基本语法规范：
    1：语句不需要用 ; 作为语句结束符；原则上一行就是一条语句，如果语句需要换行则使用 \ 换行；但是{}，[]，()中的语句换行无需使用 \ ；
    2：代码块不使用{}作为划分方式，而是通过缩进来确认同一段代码块；即：同一个代码块中的代码缩进必须保持一致；
    3：函数，方法使用空行作为分割，代表一段新的代码开始，类和函数入口也需要空行分割；
    4：注释：
        单行注释：#
        多行注释：#，''',""";
    5：标识符命名规则：
        1：由字母，数字，下划线组成，不能以数字开始；
        2：不能和关键字冲突；
        3：要有可读性；
        4：对大小写敏感；
        5：不推荐使用_或者__作为标识符命名前缀；
    6：字符编码：
        1：python2.x以ascll作为默认字符编码，因此仅仅支持英文，需要输出中文时必须在文件开头加上;# -*- coding: UTF-8 -*-
        2：python3.x默认以utf-8做为字符编码；
基本数据类型：
    1：number类型：
        int: 整数
            特征：允许二进制，十进制，八进制，十六进制；
                 相比python2.x版本没有long型；
                 大小无限制；
            转换：int(var)/int(str,base=n)
                 其中：int(var)默认将变量var转换为十进制整数；
                      int(str,base=n)n为进制，可以将n进制的字符串str转换为10进制的整数；
        float:浮点数
            特征：允许两种表示方式：小数形式，指数形式；
                 大小无限制；
            转换：float(var)
                 其中：float(var)默认将变量var转换为十进制浮点数；

        complex:复数；
    2：布尔类型：
        bool：开关量；
            特征：
                1:python中False和True才代表布尔值，其余如false,true则是非法字符；首字母一定要大写；
                2：python是弱数据类型语言，因此除过False,0,None,'',"",空的列表，空的元祖，空的set以及空的dict以外都是True;
                3：一些逻辑和比较运算结果也是布尔值；
    3：字符串：
        1：被 ' 和 " 包含的认为是字符串；
        2：python中没有字符类型，字符即为长度为1的字符串；
        3：常用的转义字符：\r \n \f \v \t \\ \' \";
        4：不希望转义字符转义时，可以使用r'',或者r""使字符串中的转义字符禁止转义；
        5：字符串使用+来连接；使用*来重复字符串：str*2;
        6：字符串索引规则：从左向右索引以0开始，从右向左以-1开始，下一个为-2，依次类推；
        7：字符串截取方法：变量[头下标:尾下标]：如：str[2],str[2:5],str[2:],str[:5];
        8：字符串长度获取：len(str);
    4：空值：None;和0不同，是标量；而且只能使用None，首字母要大写，而none则是非法字符；
    5：class：对象型；
变量：
    变量命名规范：严格遵守python标识符命名规范
                1：由数字。字母。下划线组成，且不能以数字开头
                2：不能和系统关键字冲突
                3：严格区分大小写
                4：尽量避免使用_或者__开头
                5：尽量避免使用拼音以及拼音和英语的混合
    变量声明规范：
                1：python是若数据类型语言，无需先声明后使用，可以直接在使用时声明；但是为了程序的健壮性推荐先声明并初始化之后再使用；
                2：python变量声明时无需声明数据类型，其数据类型取决于其引用的数据的数据类型；
                3：程序运行过程中允许变量引用不同数据类型的数据；
    可变对象与不可变对象：
        可变对象：
                1：可变对象是指变量所引用的内存空间中的值是可以被其他值替换的；
                2：不可变对象是指变量所引用的内存空间中的值是不可以被其他值提花的；
        可变对象/不可变对象之赋值：
                可变对象赋值：给引用可变对象的变量赋一个新值，该变量所引用的内存空间中的值将会被替换为新值，而变量依然只想该块内存空间；
                不可变对象赋值：给引用不可变对象赋一个新值，系统将会从新分配一块内存区域存储新值，然后将变量重新指向该块新的内存区域，原先的内存区域将保持不变，但失去引用；
        可变对象/不可变对象之复制：
                可变对象复制：将一个引用可变对象的变量复制给另一个变量，那么另一个变量也将指向该块可变对象内存区域，之后，任何一个指向该可变对象内存区域的变量的值一旦被更改，那么其余指向该块内存变量的值都将被更改；
                不可变对象复制：将一个引用不可变对象的变量复制给另一个变量，那么另一个变量也将指向该块不可变对象内存区域，之后，给指向该块内存区域的某个变量重新赋值，该块内存变量将会按照不可变对象赋值逻辑进行，其余指向该块内存区域的变量不受影响；
        python中变量地址的检测：
                id(var):可以打印该变量指向的内存地址；
                is和==的区别：is判断时根据两个变量是否指向同一块内存区域，而==则是判断两个变量的值是否一致；      
运算：
    算数运算：
       1：允许类型：+ - * / // %
       2：不支持自增自减运算
       3：仅支持数字参与运算
       2：/和//的区别：
                    / :除法运算，所得结果是浮点数，即便被整除，结果也是浮点数；
                    //:除法运算，所得结果是整数，即便不能被整除，结果也是整数，小数部分无论大小均被舍去；
    布尔运算：
        1：允许的计算类型：and or not（注意不要使用符号&& || ！）
        2：运算结果：仍是布尔值；
    比较运qi
        1：允许的计算类型：== != > < >= <=
        2：运算结果：仍是布尔值；
        3：is 就是判断两个对象的id是否相同， 而 == 判断的则仅判断内容是否相同。
    赋值运算：
        1：允许的计算类型：= += -= *= /= //= %=
    位运算符：
        &：按位求与运算
        |：按位求或运算
        ^：按位异或运算
        ~：按位取反运算
        <<：左移运算；
        >>：右移运算；
    成员运算符：
        in  如果再指定的序列中找到值返回True，否则返回False;
        not in 如果再指定的序列中没有找到值返回True,否则返回False;
        成员运算符支持：字符串，列表，元祖，字典，集合；
    长度获取：len()
        支持的数据类型有：字符串，列表，元祖，集合，字典；
    序列截取：
        obj[n],obj[n:],obj[n:m],obj[:m]
        支持的数据类型有：字符串，列表，元祖，字典
    
流程控制：
    条件：
            if 表达式 :
                code...
                code...
        或者：
            if 表达式 :
                code...
            else :
                code...
        或者：
            if 表达式:
                code...
            elif 表达式:
                code...
            else :
                code
    循环：
        while循环：
            while 条件 :
                code...
            
        while+else:
            while 条件 :
                code...
            else :
                code...
                (不符合while条件的时候执行,仅执行一次)
        for..in循环：
            for variable in sequence:
                code...
                (variable代表存储遍历出来的值，sequence代表被遍历的集合)

        for..in..else:
            for variable in sequence:
                code...
                (variable代表存储遍历出来的值，sequence代表被遍历的集合)
            else:
                code...
                (for循环正常终止的时候执行)

        遍历数字序列：
            for i in range(5):
                code...
            (该函数只能用来遍历数字序列)
            (range函数可以指定遍历的步长)
            (也可以使用else,在遍历完成之后进入else中执行)
        使用enumerate:
            for index,item in enumerate(sequence):
                code...
            (item代表存储遍历出来的值,index代表存储遍历出来的索引，sequence代表被遍历的集合)
            (也可以使用else,在遍历完成之后执行else中的code)
            (对于dict，key代表从0开始的索引，item是键名，值则需要通过dict的名称获取)
    备注：
        pass：在代码段或者函数中，暂时不做处理或者无内容的时候要使用pass;
              eg:if a>1 : pass

函数：
    函数声明方式：def 函数名 (参数列表) :
                    code...（函数体）
        备注： 
            1：函数以def关键字声明；
            2：函数体必须缩进，且同一个代码块缩进要统一；
            3：多个函数之间用空行隔开；
            4：函数名的命名要根据标识符来进行；

    函数调用：函数名(实参列表)
    函数形参： 
        必选参数;
            1：函数声明时要求了形参，而且没有给出默认值，此时调用函数时必须按照形参顺序给出对应的实参值；
                eg:
                    def a(q,w,e):
                        print(q,w,e)
                    a(1,2,3)
        默认参数：
            2：允许形参设置默认参数，有以下几种情况：
                    def a(q=1,w=2,e=3,r=4):
                        print(q,w,e,r)
                1:此时如果未给出实参值，将直接使用形参设置的默认值；如果给出实参值，则使用实参给出的值；
                2:如果是中间某个形参设置了默认参数，而函数调用时未提供实参值，则该参数以后的所有的参数都赋值时都要带上参数名；
                3：推荐在自定义函数的时候，尽量避免将有默认参数的形参放置在前面或者中间；
                4：如果形参是可变对象，在函数运行期间改变了该可变对象的内容，这种改变实质上是更改了形参变量所指向的内存空间中的内容；所以尽量不要给形参传递可变对象或者将其默认值设置为可变对象；
        可变参数：
            3：a：函数声明时可以声明一个接收任意多个参数的形参变量:
                    def tmp(*t):
                        print(t)
                        print(type(t))
                    tmp(1,2,3)
                    备注：   1：该形参变量必须使用*var这中方式声明；
                            2：函数中只能将存储不定长参数的变量放置在最后面；不能放置形参列表的前面或者中间位置；
                            3：该变量在函数内部是一个tuple;所有接收到的参数都会存储在tuple中；
                            4：给存储不定长参数赋值时仍然按照普通的赋值方式赋值；
                            5：而且允许使用*list/*tuple将列表和元组中的元素变成可变参数传入；接收到的参数将会组成
                             tuple;
                                def tmp(*t):
                                    print(t)
                                    print(type(t))

                                list_tmp = [1,2,3,4]
                                tmp(*list_tmp)
            关键字参数：
                c：python允许声明一种变量来接收dict字典；这种形参变量即为关键字参数；
                        
                    备注：1：声明方式为**var；而且这种方式只能用来接收dict这种类型的实参，
                         2：var本质上就是一个dict，内容是传递给var的实参dict；即var会将dict中的内容拷贝一份，存放在新的内存空间；
                         2：如果通过var改变了传进来的dict的内容，外部的dict不受影响；因此推荐使用这种方式接收dict参数；
                    def tmp(**t):
                        print(t)
                        print(type(t))

                    dict_tmp = {"name":"tom","age":23,"sex":"mail"}
                    tmp(**dict_tmp)
            限制关键字参数：
                e：限制性关键字参数前面需要使用*来分割
                   如果限制性关键字参数前面使用了可变参数：则可以不使用*作为分隔符；
            参数组合：
                必选参数，默认参数，可变参数，关键字参数，限制关键字参数，
                1:尽量避免过多组合；
                2:尽量避免使用限制性关键字参数
                3：推荐直接使用(*var,**param)来接收任意类型，任意多个参数；

    函数返回值：使用return返回值；
        备注：
            1：如果return没有返回具体的值，则返回none;
            2：可以有多个return；但是只会执行一个return;
    
    变量作用域：
        变量作用域类型：
            全局作用域
            闭包函数外的函数中
            局部作用域；
        查找规则：
            局部作用域->闭包函数外的函数中->全局作用域;
        作用域围栏：
            python中只有类，函数，模块才会引入新的作用域，其他的代码块是不会产生作用域的；
        作用域访问规则：
            当前作用域声明的变量只能在当前作用域及以下作用域访问；不能向上突破；
        备注： 
            作用域在函数未执行前就已经形成了，作用域链也生成了，
            解释器在查找变量的时候按照上述规则查找；
    函数的名称：
        每个函数都有一个__name__属性，可以拿到变量的名称；
函数式编程：

    匿名函数：python使用lambda来创建匿名函数；
        备注： 
            1：声明方式：lambda [arg1,[arg2,arg3,...]]:expersion
            2：调用方式：匿名函数需要赋值给变量，通过变量调用；
    
    高阶函数：
        1：将函数作为实参传递给函数，接收函数作为实参的函数就称为高阶参数函数；
            通过高阶参数函数可以实现处理函数的无状态特性；
            eg：高阶参数函数：
                def tmp (x,y,f) :
                    return f(x)+f(y)

                def auto_add (param) :
                    return param+1

                print(tmp(-1,-2,auto_add))
        2：函数可以将函数作为返回值返回；将函数作为返回值的函数称为闭包函数；或者称为高阶返回函数；
            eg:
                def account():
                    a = [0]
                    def addCount():
                        a[0]=a[0]+1
                        print(a[0])
                    return addCount
            注意：重点：
                1：返回一个函数的时候，该闭包函数并未执行；只有在调用该闭包函数的时候才会执行；
                2：调用闭包函数时，如果闭包函数引用了闭包外部的变量，则该变量的值是外部函数执行完成后对该变量最后一次写入的值；
                3：闭包函数中不要引用外部任何可变对象；原因在于外部的可变对象的值有可能会被更改；
                4：闭包可以实现变量保护
            如：
                def count():
                    fs = []
                    for i in range(1,4):
                        def f():
                            return i*i
                        fs.append(f)
                    return fs

                res = count()
                f1 = res[0]
                f2 = res[1]
                f3 = res[2]
                print(f1())9
                print(f2())9
                print(f3())9
                原因在于每次循环的时候所创建的闭包函数并不会执行，只有在调用f1(),f2(),f3()的时候闭包函数才会执行，此时访问的变量i是最后一次循环修改之后的值；
        3:装饰器
            1：装饰器本质上是一个为函数加上前置功能代码的函数；其功能单一：仅仅只是为目标函数加上提前指定好的一些代码，并将加好代码之后的函数对象返回；
                
            2：装饰器原理：
                装饰器函数本质上是一个闭包函数，装饰器必须在闭包中为目标函数添加装饰代码，并调用目标函数；
                在调用目标函数时，应先调用装饰器函数，并传入目标函数，获取被装饰之后的函数，赋值给目标函数名；
                eg:
                    #装饰函数
                    def writeLog(func):
                        def log():
                            #对目标函数的装饰要在闭包中进行，可以在调用目标函数之前与之后添加对应代码，实现不改变目标函数源代码的情况下为目标函数增加功能；并将函数的执行结果返回；
                            print("开始执行函数")
                            res = func()
                            print("函数已执行完)
                            return res
                        return log
                    #目标函数
                    def bar():
                        print("bar")
                        return "end"
                    #获取装饰后的函数
                    bar = writeLog(bar);
                    #执行装饰后的函数，本质上是执行装饰器中的log函数；
                    bar()
            3：装饰器为何要使用闭包实现：
                1：装饰器在意图上仅仅只是需要 "装饰" 某个函数，并将装好之后的函数返回；
                2：如果直接在函数中添加前置代码并调用目标函数，将会导致：
                    1：装饰器失去了装饰目标函数的意图：即装饰了目标函数而且还执行了目标函数；
                    2：在需要调用目标函数的地方都需要去调用装饰器函数，会导致代码意义不够明确；
                    eg:
                        def writeLog(func):
                                print("记录日志")
                                return func()
                        此时调用writeLog，将会直接执行func函数；失去了装饰器的意义，增加了代码的混乱程度；

                3：如果使用闭包实现：则闭包函数中可以实现对目标函数的装饰，闭包函数返回装饰后的函数时并不会立即执行，是否执行取决于程序本身，满足了装饰器的意图以及保证了代码的意义明确；

            4：通过@使用装饰器：@是个语法糖，代替的调用高阶返回函数那一步；使用时装饰器必须在目标函数之前声明；
                使用方式：@装饰器函数名
                         def fun_name():
                            code....
            5:使用带有参数的装饰器
                声明装饰器函数是，闭包外函数可根据需求接收对应参数；
                def paramWriteLog(level="debug"):
                    def writeLog(func):
                        def log():
                            print("记录日志")
                            return func()
                        return log
                    return writeLog

                @paramWriteLog("info")
                def foo():
                    print("you are foo")
                即：如果装饰器需要带上参数，则要在原来的装饰器外面增加一层，来接收参数；
                    使用时如有必要可以传入参数；
                
            6：被装饰函数若有参数：
                如果被装饰器函数若有参数，则该参数需要在闭包中接收，处理，传递给目标函数
                    def deco(func):  
                        def _deco(a, b):#内嵌包装函数的形参和返回值与原函数相同  
                            print("before myfunc() called.")  
                            result = func(a, b)  
                            print("after myfunc() called.")  
                            return result  
                        return _deco    #装饰函数返回内嵌包装函数对象  
                    
                    @deco  
                    def myfunc(a,b):  
                        print("myfunc(%s,%s) called." % (a, b))  
                        return a + b  
                    
                    print myfunc(1, 2)#实际上，调用的是_deco函数  
                上述装饰器的闭包函数只能接受两个参数，可以使用：
                    def _deco(*arg,**args):   来接收任意多个参数
            7:同一个函数可以被多个装饰器装饰；
        装饰器相关知识总结：
            1：装饰器的作用
            2：装饰器的实现原理和使用原理
            3：装饰器为何要使用闭包实现：
            4：python提供的装饰器语法糖
            5：装饰器修饰带有形参的目标函数
            6：装饰器本身带有形参
            7：同一个函数被多个装饰器装饰
    偏函数：
        1：偏函数是functools提供的一个功能，可以固定某些函数的默认参数，将结果返回个一个新的函数名，来减少调用函数时提供的参数个数
        2：使用方式：
            func_new_name = functools.partial(func_old_name,param=val)
        3:eg：
            import functools

            def a(arg1,arg2):
                if arg2==1:
                    print("arg2 = 1;arg1-----",arg1)
                else:
                    print("arg2 != 1;arg1-----",arg1)

            b = functools.partial(a,arg2=2)
            b(1)
    
    


    
    






        
    


    


        
    
        





    


    

    