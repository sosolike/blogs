基本语法规范：
    1：语句不需要用 ; 作为语句结束符；原则上一行就是一条语句，如果语句需要换行则使用 \ 换行；但是{}，[]，()中的语句换行无需使用 \ ；
    2：代码块不使用{}作为划分方式，而是通过缩进来确认同一段代码块；即：同一个代码块中的代码缩进必须保持一致；
    3：函数，方法使用空行作为分割，代表一段新的代码开始，类和函数入口也需要空行分割；
    4：注释：
        单行注释：#
        多行注释：#，''',""";
    5：标识符命名规则：
        1：由字母，数字，下划线组成，不能以数字开始；
        2：不能和关键字冲突；
        3：要有可读性；
        4：对大小写敏感；
        5：不推荐使用_或者__作为标识符命名前缀；
    6：字符编码：
        1：python2.x以ascll作为默认字符编码，因此仅仅支持英文，需要输出中文时必须在文件开头加上;# -*- coding: UTF-8 -*-
        2：python3.x默认以utf-8做为字符编码；
基本数据类型：
    1：number类型：
        int: 整数
            特征：允许二进制，十进制，八进制，十六进制；
                 相比python2.x版本没有long型；
                 大小无限制；
            转换：int(var)/int(str,base=n)
                 其中：int(var)默认将变量var转换为十进制整数；
                      int(str,base=n)n为进制，可以将n进制的字符串str转换为10进制的整数；
        float:浮点数
            特征：允许两种表示方式：小数形式，指数形式；
                 大小无限制；
            转换：float(var)
                 其中：float(var)默认将变量var转换为十进制浮点数；

        complex:复数；
    2：布尔类型：
        bool：开关量；
            特征：
                1:python中False和True才代表布尔值，其余如false,true则是非法字符；首字母一定要大写；
                2：python是弱数据类型语言，因此除过False,0,None,'',"",空的列表，空的元祖，空的set以及空的dict以外都是True;
                3：一些逻辑和比较运算结果也是布尔值；
    3：字符串：
        1：被 ' 和 " 包含的认为是字符串；
        2：python中没有字符类型，字符即为长度为1的字符串；
        3：常用的转义字符：\r \n \f \v \t \\ \' \";
        4：不希望转义字符转义时，可以使用r'',或者r""使字符串中的转义字符禁止转义；
        5：字符串使用+来连接；使用*来重复字符串：str*2;
        6：字符串索引规则：从左向右索引以0开始，从右向左以-1开始，下一个为-2，依次类推；
        7：字符串截取方法：变量[头下标:尾下标]：如：str[2],str[2:5],str[2:],str[:5];
        8：字符串长度获取：len(str);
    4：空值：None;和0不同，是标量；而且只能使用None，首字母要大写，而none则是非法字符；
    5：class：对象型；
变量：
    变量声明：
        1：变量命名应该严格遵守python变量命名规范；
        2：推荐变量使用之前先声明并初始化，一来为了避免出错，而来为了程序的可读性；
        3：python是弱数据类型语言，因此变量没有自己的数据类型，变量的数据类型和其指向的数据的数据类型相同；
        4：程序运行过程中，同一个变量可以指向不同类型的数据；
    python中的可变对象和不可变对象：
            1:可变对象： 
                可变对象是指内存空间中存放该可变对象值的内存空间是中的内容是可以改变的；即：内存空间中的内容可以被更改；  
            2:对于不可变对象：
                不可变对象是指内存空间中存放该不可变对象值的内存空间是被该不可变对象值持久占有的，无法再写入其他内容。即：内存空间一旦初始化将永远是初始化的值，无法再被更改；
            3:python中的可变对象和不可变对象：
                python中的不可变对象：int型，float型，str型，tuple型，None型数据，均是不可变对象；
                python中的可变对象：list,dict 
            4：引用可变对象及引用不可变对象的变量的赋值：
                1：对于可变对象：给变量从新赋值之后，原来变量指向的内存空间的值将会被覆盖；存储上新的值；变量对内存空间的指向并不会改变；
                2：对于不可变对象：给变量从新赋值之后，将会开辟一块新的内存来存储新赋的值，当前变量的指向了另外的内存区域；原先的内存空间中的内容并没有被改变，变量的指向发生了改变；
                3：变量指向的内存地址可以通过id()函数获取；
                4：判断两个变量是否相等可以通过：==来判断；判断两个变量是否指向同一个内存区域可以使用：is来判断；
                    即：==检测的是值，is检测的是内存地址；
            6：变量复制：
                对于可变对象：
                如：b所引用的是可变对象：
                    a = b；本质上是将变量b所引用的数据所在的内存地址赋值给了变量a;变量a也指向了这块内存区域；并不会为a开辟新的内存空间；因此变量a和变量b任意一个的值发生变化，实质上都是直接更改对应内存地址处所存放的数据内容；因此会引起所有指向该块内存区域的变量值的变化；
                对于不可变对象：
                如：b所引用的是不可变对象
                    a=b；将变量b的值赋给a的时候，变量a和b将指向同一块内存区域，只有在其中某个变量赋上新值的时候才会为其开辟新内存空间，并将变量指向新内存空间；
运算：
    算数运算：
       1：允许类型：+ - * / // %
       2：不支持自增自减运算
       3：仅支持数字参与运算
       2：/和//的区别：
                    / :除法运算，所得结果是浮点数，即便被整除，结果也是浮点数；
                    //:除法运算，所得结果是整数，即便不能被整除，结果也是整数，小数部分无论大小均被舍去；
    布尔运算：
        1：允许的计算类型：and or not（注意不要使用符号&& || ！）
        2：运算结果：仍是布尔值；
    比较运算：
        1：允许的计算类型：== != > < >= <=
        2：运算结果：仍是布尔值；
        3：is 就是判断两个对象的id是否相同， 而 == 判断的则仅判断内容是否相同。
    赋值运算：
        1：允许的计算类型：= += -= *= /= //= %=
    位运算符：
        &：按位求与运算
        |：按位求或运算
        ^：按位异或运算
        ~：按位取反运算
        <<：左移运算；
        >>：右移运算；
    成员运算符：
        in  如果再指定的序列中找到值返回True，否则返回False;
        not in 如果再指定的序列中没有找到值返回True,否则返回False;
        成员运算符支持：字符串，列表，元祖，字典，集合；
    长度获取：len()
        支持的数据类型有：字符串，列表，元祖，集合，字典；
    序列截取：
        obj[n],obj[n:],obj[n:m],obj[:m]
        支持的数据类型有：字符串，列表，元祖，字典
    
流程控制：
    条件：
            if 表达式 :
                code...
                code...
        或者：
            if 表达式 :
                code...
            else :
                code...
        或者：
            if 表达式:
                code...
            elif 表达式:
                code...
            else :
                code
    循环：
        while循环：
            while 条件 :
                code...
            
        while+else:
            while 条件 :
                code...
            else :
                code...
                (不符合while条件的时候执行,仅执行一次)
        for..in循环：
            for variable in sequence:
                code...
                (variable代表存储遍历出来的值，sequence代表被遍历的集合)

        for..in..else:
            for variable in sequence:
                code...
                (variable代表存储遍历出来的值，sequence代表被遍历的集合)
            else:
                code...
                (for循环正常终止的时候执行)

        遍历数字序列：
            for i in range(5):
                code...
            (该函数只能用来遍历数字序列)
            (range函数可以指定遍历的步长)
            (也可以使用else,在遍历完成之后进入else中执行)
        使用enumerate:
            for index,item in enumerate(sequence):
                code...
            (item代表存储遍历出来的值,index代表存储遍历出来的索引，sequence代表被遍历的集合)
            (也可以使用else,在遍历完成之后执行else中的code)
            (对于dict，key代表从0开始的索引，item是键名，值则需要通过dict的名称获取)
    备注：
        pass：在代码段或者函数中，暂时不做处理或者无内容的时候要使用pass;
              eg:if a>1 : pass

函数：
    函数声明方式：def 函数名 (参数列表) :
                    code...（函数体）
        备注： 
            1：函数以def关键字声明；
            2：函数体必须缩进，且同一个代码块缩进要统一；
            3：多个函数之间用空行隔开；
            4：函数名的命名要根据标识符来进行；

    函数调用：函数名(实参列表)
    函数形参： 
        必选参数;
            1：函数声明时要求了形参，而且没有给出默认值，此时调用函数时必须按照形参顺序给出对应的实参值；
                eg:
                    def a(q,w,e):
                        print(q,w,e)
                    a(1,2,3)
        默认参数：
            2：允许形参设置默认参数，有以下几种情况：
                    def a(q=1,w=2,e=3,r=4):
                        print(q,w,e,r)
                1:此时如果未给出实参值，将直接使用形参设置的默认值；如果给出实参值，则使用实参给出的值；
                2:如果是中间某个形参设置了默认参数，而函数调用时未提供实参值，则该参数以后的所有的参数都赋值时都要带上参数名；
                3：推荐在自定义函数的时候，尽量避免将有默认参数的形参放置在前面或者中间；
                4：如果形参是可变对象，在函数运行期间改变了该可变对象的内容，这种改变实质上是更改了形参变量所指向的内存空间中的内容；所以尽量不要给形参传递可变对象或者将其默认值设置为可变对象；
        可变参数：
            3：a：函数声明时可以声明一个接收任意多个参数的形参变量:
                    def tmp(*t):
                        print(t)
                        print(type(t))
                    tmp(1,2,3)
                    备注：   1：该形参变量必须使用*var这中方式声明；
                            2：函数中只能将存储不定长参数的变量放置在最后面；不能放置形参列表的前面或者中间位置；
                            3：该变量在函数内部是一个tuple;所有接收到的参数都会存储在tuple中；
                            4：给存储不定长参数赋值时仍然按照普通的赋值方式赋值；
                            5：而且允许使用*list/*tuple将列表和元组中的元素变成可变参数传入；接收到的参数将会组成
                             tuple;
                                def tmp(*t):
                                    print(t)
                                    print(type(t))

                                list_tmp = [1,2,3,4]
                                tmp(*list_tmp)
            关键字参数：
                c：python允许声明一种变量来接收dict字典；这种形参变量即为关键字参数；
                        
                    备注：1：声明方式为**var；而且这种方式只能用来接收dict这种类型的实参，
                         2：var本质上就是一个dict，内容是传递给var的实参dict；即var会将dict中的内容拷贝一份，存放在新的内存空间；
                         2：如果通过var改变了传进来的dict的内容，外部的dict不受影响；因此推荐使用这种方式接收dict参数；
                    def tmp(**t):
                        print(t)
                        print(type(t))

                    dict_tmp = {"name":"tom","age":23,"sex":"mail"}
                    tmp(**dict_tmp)
            限制关键字参数：
                e：限制性关键字参数前面需要使用*来分割
                   如果限制性关键字参数前面使用了可变参数：则可以不使用*作为分隔符；
            参数组合：
                必选参数，默认参数，可变参数，关键字参数，限制关键字参数，
                1:尽量避免过多组合；
                2:尽量避免使用限制性关键字参数
                3：推荐直接使用(*var,**param)来接收任意类型，任意多个参数；

    函数返回值：使用return返回值；
        备注：
            1：如果return没有返回具体的值，则返回none;
            2：可以有多个return；但是只会执行一个return;
    
    变量作用域：
        变量作用域类型：
            全局作用域
            闭包函数外的函数中
            局部作用域；
        查找规则：
            局部作用域->闭包函数外的函数中->全局作用域;
        作用域围栏：
            python中只有类，函数，模块才会引入新的作用域，其他的代码块是不会产生作用域的；
        作用域访问规则：
            当前作用域声明的变量只能在当前作用域及以下作用域访问；不能向上突破；
        备注： 
            作用域在函数未执行前就已经形成了，作用域链也生成了，
            解释器在查找变量的时候按照上述规则查找；
    函数的名称：
        每个函数都有一个__name__属性，可以拿到变量的名称；
函数式编程：

    匿名函数：python使用lambda来创建匿名函数；
        备注： 
            1：声明方式：lambda [arg1,[arg2,arg3,...]]:expersion
            2：调用方式：匿名函数需要赋值给变量，通过变量调用；
    
    高阶函数：
        1：将函数作为实参传递给函数，接收函数作为实参的函数就称为高阶参数函数；
            通过高阶参数函数可以实现处理函数的无状态特性；
            eg：高阶参数函数：
                def tmp (x,y,f) :
                    return f(x)+f(y)

                def auto_add (param) :
                    return param+1

                print(tmp(-1,-2,auto_add))
        2：函数可以将函数作为返回值返回；将函数作为返回值的函数称为闭包函数；或者称为高阶返回函数；
            eg:
                def account():
                    a = [0]
                    def addCount():
                        a[0]=a[0]+1
                        print(a[0])
                    return addCount
            注意：重点：
                1：返回一个函数的时候，该闭包函数并未执行；只有在调用该闭包函数的时候才会执行；
                2：调用闭包函数时，如果闭包函数引用了闭包外部的变量，则该变量的值是外部函数执行完成后对该变量最后一次写入的值；
                3：闭包函数中不要引用外部任何可变对象；原因在于外部的可变对象的值有可能会被更改；
                4：闭包可以实现变量保护
            如：
                def count():
                    fs = []
                    for i in range(1,4):
                        def f():
                            return i*i
                        fs.append(f)
                    return fs

                res = count()
                f1 = res[0]
                f2 = res[1]
                f3 = res[2]
                print(f1())9
                print(f2())9
                print(f3())9
                原因在于每次循环的时候所创建的闭包函数并不会执行，只有在调用f1(),f2(),f3()的时候闭包函数才会执行，此时访问的变量i是最后一次循环修改之后的值；
        3:装饰器
            1：装饰器本质上是一个为函数加上前置功能代码的函数；其功能单一：仅仅只是为目标函数加上提前指定好的一些代码，并将加好代码之后的函数对象返回；
                
            2：装饰器原理：
                装饰器函数本质上是一个闭包函数，装饰器必须在闭包中为目标函数添加装饰代码，并调用目标函数；
                在调用目标函数时，应先调用装饰器函数，并传入目标函数，获取被装饰之后的函数，赋值给目标函数名；
                eg:
                    #装饰函数
                    def writeLog(func):
                        def log():
                            #对目标函数的装饰要在闭包中进行，可以在调用目标函数之前与之后添加对应代码，实现不改变目标函数源代码的情况下为目标函数增加功能；并将函数的执行结果返回；
                            print("开始执行函数")
                            res = func()
                            print("函数已执行完)
                            return res
                        return log
                    #目标函数
                    def bar():
                        print("bar")
                        return "end"
                    #获取装饰后的函数
                    bar = writeLog(bar);
                    #执行装饰后的函数，本质上是执行装饰器中的log函数；
                    bar()
            3：装饰器为何要使用闭包实现：
                1：装饰器在意图上仅仅只是需要 "装饰" 某个函数，并将装好之后的函数返回；
                2：如果直接在函数中添加前置代码并调用目标函数，将会导致：
                    1：装饰器失去了装饰目标函数的意图：即装饰了目标函数而且还执行了目标函数；
                    2：在需要调用目标函数的地方都需要去调用装饰器函数，会导致代码意义不够明确；
                    eg:
                        def writeLog(func):
                                print("记录日志")
                                return func()
                        此时调用writeLog，将会直接执行func函数；失去了装饰器的意义，增加了代码的混乱程度；

                3：如果使用闭包实现：则闭包函数中可以实现对目标函数的装饰，闭包函数返回装饰后的函数时并不会立即执行，是否执行取决于程序本身，满足了装饰器的意图以及保证了代码的意义明确；

            4：通过@使用装饰器：@是个语法糖，代替的调用高阶返回函数那一步；使用时装饰器必须在目标函数之前声明；
                使用方式：@装饰器函数名
                         def fun_name():
                            code....
            5:使用带有参数的装饰器
                声明装饰器函数是，闭包外函数可根据需求接收对应参数；
                def paramWriteLog(level="debug"):
                    def writeLog(func):
                        def log():
                            print("记录日志")
                            return func()
                        return log
                    return writeLog

                @paramWriteLog("info")
                def foo():
                    print("you are foo")
                即：如果装饰器需要带上参数，则要在原来的装饰器外面增加一层，来接收参数；
                    使用时如有必要可以传入参数；
                
            6：被装饰函数若有参数：
                如果被装饰器函数若有参数，则该参数需要在闭包中接收，处理，传递给目标函数
                    def deco(func):  
                        def _deco(a, b):#内嵌包装函数的形参和返回值与原函数相同  
                            print("before myfunc() called.")  
                            result = func(a, b)  
                            print("after myfunc() called.")  
                            return result  
                        return _deco    #装饰函数返回内嵌包装函数对象  
                    
                    @deco  
                    def myfunc(a,b):  
                        print("myfunc(%s,%s) called." % (a, b))  
                        return a + b  
                    
                    print myfunc(1, 2)#实际上，调用的是_deco函数  
                上述装饰器的闭包函数只能接受两个参数，可以使用：
                    def _deco(*arg,**args):   来接收任意多个参数
            7:同一个函数可以被多个装饰器装饰；
        装饰器相关知识总结：
            1：装饰器的作用
            2：装饰器的实现原理和使用原理
            3：装饰器为何要使用闭包实现：
            4：python提供的装饰器语法糖
            5：装饰器修饰带有形参的目标函数
            6：装饰器本身带有形参
            7：同一个函数被多个装饰器装饰
    偏函数：
        1：偏函数是functools提供的一个功能，可以固定某些函数的默认参数，将结果返回个一个新的函数名，来减少调用函数时提供的参数个数
        2：使用方式：
            func_new_name = functools.partial(func_old_name,param=val)
        3:eg：
            import functools

            def a(arg1,arg2):
                if arg2==1:
                    print("arg2 = 1;arg1-----",arg1)
                else:
                    print("arg2 != 1;arg1-----",arg1)

            b = functools.partial(a,arg2=2)
            b(1)
    
    


    
    






        
    


    


        
    
        





    


    

    