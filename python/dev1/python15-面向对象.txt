python面向对象编程:
类：
    1：类的声明：class ClassName(object):
                    类成员...
    2：类声明时的注意事项：
        1：类声明需要使用class
        1：类名推荐驼峰式命名法命名，每个单词首字母都要大写
        2：类的代码块依靠缩进保证；
        3：python中类的继承使用()中放置需要继承的类；一般继承object即可；
            如定义一个异常类：MyException(Exception)即为创建一个类，并继承Exception
        4：类中有属性和方法两类元素；

对象：
    1：对象本质上是对类的封装
    2：通过对象可以调用类中实例属性和实例方法
    3：对象的实例化：obj = ClassName();
    4：类中和对象有关的内置函数：
        1：检测对象类型：isinstance(obj,ClassName)
        2：获取对象所有的属性和方法：dir();
        3：检测对象是否有指定属性：hasattr(obj,"x")
        4：操作属性：getattr()、setattr()
    注意：python中不是通过new关键字来创建对象的；
 
属性：
    1：实例属性：
        1:属于对象的属性
        2:声明：
            1：在类的内部通过self.abbrName的方式绑定的均是实例属性；
            2：在类外部可以通过类对象绑定任意实例属性；如：obj.name="tom"来创建实例属性

          备注：
            1：在类的任意一个实例方法中通过self.attrName都可以创建实例属性，但是比较混乱，推荐需要的示例属性均在构造函数中创建；
            2：在类外部通过对象直接创建实例属性不可取，尽量避免通过对象直接创建属性；
        3:访问：
            在类的内部：self.abbrName来访问
            在类的外部：obj.abbrName来访问

    2：类属性：
        声明：
            1：在类内部声明：eg：name = "tom"
        访问：
            1：无论类的内部还是外部均通过ClassName.abbrName来访问
        备注： 
            1：如果实例属性名称和类属性名称一致时，优先访问实例属性；所以为避免出错尽量避免同名；
            2：类属性属于类所有
            3：类属性的声明位置只能在类中

构造函数：
    声明：def __init__(self):
            code...
    备注:
        1：名称固定：__init__
        1：构造函数起初始化作用；并非用来创建对象
        2：构造函数必须要有self参数，代表对象本身；必须放在第一个位置，形参是从第二个开始算起的
        3：构造函数如果声明了除过self以外的形参，则在创建对象是必须给予实参，实参赋值是从第二个开始的；
        4：一般推荐在构造函数中声明实例属性和对实例属性进行初始化

方法：
    实例方法：

        声明：def function_name(self):
                code...
        备注:
            1：实例方法的声明和函数的声明一致；
            2：实例方法是属于对象的；
            3：方法中至少要有self参数；且必须放在第一个位置，其余形参从第二个位置开始声明；
            4：调用实例方法赋值时，实参从第二个参数开始
            5：在类内部通过self.function_name调用
               在类外部通过obj.function_name调用
        
    静态方法：
        声明：
            @staticmethod
            def function_name():
                code...
        备注：
            1：静态方法需要使用@staticmethod修饰，声明方式和普通函数声明一致；
            2：静态方法没有self参数，形参从第一个位置算起；实参赋值时也是从第一个位置开始的；
            3：可以被类和类实例调用；尽量不要使用对象调用静态方法；
            4：只能访问类变量和类方法，静态方法，以及传入的变量，不能在静态方法中调用/声明实例变量，以及调用实例方法；
            5：访问方式使用类名.方法名；
    
    类方法：
        声明：
            @classmethod
            def function_name(cls):
                code...
        备注： 
            1：类方法需要被@classmethod修饰
            2：默认参数是cls，传入的参数默认从第二个开始赋值；
            3：类方法中只能访问类属性和类方法,静态方法，不能访问实例属性和实例方法；
            4：调用时使用类名.类方法调用；
            
封装：
    1：以非__开头命名的变量在类内部以及外部均可被正常访问
    2：以__命名的变量将会被解释器修改为_类名__属性名的形式，在类的外部通过__属性名将无法拿到该属性；
    3：以__命名的变量或者方法不会被子类覆盖，因为子类名不可能和父类一致，因此被解释器修改之后不会和父类重名；
    4：

继承：
    1：python中继承语法：class ClassName(ParentClass1,ParentClass2):
    2：继承之后的结果：
        子类继承父类之后拥有父类的所有属性和方法;
    3：python中支持多继承，即一个子类可以有多个父类；
    4：子类中访问父类属性和方法：
        1：类属性：ParentClassName.abbrName;
           实例属性：self.abbrName;
        2：类方法/静态方法：ParentClassName.funName;
            实例方法：ParentClassName.funName(self)
        3：由于python支持多继承，因此如果多个父类中有同名实例方法或者实例属性，此时通过self或者子类实例调用父类方法时，将默认调用第一个父类中的属性及方法；
    5：通过子类实例访问父类中的方法或者属性：
        如果子类中有该父类同名属性或者方法，则直接调用子类中的该方法
        如果子类中没有将会调用父类中的方法，如果多个父类中均有该方法，则以第一个父类为准；
    6：构造方法：
        1：如果子类有自己的构造方法则直接调用自己的构造方法，不再调用父类的构造方法
        2：如果子类没有构造方法将会直接调用父类构造方法，以第一个父类的构造方法为准；
        3：子类中调用父类构造方法：ParentClassName.__init__(self);
多态：
    多个实例均有相同的方法，传入不同的实例将会调用不同实例的同名方法；

                
                
                

            
        



    


    
