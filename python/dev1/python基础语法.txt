基本语法要求：
    1：语句不需要用 ; 作为语句结束符；原则上一行就是一条语句，如果语句需要换行则使用 \ 换行；但是{}，[]，()中的语句换行无需使用 \ ；
    2：代码块不使用{}作为划分方式，而是通过缩进来确认同一段代码块；即：同一个代码块中的代码缩进必须保持一致；
    3：函数，方法使用空行作为分割，代表一段新的代码开始，类和函数入口也需要空行分割；
    4：注释：
        单行注释：#
        多行注释：#，''',""";
    5：标识符命名规则：
        1：由字母，数字，下划线组成，不能以数字开始；
        2：对大小写敏感；
    6：字符编码：
        1：python2.x以ascll作为默认字符编码，python3.x默认以utf-8做为字符编码；
基本数据类型：
    1：number类型：
        int: 整数
            允许二进制，十进制，八进制，十六进制；
            相比python2.x版本没有long型；
            大小无限制；
        float:浮点数
            允许两种表示方式：小数形式，指数形式；
            大小无限制；
        complex:复数；
    2：布尔类型：
        bool：开关量；
    3：字符串：
        1：被 ' 和 " 包含的认为是字符串；
        2：python没有字符类型，一个字符即为长度为1的字符串；
        3：常用的转义字符：\r \n \f \v \t \\ \' \";
        4：可以使用r'',或者r""使字符串中的转义字符禁止转义；
        5：字符串使用+来连接；使用*来重复字符串：str*2;
        6：字符串索引规则：从右向左索引以0开始，从左向右以-1开始；
        7：字符串截取方法：变量[头下标:尾下标]：如：str[2],str[2,5],str[2:];
    4：空值：none;和0不同，是标量；
变量：
    变量命名：
        1：以数字，字母，下划线组成；不能以数字开头；
        2：变量名严格区分大小写；
        3：变量在初始化的时候无需指定数据类型；
        4：同一个变量可以指向不同类型的数据；
        5：变量的数据类型和其指向的数据的数据类型相同；
        6：变量复制：
            a = b；将变量b赋值给变量a,此时并不会为变量a分配内存空间，仅仅是将变量a指向变量b所指向的数据；
        7：变量中的不可变对象和可变对象：
            不可变对象：
                该对象指向内存中的值是不能被改变的；一个变量如果引用的是一个不可变对象，此时从新给变量复制的时候，因为该不可变对象的值不能被改变，因此会把原来的值复制一份，然后让该变量引用复制之后的值，再用新的内容覆盖掉复制来的值；
            可变对象：
                即对象指向内存中的值是可以被改变的，同样上述变量从新赋值，将会直接修改当前变量引用的保存在内存中的值；并不会有复制的过程；
            python中的不可变对象：int型，float型，str型，tuple型，None型数据，均是不可变对象；
            由于python存在不可变对象和可变对象的概念，因此；
                可变对象的赋值是浅赋值，传递的是值的地址；因此当指向该值的任意一个变量发生改变，都会引起其他变量的改变
常量：
    常量命名：
        1：以数字，字母，下划线组成；不能以数字开头；
        2：常量名严格区分大小写；推荐以大写+下划线的方式命名；
运算：
    算数运算：
       1：允许类型：+ - * / // %
       2：/和//的区别：
                    / :除法运算，所得结果是浮点数，即便被整除，结果也是浮点数；
                    //:除法运算，所得结果是整数，即便不能被整除，结果也是整数，小数部分无论大小均被舍去；
    布尔运算：
        1：允许的计算类型：and or not
        2：运算结果：仍是布尔值；
    比较运算：
        1：允许的计算类型：== != > < >= <=
        2：运算结果：仍是布尔值；
        3：is 就是判断两个对象的id是否相同， 而 == 判断的则是内容是否相同。
    赋值运算：
        1：允许的计算类型：= += -= *= /= //= %=
    位运算符：
        &：按位求与运算
        |：按位求或运算
        ^：按位异或运算
        ~：按位取反运算
        <<：左移运算；
        >>：右移运算；
    成员运算符：
        in  如果再指定的序列中找到值返回true，否则返回false;
        not in 如果再指定的序列中没有找到值返回true,否则返回false;
    
流程控制：
    条件：
            if 表达式 :
                code...
                code...
        或者：
            if 表达式 :
                code...
            else :
                code...
        或者：
            if 表达式:
                code...
            elif 表达式:
                code...
            else :
                code
    循环：
        while循环：
            while 条件 :
                code...
            
        while+else:
            while 条件 :
                code...
            else :
                code...
                (不符合while条件的时候执行,仅执行一次)
        for..in循环：
            for variable in sequence:
                code...
                (variable代表存储遍历出来的值，sequence代表被遍历的集合)

        for..in..else:
            for variable in sequence:
                code...
                (variable代表存储遍历出来的值，sequence代表被遍历的集合)
            else:
                code...
                (for循环正常终止的时候执行)

        遍历数组序列：
            for i in range(5):
                code...
            (该函数只能用来遍历数字序列)
            (range函数可以指定遍历的步长)
            (也可以使用else,在遍历完成之后进入else中执行)
        使用enumerate:
            for index,item in enumerate(sequence):
                code...
            (item代表存储遍历出来的值,index代表存储遍历出来的索引，sequence代表被遍历的集合)
            (也可以使用else,在遍历完成之后执行else中的code)
    备注：
        pass：在代码段或者函数中，暂时不做处理或者无内容的时候要使用pass;
              eg:if a>1 : pass

函数：
    函数声明方式：def 函数名 (参数列表) :
                    code...（函数体）
        备注： 
            1：函数以def关键字声明；
            2：函数体必须缩进，且缩进要统一；
            3：可以使用return返回值；
            4：多个函数之间用空行隔开；

    函数调用：函数名(实参列表)
        备注： 
        必选参数;
            1：允许根据需要添加形参，此时调用函数时必须按照形参顺序给出对应的实参值；
                eg:
                    def a(q,w,e):
                        print(q,w,e)
                    a(1,2,3)
        默认参数：
            2：允许形参设置默认参数，有以下几种情况：
                    def a(q=1,w=2,e=3,r=4):
                        print(q,w,e,r)
                此时如果未给出实参值，将直接使用形参设置的默认值；
                如果给出实参值，则使用实参给出的值；
                在有多个默认参数的时候，
                    调用函数可以按照参数顺序提供实参值，后面没有提供实参的形参将使用默认值：
                        如：a(1,2),此时e参数,r参数将使用默认值；
                    如果跳过某个形参，给该形参后面的形参赋值，则后面所有形参赋值的时候需要带上形参的名称：
                        如：a(1,e=3,r=34);
                需要特别注意的是：
                    python 函数在定义的时候,如果对形参赋值，1：相当于对形参进行了初始化操作，而且仅初始化一次；2：在当前脚本文件执行的过程中，会记住形参最后一次改变的值；
            2：形参如果没有初始值，则调用函数的时候必须给形参赋值；
        可变参数：
            3：a：可以使用*var来存储不定长参数；接收到的参数默认组成一个tuple:
                    def tmp(*t):
                        print(t)
                        print(type(t))
                    tmp(1,2,3)
                b：而且允许使用*list/*tuple将列表和元组中的元素变成可变参数传入；接收到的参数将会组成tuple;
                    def tmp(*t):
                        print(t)
                        print(type(t))

                    list_tmp = [1,2,3,4]
                    tmp(*list_tmp)
            关键字参数：
                c：允许使用**var来接收一个dict,接收到之后，该形参相当于复制了一份传进来的dict；
                    def tmp(**t):
                        print(t)
                        print(type(t))

                    dict_tmp = {"name":"tom","age":23,"sex":"mail"}
                    tmp(**dict_tmp)
                d：允许使用**var来接收0个或者n个含参数名的参数；这些参数会自动组装为一个dict;
            限制关键字参数：
                e：限制性关键字参数前面需要使用*来分割
                   如果限制性关键字参数前面使用了可变参数：则可以不使用*作为分隔符；
            参数组合：
                必选参数，默认参数，可变参数，关键字参数，限制关键字参数，尽量避免过多组合；

    匿名函数：python使用lambda来创建匿名函数；
        备注： 
            1：声明方式：lambda [arg1,[arg2,arg3,...]]:expersion
            2：调用方式：匿名函数需要赋值给变量，通过变量调用；
    
    函数返回值：使用return返回值；
        备注：
            1：如果return没有返回具体的值，则返回none;
    变量作用域：
        变量作用域类型：
            局部作用域；
            闭包函数外的函数中
            全局作用域
        查找规则：
            局部作用域->闭包函数外的函数中->全局作用域;
        作用域围栏：
            python中只有类，函数，模块才会引入新的作用域，其他的代码块是不会产生作用域的；
        作用域访问规则：
            当前作用域声明的变量只能在当前作用域及以下作用域访问；不能向上突破；
        备注： 
            作用域在函数未执行前就已经形成了，作用域链也生成了，
            解释器在查找变量的时候按照上述规则查找；
            函数外部定义的变量全局可用
            函数内部定义的变量只能在函数内部使用
    尾递归：
        尾递归是指在函数返回的时候，调用函数本身，并且return语句中不能包含任何表达式，称为尾递归；
        尾递归中，无论函数调用多少次，都只占用一个栈帧，不会出现栈溢出的情况；
        但是python解释器并未对尾递归做出优化，因此在函数递归调用的时候还是会有栈溢出；






        
    


    


        
    
        





    


    

    