基本语法规范：
    1：语句不需要用 ; 作为语句结束符；也不使用其他任何符号作为语句结束符；原则上一行就是一条语句，尽量避免手动换行！
    2：代码块不使用 {} 作为划分方式，而是通过缩进来确认同一段代码块；即：同一个代码块中的代码缩进必须保持一致；
    3：空行不是python的语法要求，但是在代码中合理使用空行可以提高代码的阅读性；
    4：注释：
        单行注释：#
        多行注释：''',""";
    5：标识符命名规则：
        1：由字母，数字，下划线组成;
        2：不能以数字开头；
        2：不能和关键字冲突；
        3：标识符严格区分大小写；
        4：要具备可读性；
        5：不推荐使用_或者__作为标识符命名前缀；
    6：字符编码：
        1：python2.x以ascll作为默认字符编码，因此仅仅支持英文，需要输出中文时必须在文件开头加上;# -*- coding: UTF-8 -*-
        2：python3.x默认以utf-8做为字符编码； 
基本数据类型：
    number--数字类型
        int : 整数
            特征：
                 1：python中允许使用二进制，八进制，十进制，十六进制；
                 2：python中的整数没有范围限制；
                 3：相比python2.x，python3.x取消了long型；
            类型转换：
                 1：int(var) 将变量转换为整数；
                 2：int(var,base=n)n为进制，可以将n进制的数字字符串转换为十进制的整数；
                 3：转换之后类型改变的仅仅是转换之后的结果，变量原类型依然不变；
        float : 浮点数
            特征：
                 1：python中浮点数有两种表示方式：指数形式和小数形式；
                 2：python中的浮点数无大小限制；
            类型转换：
                 1：float(var) 将变量转换为浮点数；
                 2：转换之后类型改变的仅仅是转换之后的结果，变量原类型依然不变；
    bool--布尔类型
        1：代表开关量，只有两个值；分别为True和False;
        2：python是弱数据类型语言，因此除过False,'',"",0,None,空list,空set,空dict,空元祖以外，都是True;
        3：python中逻辑运算的结果也是布尔值；
    string--字符串
        1：被 ' 和 " 包含的认为是字符串；
        2：python中没有字符类型，字符即为长度为1的字符串；
        3：常用的转义字符：\r、\n、\t、\v、\b、\f、\\、\'、\"；
        4：禁止转义的方式为\\(双斜杠)，或者使用r''或者r""将转义字符包裹在''或者""以内即可反转义；
        5：字符串的连接使用 + ; 如str1+str2;
        6：字符串的重复使用 * ; 如str*2
        7：字符的截取：str[n]、str[n:]、str[n:m]、str[:m]
        8：字符串长度：len(str)
        9：字符串索引顺序：从左向右字符串索引从0开始，从右向左，索引从-1开始；
    None--空值
        1：None和False不同，和0不同；是单独的一个数据类型，代表空值；
        2：None中首字母N必须大写，其余写法认为是非法字符；
    class--对象型数据
变量：
    变量命名规范：严格遵守python标识符命名规范；
    变量使用规范：1：python是弱数据类型语言，无需先声明后使用，可以直接在使用时声明；但是推荐先声明并初始化之后再使用；
                2：python变量声明时无需声明数据类型，其数据类型取决于其引用的数据的数据类型；
                3：程序运行过程中允许变量引用不同数据类型的数据；
    可变对象与不可变对象：
        可变对象：
                1：可变对象是指变量所引用的内存空间中的值是可以被其他值替换的；
                2：不可变对象是指变量所引用的内存空间中的值是不可以被其他值替换的；
        可变对象/不可变对象之赋值：
                可变对象赋值：给引用可变对象的变量赋一个新值，该变量所引用的内存空间中的值将会被替换为新值，而变量依然引用该块内存空间；
                不可变对象赋值：给引用不可变对象赋一个新值，系统将会从新分配一块内存区域存储新值，然后将变量重新指向该块新的内存区域，原先的内存区域将保持不变，但失去引用；
        可变对象/不可变对象之复制：
                可变对象复制：将一个引用可变对象的变量复制给另一个变量，那么另一个变量也将指向该块可变对象内存区域，之后，任何一个指向该可变对象内存区域的变量的值一旦被更改，那么其余指向该块内存变量的值都将被更改；
                不可变对象复制：将一个引用不可变对象的变量复制给另一个变量，那么另一个变量也将指向该块不可变对象内存区域，之后，给指向该块内存区域的某个变量重新赋值，该块内存变量将会按照不可变对象赋值逻辑进行，其余指向该块内存区域的变量不受影响；
        python中变量地址的检测：
                id(var):可以打印该变量指向的内存地址；
                is和==的区别：is判断时根据两个变量是否指向同一块内存区域，而==则是判断两个变量的值是否一致；
运算：
    算术运算：
        1：允许类型：+ - * / // %
        2：不支持自增自减运算
        3：仅支持数字参与运算
        2：/和//的区别：
                / :除法运算，所得结果是浮点数，即便被整除，结果也是浮点数；
                //:除法运算，所得结果是整数，即便不能被整除，结果也是整数，小数部分无论大小均被舍去；
    布尔运算：
        1：允许的计算类型：and、or、not；
        2：python中的逻辑运算符是单词，不是&&、|、！这种符号；
        3：逻辑运算的结果仍然是布尔值；
    比较运算：
        1：允许的计算类型：== != > < >= <=
        2：运算结果：仍是布尔值；
        3：is 就是判断两个对象的id是否相同， 而 == 判断的则仅判断内容是否相同。
    赋值运算：
        1：允许的计算类型：=、+=、-=、*=、/=、//=、%=
    位运算：
        &：按位求与运算
        |：按位求或运算
        ^：按位异或运算
        ~：按位取反运算
        <<：左移运算；
        >>：右移运算；
    成员检测运算符：
        in 检测子串是否在指定的字符串序列中，如果在返回True，如果不在返回False；
        not in 检测子串是否不在指定的字符串序列中，如果不在返回True，如果在返回False；
    长度获取：
        len() 支持的数据类型包括：字符串，列表，元祖，字典，集合
    序列截取：
        ser[n],ser[n:],ser[n:m],ser[:m]
        支持的数据类型包括字符串，列表，元祖，字典；
流程控制：
    条件：
        if 表达式:
            code...
    ----------------------------

        if 表达式:
            code...
        esle:
            code...

    ----------------------------

        if 表达式:
            code...
        elif 表达式:
            code...
        else:
            code...
    ----------------------------
    循环：
        while循环：
            while 条件表达式:
                code...
    ----------------------------
        while+else:
            while 条件表达式:
                code...
            else:(else在不符合条件的时候会执行，但是仅执行一次)
                code...
    ---------------------------
        for...in...循环：
            for variable in sequence:
                code..
                (variable 代表存储集合遍历出来的值，sequence代表被遍历的集合)
        for...in...else：
            for varaile in sequence:
                code...
            else:
                code...
                (else在for循环正常终止的时候执行)
    --------------------------
        遍历数字：
            for i in range(m)   #m=5
                code...
        遍历数字...else：
            for i in range(m)
                code...
            else:
                code...
    --------------------------
        使用enumerate遍历器：
            for index,item in enumerate(sequence):
                code...
        使用enumerate遍历器...else：
            for index,item in enumerate(sequence):
                code...
            else:
                code...
        (index代表遍历出来的索引，item代表遍历出来的值)
    -------------------------
    对于pass：在代码或者函数中，暂时不处理或者无内容时需要使用pass;
        eg:if a>1 : pass
    -------------------------
    三目运算符：
    compare = a if a>b else b;
        
函数：
    函数声明方式：def 函数名 (参数列表) :
                    code...（函数体）
        备注： 
            1：函数以def关键字声明；
            2：函数名的命名要根据标识符来进行；
            3：函数体必须缩进，且同一个代码块缩进要统一；
            4：多个函数之间用空行隔开；
 
    函数调用：函数名(实参列表) 或者 return_value = 函数名(实参列表)
    函数形参： 
        1：必选参数：函数声明时明确了形参，但没有给出默认值，调用函数时必须按照形参顺序给出对应的实参值；
            1：形参声明：按需要声明形参，不设置默认值；
            2：实参传值：
                        1：按顺序一一传值；
                        2: 按照参数名传值 
                eg:
                    def a(q,w,e):
                        print(q,w,e)

                    a(1,2,3)
                    a(q=1,w=2,e=3) 

        --------------------------------------------------------------------------------------

        2：默认参数：允许为形参设置默认参数：
            1：形参声明：
                1：按需要声明形参，并可以为部分或者全部的形参设置默认值；
                2：设置了默认值的形参必须放在没有设置默认值的形参后面，且有默认值的形参后面不允许再有未设置默认值的形参；
            2：实参传值：
                1：可以按顺序赋值；
                2：也可以通过形参名为形参赋值；
                3：对于有默认值的形参，如果传入实参，形参值即为实参传入的值，如果未传入实参，形参值即为形参的默认值；对于没有默认值的形参，必须传入实参；
                eg:
                    def a(q,w=2,e=3):
                            print(q,w,e,r)
                    
                    a(1,12) => 1,12,3
                    a(w=12,q=1) => 1,12,3

        --------------------------------------------------------------------------------------
        
        3：可变参数：python中允许声明一个接收任意多个参数的形参变量:
            1：形参声明：
                1：可以声明一个 *var 格式的形参变量，这种类型的形参变量可以接收任意多个参数；
                2：该形参变量只能放在形参列表的最后一位；
                3：改形参变量接收到的参数将会存储在tuple中；
            2：实参传值：
                1：可以通过 , 分隔的方式传入多个参数，将一并被*var形参接收；
                2：可以通过*list或者*tuple的方式为该形参赋值；
                eg:
                    list_tmp = [1,2,3,4]
                    def tmp(*var):
                        print(var)
                        print(type(var))

                    tmp(1,2,3)  => (1,2,3)/tuple
                    tmp(*list_tmp) => (1,2,3,4)/tuple

        --------------------------------------------------------------------------------------

        4：关键字参数： python允许声明一种变量来接收dict字典；这种形参变量即为关键字参数；
            1：形参声明：
                1：允许声明 **var 类型的形参来接收dict的值；
                2：函数允许声明多个 **var 参数，也可以在任意位置声明;
                3：形参接收到的dict是实参的副本，因此在函数内部修改了形参dict的值，实参dict的值不会被修改掉；
            2：实参传值：
                1：实参需要通过**dict的方式传参；
                eg:
                    dict_tmp = {"name":"tom","age":23,"sex":"mail"}
                    def tmp(**t):
                        print(t)
                        print(type(t))

                    tmp(**dict_tmp)  => {"name":"tom","age":23,"sex":"mail"}/dict

            --------------------------------------------------------------------------------------

        限制关键字参数：
            e：限制性关键字参数前面需要使用*来分割
                如果限制性关键字参数前面使用了可变参数：则可以不使用*作为分隔符；
        参数组合：
            必选参数，默认参数，可变参数，关键字参数，限制关键字参数，
            1:尽量避免过多组合；
            2:尽量避免使用限制性关键字参数
            3：推荐直接使用(*var,**param)来接收任意类型，任意多个参数；

    函数返回值：使用return返回值；
        备注：
            1：如果return没有返回具体的值，则返回none;
            2：可以有多个return；但是只会执行一个return;
    
    变量作用域：
        变量作用域类型：
            全局作用域
            闭包函数外的函数中
            局部作用域；
        查找规则：
            局部作用域->闭包函数外的函数中->全局作用域;
        作用域围栏：
            python中只有类，函数，模块才会引入新的作用域，其他的代码块是不会产生作用域的；
        作用域访问规则：
            当前作用域声明的变量只能在当前作用域及以下作用域访问；不能向上突破；
        备注： 
            作用域在函数未执行前就已经形成了，作用域链也生成了，
            解释器在查找变量的时候按照上述规则查找；
    函数的名称：
        每个函数都有一个__name__属性，可以拿到函数的名称；

    高阶参数函数：
        1：以函数作为形参的函数称作高阶参数函数；
    高阶返回函数：
        1：以函数做为返回值的函数称为高阶返回函数，在高阶函数内部定义的函数被称为闭包函数；如：
                def account():
                    a = [0]
                    def addCount():
                        a[0]=a[0]+1
                        print(a[0])

                return addCount
        备注：
            1：account函数称为高阶返回函数，addCount称作闭包函数；
            2：调用高阶返回函数的时候会将闭包函数返回，但是并不会执行闭包函数，只有在调用返回的闭包函数时才会真正执行闭包函数；
            3：高阶返回函数的变量如果被闭包函数引用，该变量在高阶函数返回之后并不会立即销毁，而是依旧保存在内存中，因此通过闭包函数可以实现函数变量的保护以及函数内部变量的访问；
            4：闭包函数如果引用高阶返回函数内部的变量，在执行闭包函数时，该变量的值是高阶返回函数执行完毕前对该变量最后一次修改后的值；
            5：由于高阶函数会修改闭包函数所引用的外部变量，因此，闭包函数尽量避免引用高阶返回函数的可变对象；
        示例：
                def count():
                    fs = []
                    for i in range(1,4):
                        def f():
                            return i*i
                        fs.append(f)
                    return fs

                res = count()
                f1 = res[0]
                f2 = res[1]
                print(f1())9
                print(f2())9
            由于闭包函数所引用的变量值是高阶返回函数结束前最后一次对变量做的修改，因此多次调用闭包函数，其i值都是固定的3；
    装饰器：
        1：装饰器功能：在不改变函数本身代码的情况下，可以为函数添加功能，或者修改函数原先的执行动作；
        2：装饰器的要求：
            1：不改变函数原有的代码逻辑；
            2：只装饰函数，不执行被装饰之后的函数，具体何时执行，取决于调用；
        3：装饰器的实现：
            装饰器通过高阶返回函数实现；
            原因在于：高阶返回函数中可以定义闭包函数，可以在闭包函数中装饰指定函数，高阶返回函数执行之后将会返回被装饰之后的函数，因此可以起到装饰的作用，但不会立即执行被装饰的函数；如：
                #装饰函数
                    def writeLog(func):
                        def log():
                            #对目标函数的装饰要在闭包中进行，可以在调用目标函数之前与之后添加对应代码，实现不改变目标函数源代码的情况下为目标函数增加功能；并将函数的执行结果返回；
                            print("开始执行函数")
                            res = func()
                            print("函数已执行完)
                            return res
                        return log

                    #目标函数
                    def bar():
                        print("bar")
                        return "end"

                    #获取装饰后的函数
                    bar = writeLog(bar);

                    #执行装饰后的函数，本质上是执行装饰器中的log函数；
                    bar()
        4：装饰器的本质：
            装饰器本质上是在被装饰函数之前或者之后添加代码，组装成一个新的函数，通过执行这个心的函数实现对函数的装饰！
        5：python中为装饰器提供的语法糖：
            1：python中通过@符号来装饰指定函数；如：
                @writeLog
                def bar():
                    pass
            2：@符号本质上是代替调用高阶返回函数，返回被装饰之后的函数；
        6：常见的装饰器模式：
            1：简单装饰：
                #装饰器函数
                def decorate(funed):
                    def decorate_fun():
                        print("装饰指定函数")
                        funed()
                        print("装饰指定函数")
                    return decorate_fun
                #被装饰函数
                @decorate
                def bar():
                    pass
            2：带有参数的装饰器：
                 #装饰器函数
                 def decorateParam(param):
                    def decorate(funed):
                        def decorate_fun():
                            print("param")
                            print("装饰指定函数")
                            funed()
                            print("装饰指定函数")
                        return decorate_fun
                    return decorate
                #被装饰函数
                @decorateParam(value)
                def bar():
                    pass 
            3：带有参数的装饰器且被装饰函数带有参数
                 #装饰器函数
                 def decorateParam(param):
                    def decorate(funed):
                        def decorate_fun(param1,param2):
                            print("param")
                            print("装饰指定函数")
                            funed(param1,param2)
                            print("装饰指定函数")
                        return decorate_fun
                    return decorate
                #被装饰函数
                @decorateParam(value)
                def bar(param1,param2):
                    pass  
        7：同一个函数可以被多个函数装饰；



        
        
    