生成器：
    1：数据集合：数据集合有两种表示形式：穷举法表示和表达式表示；
        对于穷举法表示集合：
            一一列举集合中的每一个元素，
            特点在于：1：简单直观，但是有些数据集合无法进行穷举或者穷举困难；
                     2：集合中的数据提前已知，需要对整个集合中的数据进行保存，如果数据量大，保存集合本身比较耗费空间；
        对于表达式表示集合：
            集合中的数据可以由计算规则计算得出，每进行一次计算即可获取一个值；
            特点在于：
                1：需要时才生成数据，不占用过多的内存空间；
                2：集合不够直观，集合中有哪些元素，提前不可知；
    
    2：生成器：能够生成集合中数据的计算规则就称之为生成器；
        1：在程序中，有的情况下都只需要集合中前面一部分元素，如果集合中的所有元素都提前计算出并存储，则是对内存的浪费；在这种场景下，通过生成规则按需生成数据更符合要求；这种生成数据的规则封装成函数后就称该函数为生成器；

        2：生成器的要求：
            1：生成器每调用一次就需要创建一个值，并暂停执行，将值返回给调用者；如果程序无法暂停，那么一次调用将计算出集合中所有的值，这样与直接穷举数据集合无异，并没有起到节省空间，按需创建的需求；因此，满足生成器要求的最大特征在于程序能够暂停执行，并能够在暂停处激活继续向下执行；python中提供 yield 关键字来实现程序的暂停与激活；

            2：yield关键字：
                1：yield 关键字在函数中使用，能够暂停函数的执行，同时将一个值返回给函数的调用者；并能够在函数下一次被调用的时候激活函数，从暂停处继续向下执行，直至下一个yield处或者执行结束；

                2：和return相比有以下几个异同点：
                    1：相同之处在于yield和return都能够向函数外部返回值；
                    2：不同之处在于：
                        1：yield 返回值以后是暂停当前函数，而return 返回值以后是结束当前函数；
                        2：对于yield,函数再次被调用时将会从yield处继续向下执行直至结束或者下一个yield；对于return，函数再次被调用时将从函数开始处重新执行；
                        3：在python2.5以后，函数被激活时，暂停处还可以接收外部传入的参数：param = yield value;外部传入的参数会代替yield表达式(yield value整体)赋值给param;
                
        3：创建生成器：
            1：通过生成器表达式和生成器函数创建生成器：
                生成器表达式：类似于列表生成式：(x*x for x in range(n))；
                生成器函数：range()函数在python3中即是一个生成器函数,返回一个整数列表对象；使用方式有:
                            range(end)
                            range(start,end)
                            range(start,end,step)
                            但是在python2中，range()函数返回一个整数列表；返回值并非是生成器对象；

            2：通过yield关键字创建生成器：
                1：除过生成器表达式以外，对于一些逻辑复杂的生成规则，还可以利用yield关键字能够暂停和激活函数的特征来实现生成器；python中将使用yield关键字的函数称之为生成器；

                2：生成器函数的执行和普通函数不同：
                    1：普通函数使用时直接调用即可，调用之后立刻执行，直至结束或者发生错误、异常；
                    2：生成器函数直接调用之后会返回一个对象，称之为生成器对象；然后需要通过next(生成器对象)函数来执行生成器的逻辑；
                    3：每调用一次next()函数就会执行一次生成器的逻辑，并在yield处暂停，将yield的值返回；下次使用next()函数调用时将会从暂停处继续执行，如果生成器执行完毕将会报 StopIteration 异常；如：
                        def gen_func():
                            print("first")
                            yield 1
                            print("end")
                        
                        gen = gen_func()
                        next(gen)    #打印first
                        next(gen)    #打印end并报StopIteration异常

                    4：如果在激活生成器时需要从外部向生成器发送参数，可以通过send()函数发送值：gen.send(value);所发送的值将会替代yield表达式，赋值给接收参数的变量，并激活函数，从上一次的暂停处继续向下执行；如：
                        def gen_func():
                            print("start")
                            m = yield 34
                            print(m)
                            print("end")

                        gen = gen_func()
                        next(gen)       #打印start
                        gen.send(123)   #打印123，end并报StopIteration异常
                    
                    5：使用send()向生成器发送参数，并激活生成器时，务必使生成器除以预激状态(暂停状态)；因此避免出错，可以在创建生成器对象之后，使用next(gen)或者gen.send(None)来预激生成器；

                3：生成器的串联：yield from
                    在python3.3中提供了yield from 语法来解决生成器串联的问题；yield from语法有以下的特征：
                        1：yield from后跟一个生成器对象，用来将当前程序的执行权转交给后面所跟的生成器；实现生成器的串联；
                        2：使用yield from 语句的函数称为委托生成器，yield from后跟的生成器称之为子生成器，子生成器中也可以使用yield from 来串联另一个生成器；
                        3：在委托生成器中，函数执行至yield from处时，会将执行权交给yield from后的生成器，此时委托生成器类似于一个调用者和子生成器之间的管道；调用者通过send()函数可以将参数发送至子生成器，子生成器yield出的值也会直接返回给调用者；
                        4：子生成器中的return值将会作为StopIteration的第一个参数作为yield from 的返回值返回，其余异常将会一直向上冒泡；
                        
                        1：使用了yield from 的函数称之为生成器函数，



                    





                    



