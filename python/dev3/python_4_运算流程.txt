变量：
变量的命名规范：务必遵守python标识符命名规范；即：
    1：以数字、字母、下划线组成；
    2：不能以数字作为开头；
    3：严格区分大小写；
    4：不能使用系统关键字作为变量名；
    5：要具备可读性，除过迭代器和计数器以外，避免使用单字符作为变量名；
    6：避免使用以"__"作为前缀且以"__"作为后缀的变量名；

变量的权限：
    1：在python中以 '_' 作为变量的前缀，表示当前变量是属于当前模块的，不能被外部模块直接导入，即:无法通过 from module import * 直接导入使用；

变量的数据类型：
    1：python是动态类型编程语言，具有松散的数据类型，即变量的数据类型在编码阶段无法确定，只有在程序运行时，解释器才会根据变量所引用的数据的数据类型来确定变量的数据类型，因此python中变量的类型取决于变量所引用的数据的数据类型；
    2：python中的变量在程序运行过程中可以引用不同数据类型的数据；
    3：python中变量在使用之前必须先声明，后使用；如：
        vara += 1:将会报NameError异常，变量vara未定义；需要先通过vara = 0 vara += 1

变量的作用域：
    在python中，只有模块、类、函数(方法)才会产生作用域，其余语句块均不会产生作用域；
    根据变量定义时所处位置的不同，变量的作用域分为以下几种：
        局部作用域、嵌套(闭包)作用域、全局作用域、内置(built-in)作用域
    局部作用域：
        如果变量在函数(方法)中定义，那么变量所处的作用域称之为局部作用域，所定义的变量仅能够在函数(方法)中使用，在函数外部，无法访问到函数(方法)内部所定义的变量；
    嵌套(闭包)作用域：
        如果函数(方法)中有被嵌套函数，并且变量定义在被嵌套函数外部，外层函数的内部，那么变量所处的作用域称之为嵌套作用域；所定义的变量仅能在外层函数内部和被嵌套函数内部访问到，外层函数外部则无法访问到该作用域的变量；
    全局作用域：
        如果变量在顶层定义，即在模块层次中定义，那么该变量称之为全局作用域，此时当前模块内的类中，函数中均可直接访问；模块以外访问需要先导入，如果变量名以'_'开始，那么需要显式的导入该变量，而不能直接使用from module import *来导入；
    内置作用域：
        如果变量定义在python的built-in模块中，那么该作用域称之为内置作用域；无需导入，可以在任意模块中直接使用；

变量在python中的存放方式：
    1：变量在python中是以dict的形式存放，可以通过globals()函数和locals()函数获取存放变量的dict；
    2：其中globals()函数获取的是存放全局变量的dict,locals()函数获取的是存放局部变量的dict;在全局状态下，locals()函数和globals()函数相同，获取的都是存放全局变量的dict；
    3：globals()函数得到存放全局变量的dict，并且可以通过该dict直接修改全局变量的内容,如：globals()[var_name]=value；
       locals()函数得到存放局部变量的dict，但是不能通过该dict直接修改局部变量的值，仅仅可读,如：locals()[var_name]=value无法修改具体变量的值；
    
动态创建变量：
    1：动态创建变量的原理：
        python中的变量是在dict中存储的，因此动态创建变量的本质就是向存储变量的字典中添加一个键值对即可，键名即为变量名，键值即为变量值；通过该方式动态创建变量需要先使用globals()或者locals()获取到存储变量的字典；
    2：动态创建变量：globals()['var_name'] = value  或者  locals()['var_names'] = value

    3：除过上述方式以外，还可以利用exec()函数动态创建变量：exec()函数用来执行存储在字符串或者文件中的代码段，因此可以通过组装字符串的方式来动态创建字符串：
        exec("a = []")  # print(type(a)) : <class 'list'>

变量赋值时的注意事项：
    python中为变量赋值时，如果值后带有 ',' 那么解释器将会把值解释为一个tuple赋值给变量；如：
        a = 1,    #a的值为(1,)

可变对象和不可变对象：
    可变对象和不可变对象：
        python中一切皆对象：
            如果修改一个对象时，是对对象本身的修改，则称该对象为可变对象；
            如果修改一个对象时，是对创建一个新的对象，然后将新的内容赋值给新创建的对象，则称该对象为不可变对象；
            python中的不可变对象:str、int、float、None、tuple；可变对象：list、set、dict
        
    可变对象/不可变对象的赋值：
        对于可变对象：由于可变对象在修改时，是对对象本身的修改；因此重新为可变对象赋值时，实际上是修改可变对象本身的值；
        对于不可变对象：由于不可变对象在修改时，系统会创建一个新的对象来存放新的内容；因此为不可变对象赋值时，实际上是创建了一个新的对象；   
    
    可变对象/不可变对象的复制：
        可变对象的复制：
            1：将一个指向可变对象的变量a复制给另一个变量b，系统并不会为变量b分配内存块来存储被复制的内容；而是将被复制的变量b一并指向该可变对象；
            2：如果通过任意一个指向该可变对象的变量修改了该可变对象的内容，其余指向该可变对象的变量的值都将发生改变；如：
            a = ['list1']
            b = a
            a[0] = 'list2'
            print(b)   #打印内容：['list2'],而不再是['list1']
        
        不可变对象的复制：
            1：将一个指向不可变对象的变量a复制给另一个变量b，系统同样不会为变量b分配内存块来存储被复制的内容，而是将变量b指向该可变对象；
            2：修改任意一个指向不可变对象的变量，都会为该变量重新分配内存，并存储新的内容；其他指向该不可变对象的变量不会受任何影响；

运算：
    算术运算：
        运算类型：+(加法) -(减法) *(乘法) /(除法) //(整除) %(求余)
        备注：
            1：python语言本身仅支持上述算术运算；
            2：python中不支持自增自减运算；
            3：对于 '/' 和 '//' 的区别在于：
                '/' 得到的一定是浮点数，无论是否能够整除，无论除数与被除数是否是浮点数，结果都会得到浮点数；
                '//'得到的一定是整数，无论是否能够整除，余数无论大小都将被舍去，结果得到的一定是整数；但是如果除数或者被除数之一是浮点数，那么运算结果一定是浮点数；
        对算数运算的扩展：math模块、random模块、decimal模块以及round()函数：
            math模块：
                math模块支持了更多的科学运算,使用之前需要先导入math模块：import math
                math中的两个常量：
                    math.pi：表示圆周率
                    math.e：表示自然数
                math中的方法(常用)：
                    math.ceil(x)：对x向上取整
                    math.floor(x)：对x向下取整
                    math.fabs(x)：获取x的绝对值(浮点数)
                    math.abs(x)：获取x的绝对值(整数)
                    math.fsum([])：对迭代器中的每一个元素求和

                    sin(x)：求x的正弦
                    cos(x)：求x的余弦
                    tan(x)：求x的正切
                    asin(x)：求x的反正弦
                    acos(x)：求x的反余弦
                    atan(x)：求x的反正切

                    exp(x)：求e的x次幂
                    pow(x,y)：求x的y次幂
                    log10(x)：求x的以10位底的对数
                    sqrt(x)：求x的平方根
            random模块：
                random模块可以创建随机数，使用之前需要先导入：import random
                #获取一个大于0小于1的随机小数
                random.random()

                #获取一个指定区间的随机小数
                random.uniform(0,9)   

                #获取一个指定区间的随机整数
                random.randint(0,9)  

                #从list中随机获取一项
                random.choice([1,2,3,4])

                #随机打乱list
                random.shuffle([1,2,3,4])

                #从序列中随机截取指定长度的片段，原序列不做修改
                random.sample([1,2,3,4],2)
            decimal模块：
                decimal模块的存在主要为了python中的浮点数运算；decimal模块在使用时需要先导入:from decimal import Decimal

                #使用decimal进行算术运算(使用decimal进行算术运算时，只能传入整数或者浮点数字符串)：
                decimal.Decimal(1)+decimal.Decimal("1.7") = "2.7"

                #使用decimal进行算术运算可以指定运算结果中的有效位数(如果结果是浮点数时)：
                getcontext().prec = 3
                Decimal(1)/Decimal(7)
                结果是0.143,相比float(1)/float(7)，得到的结果有效位数可以控制；

                #四舍五入，保留指定位数：
                Decimal('1.2363').quantize(Decimal('0.00'))
                结果是：'1.24'
            
            round()函数：可以指定浮点数的有效位数对浮点数进行四舍五入运算；如：
                round(1.234,1)  :1.2
                round(1.227,2)  :1.23

    比较运算：
       运算类型： == != > < >= <= is
       备注：
            1：is和==有本质的不同，==仅仅判断两个变量的值是否相同，is则判断两个变量是否指向同一个对象，即变量的值以及值所在的内存地址都必须完全一样才会返回True；
            2：条件运算的结果是个布尔值，即True或者False
    
    布尔运算：
        1：允许的运算类型：and、or、not；
        2：python中的逻辑运算符是单词，不是&&、|、！这种运算符号；

    赋值运算：
        1：允许的计算类型：=、+=、-=、*=、/=、//=、%=
    
    位运算：
        &：按位求与运算
        |：按位求或运算
        ^：按位异或运算
        ~：按位取反运算
        <<：左移运算；
        >>：右移运算；
    
    序列类型的相关运算：
        1：检测子元素是否存在：
            in 检测子元素是否在指定的父级序列中，如果在返回True，如果不在返回False；
            not in 检测子元素是否不在指定的父级序列中，如果不在返回True，如果在返回False；
        
        2：序列的长度获取：
            len() :支持的数据类型包括：字符串，列表，元祖，字典，集合以及其他实现了__len__()魔术函数的对象
        
        3：序列截取：
            ser[n],ser[n:],ser[n:m],ser[:m],ser[n:m:i]
            支持的数据类型包括字符串，列表，元祖，字典以及其他序列类型；

流程控制：
    条件控制：
        条件控制-1：if
            if 表达式:
                code...
        
        条件控制-2：if-else
            if 表达式:
                code...
            else:
                code...
        
        条件控制-3：if-elif-else
            if 表达式:
                code...
            elif 表达式:
                code...
            else:
                code...
        
        条件控制-4：三目运算符
            x if True else y
            如：
                y=1
                x = 2 if y>3 else 1
                结果:x=1

    循环控制：
        循环控制-1：while
            while 条件表达式:
                code...

        循环控制-2：while-else
            while 条件表达式:
                code...
            else:
                #在不符合while循环条件是进入else执行，仅执行一次；
                code...
        
        循环控制-3：for-in
            for item in sequence:
                code...

        循环控制-4：for-in-else
            for item in sequence:
                code...
            else:
                code...
        循环控制-5：for-in-数字
            for i in range(5):
                code...

        循环控制-6：for-in-数字-else
            for i in range(5):
                code...
            else:
                code...
        
        循环控制-7：for-in-enumerate
            for (index,item) in enumerate(sequence):
                code...

        循环控制-8：for-in-enumerate-else
            for (index.item) in enumerate(sequence):
                code...
            else:
                code...
        循环控制：
            break：结束并跳出当前循环，执行循环之后的逻辑
            continue：结束本次循环，并进行新的循环

无处理逻辑的代码块：
    对于无任何处理逻辑的代码块中需要使用 pass 来标识