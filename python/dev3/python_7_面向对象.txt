python面向对象基本语法：
    1：类的定义：
        1：定义语法：class ClassName(inheritedClass):
                        class_attr = value    #定义类属性

                        def __init__(self):
                            #定义构造方法
                            self.obj_attr = value    #定义一个实例属性
                        
                        def func(self):
                            #定义实例方法
                        
                        @staticmethod
                        def func():
                            #定义一个静态方法
                        
                        @classmethod
                        def func(cls):
                            #定义一个类方法
        
        2：类定义说明：
            1：python中使用class关键字定义一个类；
            2：类名推荐使用首字母大写的命名方式；并且要符合python中标识符命名规范；
            3：在类后使用()来表示当前类需要继承的父类，python中支持多继承，因此继承多个父类时使用','分隔开多个父类；
            4：类中成员包括：类属性，实例属性，类方法，静态方法，实例方法，构造方法以及魔术方法；类成员无需{}包裹，但是需要保持相同的缩进；

    2：对象的创建：
        1：对于对象和类的关系：
            类是用来创建对象的模板，对象则是类具体化的实例；

        2：对象的实例化：
            obj = ClassName()           #构造方法无明确需要传入的形参
            obj = ClassName(arg1,arg2)  #构造方法有明确需要传入的形参
        
        3：几个操作对象的常用函数：
            dir(obj)   #获取对象的所有属性以及方法
            isinstance(obj,ClassName)    #检测对象是否是指定类的实例
            hasattr(obj,'x')    #检测对象是否有指定属性

    3：类成员-属性：
        1：属性有两种：类属性和实例属性；
        2：类属性：该属性属于类，不属于实例对象；对象的创建并不会影响类属性的值，在对象创建之后，所有对象中的类属性都是完全相同的；
            1：类属性的特征：
                1：在类初始化的时候即初始化类属性，类被销毁时即被销毁，类属性的生命周期和类相同；
                2：类属性只能在类内部定义；不能在类中其他方法中定义，否则将成为方法中的局部变量；如：
                    class ClassName():
                        class_attr = 1      #class_attr是在类内部定义类属性

                        def func(self):
                            var_name = 1    #var_name属于实例方法func的局部变量
                3：类属性只能通过类名访问：无论是在类内部的方法中还是类外部访问，类属性都必须使用类名来访问；如：
                    class ClassName():
                        class_attr = 1    #类属性

                        def func(self):
                            print(ClassName.class_attr)         #在类内部方法中访问类属性
                        

                    ClassName.class_attr    #在类外部方法中访问类属性
                
        3：实例属性：该属性属于对象本身；并且不同对象中的实例属性属于各自对象；
            1：实例属性特征：
                1：实例属性属于对象，每创建一个对象，这些实例属性就会被创建一次；每一个对象中都有各自的实例属性，不同对象的实例属性互相独立；
                2：实例属性在创建对象时定义并初始化，对象被销毁时也将被销毁，其生命周期和对象本身相同；
                3：实例属性定义：
                    1：可以在构造方法、实例方法中通过 self.实例属性名 来定义；构造方法中和实例方法中定义的实例属性，每一个对象中都会存在一份；
                    2：可以通过实例对象定义，obj.实例属性名；通过实例对象定义的属性只有当前实例对象有；
                    3：不允许再静态方法、类方法中定义或者调用实例属性
                    示例：
                        1：在类构造方法中和实例方法中定义：
                        class ClassName():
                            def __init__(self):
                                self.obj_attr = 1    #在构造方法定义实例属性
                            
                            def func(self):
                                self.obj_attr = 1    #在实例方法中定义实例属性
                        
                        2：通过实例对象定义：
                            obj = ClassName()
                            obj.obj_attr = 1    #通过实例对象定义实例属性

                4：实例属性的访问：
                    1：在类内部需要使用self关键字来访问：self.obj_attr；
                    2：在类外部需要通过实例对象来访问：obj.obj_attr；
                    3：通过实例对象访问实例属性时，如果实例属性不存在，那么会查找同名类属性；并返回该属性的值；
                
    4：类成员-方法：
        1：构造方法：
            1：构造方法的定义：
                def __init__(self):
                    #构造方法体
            
            2：关于构造方法的说明：
                1：构造方法用来初始化对象，比如初始化实例属性等；而非创建对象；
                2：构造方法的名称必须是__init__，不能是其他名称；
                3：构造方法的第一个参数是self,代表实例对象本身；向构造方法中传入参数时从第二个参数开始；
        
        2：实例方法：
            1：实例方法的定义：
                def func_name(self):
                    #实例方法体
            
            2：关于实例方法的说明：
                1：实例方法属于对象，每一个对象中都有一份实例方法;
                2：实例方法第一个参数为self,代表实例对象本身，传入实例方法的参数从第二个参数开始；
                3：实例方法在类内调用时，使用 self.func_name() 的方式调用，在类外使用 obj.func_name() 调用；
            
        
        3：类方法：
            1：类方法的定义：
                @classmethod
                def func_name(cls):
                    #类方法体
            
            2：关于类方法的说明：
                1：类方法属于类，和对象的创建无关；类方法的定义必须使用 classmethod 装饰器装饰；
                2：类方法的第一个参数为cls(或者其他名字),代表当前类本身；
                3：类方法无论是在类的外部还是类的内部，都是通过：ClassName.func_name()来调用；
                4：类方法中不能直接通过 self 关键字访问实例属性和实例方法；
        
        4：静态方法：
            1：静态方法的定义：
                @staticmethod
                def func_name():
                    #静态方法体
            
            2：关于静态方法的说明：
                1：静态方法同样属于类，和实例对象的创建无关；静态方法的调用必须使用 staticmethod 装饰器装饰；
                2：静态方法中无需代表类本身的参数，传入方法的参数从第一个开始；
                3：静态方法无论是在类的内部还是类的外部，都可以通过ClassName.func_name()或者obj.func_name()来调用；
                4：静态方法中不能直接通过 self 关键字访问实例属性和实例方法；
                5：静态方法和类方法都是用来表示和实例对象无关的逻辑；不同点在于，类方法中使用类本身时可以使用表示类本身的参数cls，无需将类名硬编码至代码中；
        
面向对象的三个特性：
    封装：面向对象中，一个类只需向外暴露合适的接口，以保证类内部逻辑的安全，因此需要给类成员添加不同的访问权限，称之为封装；
        1：python中不使用public、protected、private等关键字来表示类成员的权限，而是通过给类成员名称前加 __ 来实现成员的私有性；

        2：python中为类成员添加 __ 作为名称前缀，来实现成员私有性的本质并非是直接让外部不可访问，而是在python解释器中重新设置私有成员的名称：一般情况下，__name 会被转换为 _ClassName__name;

        3：在类的内部，可直接使用self.__name来访问实例属性/方法，或者通过ClassName.__name来访问类属性和类方法；但是在类的外部，不推荐直接使用_ClassName__name的方式访问私有成员(不同的python解释器会重置成不同的名称，因此并不推荐在类外部访问私有属性)；

        4：可以通过提供set/get方法，保证能够在外部访问私有属性；

        5：在python面向对象中，__name__和__name不同；__name__表示系统成员，在类的外部和内部均可直接通过__name__来访问，但是__name表示私有成员；
    
    继承：
        1：python中继承一个类，需要将被继承的类写在类的()中，并且python支持多继承，多个被继承的类需要使用 , 隔开；如类A继承类B和类C： class A(B,C);

        2：继承的结果：一个类继承了另一个类之后，将具有被继承类的所有非私有权限的方法和属性；

        3：子类访问父类的属性和方法：
            在子类内部访问：
                1：类属性
                    ParentClassName.attr_name     #使用父类类名访问父类的类属性
                
                2：类方法：
                    ParentClassName.func_name()     #使用父类类名访问父类的类方法
                
                3：静态方法：
                    ParentClassName.func_name()     #使用父类类名访问静态方法
                
                4：实例方法：
                    ParentClassName.func_name(self)    #使用父类类名访问父类的实例方法
                
                5：构造方法：
                    ParentClassName.__init__(self)    #使用父类类名访问父类的构造方法

            在子类外部：
                1：子类外部可以通过子类实例对象访问父类的实例属性和实例方法，
                    因此python中的实例对象查找实例属性时；会按照以下顺序查找(父类再无父类)：
                        1：先查看当前类中是否有实例属性；
                        2：依次查看父类中是否有同名实例属性；
                        3：查看当前类中是否有同名类属性；
                        4：依次查看父类中是否有同名类属性；
                    实例对象查找方法时，则是按照以下顺序查找(父类再无父类)：
                        1：查看当前类中是否有实例方法；
                        2：查看当前类是否有同名静态方法；
                        3：依次查看父类中是否有同名实例方法和同名静态方法；(在父类中同样按照1,2的顺序查找，如未找到，则进入第二个父类查找，以此类推)
                    
                2：子类外部也可以通过子类类名访问父类类属性和类方法：
                    python中子类外部使用子类类名访问类属性的顺序(父类再无父类)：
                        1：先查找当前类是否有类属性；
                        2：再依次查找父类中是否有类属性；

                    python中子类外部使用子类类名访问类方法的顺序(父类再无父类)：
                        1：先查找当前类是否有类方法
                        2：查看当前类是否有同名静态方法；
                        3：依次查看父类是否有同名类方法和同名静态方法；(在父类中同样按照1,2的顺序查找，如未找到，则进入第二个父类查找，依次类推)
                
                3：关于继承时的构造方法调用顺序(父类再无父类)：
                    1：如果当前类中有构造方法，则执行当前类的构造方法；如无：
                    2：检查第一个父类是否有构造方法，如果有则执行当前类的构造方法；如无：
                    3：依次按顺序检查其他父类的构造方法，如果有则执行某个父类的构造方法，如无：报错
                
                4：在父类还有其他父类的情况：根据父类的继承情况不同，可以分为：菱形继承和U型继承；
                    1：如果是菱形继承，那么类方法，类属性，实例方法，实例属性的查找顺序则是先本类，后所有直接父类，再是父类的父类；
                    2：如果是U型继承，那么类方法，类属性，实例方法，实例属性的查找顺序则是先本类，再是父类，后父类的父类，直至当前父类的继承链查找完毕再从下一个父类按照上述顺序查找；

    多态：
        多态的特征：
            1：由于继承特征的存在，一个类可以有多个子类，这些子类即为该类的不同形态，并且支持把子类当做父类使用，即：如果一个函数/方法的参数要求父类类型，那么该父类的所有子类同样也被允许；这种特征称之为多态；
        多态的意义：
            1：从父类角度来看：由于多态的特征，一种类型将具备不同类型的能力：
                1：一种类型可以衍生出多个子类，不同的子类对于同样一个行为可以有不同的表现，又由于多态在允许父类类型时也同样允许子类类型，如果不同的子类对于同一个行为由不同的表现，那么类似于间接的实现了父类的多态性，因此父类将具备不同类型的能力；
            2：从子类角度来看：因为多态的支持，程序可以实现允许不同的对象对同一行为作出不同的表现；
                1：如果函数/方法支持父类类型，那么也将支持子类类型，如果不同的子类对于同一个方法有着不同的实现，那么传入不同的子类对象，调用同样的方法将会执行不同的逻辑；因此实现支持不同的对象支持对同一个方法作出不同的响应；
        多态的实现：
            1：对于静态语言，多态必须借助继承才能够实现多态的特征；
            2：对于动态语言，如python、php等，由于数据类型较为松散，没有具体的数据类型要求，因此天然支持多态；无需借助继承实现多态特征；

