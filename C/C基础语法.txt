一：C语言基本特征：
    1：高级编程语言之一；
    2：C语言切近硬件，能够直接操作位，字节，地址；并且C程序文件会被编译成机器码来执行，因此执行效率整体很高；
    3：C语言是编译执行的编程语言：需要由编译器先编译链接成二进制可执行文件，再由操作系统执行；
    4：C语言仅仅支持面向过程编程，不支持面向对象编程！

二：C语言标准：
    1：C89和C90标准：
        C89来源：ANSI在1989年批准通过了C语言以及C语言标准库，因此称之为C89标准；
        C90来源：ISO在1990年采用ANSI批准通过的C语言及C标准库，因此称之为C90标准；
        C89标准和C90标准指的是同一个标准；
    2：C99标准：
        ANSI和ISO联合委员会在1994年开始制定新的C语言标准，并称之为C99标准，主要集中在国际化，弥补缺陷，提高计算实用性方面；但是编译器的支撑程度并不是很高；
    3：C11标准：
        2011年发布了新的C语言标准，称之为C11标准；


三：C语言执行流程：
    概述：语言执行方式：
        1：对于解释执行的编程语言：在执行时需要使用解释器逐行读取源代码文件，并执行得到结果；
        2：对于编译执行的编程语言：在执行时需要先使用编译器编译链接成可执行文件，然后由操作系统来执行；
        3：由于C语言是编译执行的编程语言，因此在执行之前需要先由编译器编译链接成为二进制可执行文件，才能够由操作系统执行；
    流程：
    C语言由源代码文件得到二进制可执行文件需要经过5个过程：1：编写C源代码文件；2：预处理得到预处理文件；3：编译得到汇编文件；4：汇编得到目标文件；5：链接得到可执行文件

    1：编写源代码文件：
        C源代码即由C语言编写的C源程序，一个C源程序可以有一个或者多个C源文件组成，每一个C源文件都以.c作为后缀；

    2：进行预处理，得到预处理文件：
        1：C源程序中会有#include包含头文件的代码以及宏的使用，预处理即为将#include包含头文件的代码替换成头文件的真正内容，以及将代码中的宏替换为宏的真正值；
        2：预处理命令：gcc -E ./test.c -o test.i
        3：预处理完成后得到预处理文件，预处理文件以.i作为后缀，仍然是一个文本文件，可以通过文本编辑器打开；预处理文件的大小会大于C源程序，原因在于#include代码全部被替换为头文件真正的内容；

    3：进行编译，得到汇编文件：
        1：此处的编译并非指将C预处理文件直接编译为二进制的目标文件，而是指将预处理文件转换为特定的汇编代码文件；
        2：编译命令：gcc -S ./test.c -o ./test.s
        3：编译完成之后得到汇编文件，汇编文件以.s作为后缀，仍然是一个文本文件，可以通过文本编辑器打开，内容为汇编代码；

    4：进行汇编，得到C源程序文件的二进制目标文件：
        1：汇编的过程是将编译完成后的汇编文件转换成二进制的目标文件的过程；
        2：汇编命令：gcc -c ./test.s -o ./test.o
        3：汇编完成之后得到汇编文件，以.o作为后缀，是一个二进制的目标文件；

    5：进行链接，得到最终的二进制可执行文件：
        1：一个可执行文件包括：启动代码，引用到的库函数代码，C源文件汇编得到的目标文件，C源程序中引用的其他C源文件汇编得到的目标文件，上一步汇编完成之后只是得到了一个C当前源文件的目标文件，还缺少启动代码、引用到的库函数代码、C源程序中引用的其他C源文件的目标文件，因此还不能作为可执行文件运行起来；
        2：链接的过程即为将当前C源文件汇编得到的目标文件，启动代码，库函数代码，其他C源文件的目标文件合并成为一个完整的可执行文件的过程；
        3：链接命令：gcc -o ./test.out ./test.o ./a.o ./b.o
        4：链接完成之后即可得到最终的可执行文件，在linux平台上以.out作为后缀，在windows平台上，以.exe作为后缀！
        5：特别注意：
            1：链接过程中导入库函数代码时，仅仅只会导入C源程序使用到的库函数代码，并不会将整个库的所有代码导入；
            2：如果一个C源程序是由多个C源文件组成的，在链接时需要将多个C源文件链接起来；

四：编译器：
    Linux上的常用的编译器为：gcc（最终可执行文件的后缀名为.out）
    windows上常用的编译器为：Cygwin（最终可执行文件的后缀名为.exe）

五：C语言基本语法规范：
    1：C源程序组成：
        1：一个C源程序可以由一个或者多个C源文件组成；
        2：一个C源程序的每一个C源文件都以.c作为后缀；
        3：一个C源程序必须要有并且只能有一个主函数；
        4：C程序执行时，从主函数开始，并从主函数结尾；
    2：C语言基本语法：
        1：以;作为语句结束符；
        2：以{}作为代码块确认符；
        3：以/* ... */作为多行注释，以//作为单行注释；
        4：标识符命名规范：
            1：以数字，字母，下划线组成；
            2：不能以数字开头；
            3：不能和关键字冲突；
            4：大小写敏感；
            5：避免使用_或者__开头；
            6：禁止使用拼音和英语混合式命名！
        5：一个C源文件结构上由两部分组成：1：函数、2：函数外部的代码
        6：表达式只能在函数中出现，函数外部只能出现语句，不能出现表达式；

六：主函数：
    1：一个C源程序必须要有，并且只能有一个主函数；
    2：C程序执行时，从主函数开始执行，并从主函数结尾处结束执行；
    3：主函数的名称只能是main，不能自定义为其他名称；
    4：主函数的定义方式：
        标准定义方式：
            1：int mian(void){/* ... */}
            2：int main(int argc,char *argv[]){/* ... */}
        非标准定义方式：
            3：int main(int argc,char *argv,char *envp){/* ... */}
    5：主函数的形参说明：
        1：形参可以直接声明为void，也可以按照标准定义方式携带参数，并且可以根据需要命名为其他名称，形参指的是使用命令行执行该程序时传入的参数！
        2：int argc(argument count:参数个数)：为0或者命令行执行该程序时传入的字符串个数，并且可执行文件本身的名称也算作一个参数，也需要计算进去！
        3：char *argv(argument vector)：是一个char指针数组，每一项都指向使用命令行执行该程序时传入的字符串参数，argv[0]指的是可执行文件的名称；传入的字符串参数可以通过argv[1]~argv[argc-1]获得！
        4：char *envp(environment pointer)：时指该C源程序的执行环境信息，每一项都指向一个字符串，字符串通常由"名称=值得方式组成"；也可以在程序中通过getenv()标准函数获取得到执行环境信息；
    6：主函数的执行结果：
        C源程序从主函数开始执行，也从主函数结尾处结束执行；在主函数执行结束后，会将执行状态以整数的形式传递给操作系统；
        1：返回值是0或者EXIT_SUCCESS，表示程序执行过程一切顺利；成功的执行完成！
        2：返回值是任何其他非0值，尤其是EXIT_FAILURE，则表示程序执行时出现问题；并未成功完整执行；
        3：mian函数并非必须调用return返回一个整数值，如果程序运行到main()的右' } '处，将会自动向执行环境返回状态值0；
        4：main()函数的结束等效于调用标准库函数exit(),main()的返回值作为exit()的参数；

七：C语言常用的输出方式：
    1：输出单个字符:
        putchar()       //putchar('c')
    2：输出字符串：
        puts()          //puts("string")
    3：格式化输出任意数据：
        printf()        
        1：基本使用方式：printf("格式化字符串",var1,var2,var3)
        2：格式化字符串组成：自定义字符、格式化字符；自定义字符将会原样输出，格式化字符将会按照顺序格式化待输出变量的值，并替换格式化字符；
        3：格式化字符组成：%[flag][width][.precision][type]
        4：flag：
            -：默认输出是右对齐，带上-之后则为左对齐；
            +：正数带上+号，负数带上-号；
            #：对于小数，强制输出小数点，对于八进制，十六进制，二进制，带上前缀；
            空格：用于数字：正数加空格，负数加负号；
        5：width：最小宽度限制，如果不足将会使用空格补齐，如果超出之后将会自动失效；
        6：.precision：
            对于 int，.precision 表示最小输出宽度
            对于 float，.precision 表示输出精度。
            对于 str，.precision 表示最大输出宽度。
        7：type:指定需要将变量格式化成指定的数据类型：
            字符/字符串：
                        %c          //格式化成字符类型
                        %s          //格式化成字符串类型
            浮点数：
                        %f          //格式化成单精度(float)类型的小数形式
                        %lf         //格式化成双精度(double)类型的小数形式
                        %e          //格式化成单精度(float)类型的指数形式
                        %le         //格式化成双精度(double)类型的指数形式
                        %E          //格式化成单精度(float)类型的指数形式(以大E表示)
                        %lE         //格式化成双精度(double)类型的指数形式(以小e表示)
            十进制整数：
                        %d          //格式化成十进制、有符号、int类型整数
                        %hd         //格式化成十进制、有符号、short类型整数 
                        %ld         //格式化成十进制、有符号、long类型整数
                        %u          //格式化成十进制、无符号、int类型整数
                        %hu         //格式化成十进制、无符号、short类型整数 
                        %lu         //格式化成十进制、无符号、long类型整数
            八进制整数：
                        %o          //格式化成八进制、无符号、int类型整数
                        %lo         //格式化成八进制、无符号、long类型整数
                        %ho         //格式化成八进制、无符号、short类型整数
            十六进制整数：
                        %x          //格式化成十六进制、无符号、int类型整数
                        %lx         //格式化成十六进制、无符号、long类型整数
                        %hx         //格式化成十六进制、无符号、short类型整数

八：C语言变量声明：
    C语言中变量使用基本规范：
        1：C语言中变量使用之前必须先声明，后使用；
        2：声明变量时，必须指明变量的数据类型，变量名称，如有必要可以赋上初值；
        3：变量声明时，即确定该变量的数据类型；
        4：在程序运行过程中，变量只能引用和其数据类型相同的数据，不能引用其他数据类型的数据；

    C语言中变量命名规范：
        1：C语言变量名必须遵守C语言标识符命名规范；
        2：C语言变量推荐采用小写+_分割式命名；如：var_name

    C语言中的全局变量和局部变量：
        全局变量：
            在函数外部声明的变量称之为全局变量；
            全局变量初始值：
                如果全局变量在声明的同时赋予初值则全局变量的初值即为所赋的值；
                如果全局变量在声明的同时并未赋值，则初值为0；
                全局变量只能在函数外部声明以及初始化，在函数外部不能参与任何赋值和运算表达式；
            全局变量分为普通全局变量和静态全局变量：
                普通全局变量：
                    即不含任何特殊含义的全局变量；
                声明方式如：  
                    int a=1;
                普通全局变量的生命周期：
                    普通全局变量的生命周期和当前程序的生命周期一致，程序运行完毕，其所占内存才能够释放；
                普通全局变量的作用域：
                    普通全局变量的作用域是组成c源程序的所有源文件；即多个c源文件中出现同名普通全局变量会冲突
                    普通全局变量可以在别的文件中通过extern引用;引用方式：extern date_type var_name

            静态全局变量：即作用域只在当前文件的全局变量：
                声明方式：
                    static int a=1;
                静态全局变量的生命周期：
                    静态全局变量的生命周期和当前程序的生命周期一致，程序运行完毕，其所占内存才能够释放；
                静态全局变量的作用域：
                    静态全局变量的作用域只在当前文件内部；不会和其他c源文件中的同名全局变量冲突！
                    静态全局变量 不 可以在别的文件中通过extern引用
        
        局部变量：
            在函数内部声明的变量称之为局部变量；
            局部变量的声明位置：
                    对于c89/c90规定，在任何执行语句之前，在块的开头声明所有局部变量；
                    对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置； 
            局部变量初始值：
                如果声明之后未赋值，只会为其分配指定大小的内存空间，值是未知的；
            局部变量作用域：
                只能为变量声明之后的代码块之内的代码中使用；
            局部变量分为自动局部变量和静态局部变量：
                自动局部变量 auto
                    1：声明方式如：int b=3; 等同于auto int b=3;
                    2：该变量只能在所声明的函数中使用；其他函数不能调用；
                    3：其生命周期和函数保持一致，函数执行完毕，变量所占用的内存即被释放；
                    4：自动局部变量如果不赋初值，其值是不确定的；
                静态局部变量 static
                    1：该变量只能在所声明的函数中使用；其他函数不能调用；
                    2：其生命周期和程序运行的生命周期一致，
                        1：在调用声明该静态变量的函数时，系统为该静态变量创建内存空间，但是只有程序运行完毕，该静态变量的内存空间才会释放！
                        即：静态局部变量的值在函数调用结束后不消失，而是保留原值，其所占用的内存空间也不释放！下次再调用该函数时，该变量已经有值，将不会再从新声明该变量！值就是上一次调用函数结束时为其赋的值；只有程序运行结束，该静态局部变量所占内存空间才会释放；
                    3：如果静态局部变量不赋初值，其值不确定；
                    4：声明方式：static int a=12;
                在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是通常认为的“零”值。
九：运算规则：
    1：运算级别：
        赋值运算= < &&和|| < 关系运算 < 算术运算 < ! < ()
    
    2: ()运算符：
        优先级最高，表示优先计算()里面的运算表达式；
    
    3: 算术运算：
        运算符：+ - * / % ++ --
        使用范围：只能适用于数字
        运算方向：从左至右运算
        级别：仅次于逻辑运算中的' ! '
        备注： 
            对于除法：
                如果除数和被除数都是整数，那么得到的结果也是整数；
                如果除数和被除数都是小数，那么得到的结果也是小数；并且是double类型的小数；
            对于取余运算：
                C语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
            对于自增自减运算：
                前自增在赋值时先运算后赋值；
                后自增在赋值时先赋值后运算；
    4：逻辑运算：
        运算符：&& || ！
        运算方向：从左至右
        级别：&& 和 || 小于关系运算符，！小于()大于算术运算符
        备注：运算结果是一个Bool值
    5：关系运算：
        运算符：< > <= >= == !=
        运算方向：从左至右
        级别：整体级别大于逻辑运算符的&&和||，小于算术运算符，但是同级别内< > <= >=的级别大于==和!=；
    6：赋值运算符：
        运算符：= += -= *= /= %= 
        方向：将右侧的值赋给左侧
        级别：级别最低；
    7：位运算：直接对二进制位操作的方式
        c语言包括6中位运算：& | ^ ~ << >>
        &：按照二进制位求交运算
        |：按照二进制位求或运算
        ^：按照二进制位求异或运算
        ~：按照二进制位取反
        <<:按照二进制位全部左移，高位丢弃，低位补0；
            （如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。）
        >>：按照二进制位全部右移，低位丢弃，高位补0或者1；最高位是0就补0，最高位是1就补1；
            （如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1） 
    8：几种操作符号的优先级： 
        1：定义中被括号( )括起来的那部分，优先级最高；
        2：后缀操作符：括号( )表示这是一个函数，方括号[ ]表示这是一个数组，优先级次之；
        3：前缀操作符：星号*表示“指向xxx的指针”，优先级较低；

十：流程控制：
    1：条件：
        1：if..else条件语句：
            if(表达式)
            {

            }
            --------------------------
            if(表达式)
            {

            }else if(表达式)
            {

            }else{

            }
            --------------------------
            if(表达式)
            {

            }else{

            }
        2:switch条件语句：
            switch(var){
                case 1:
                    code..
                    break;
                case 2:
                    code..
                    break;
                default:
                    code...
            }
            备注： 
                1：switch中只能是整数，不能是浮点数或者其余变量类型；
                2：case只能是整数，不能是浮点数或者其余变量类型
                3：多个分支有共同处理方式，则多个分支可以放在一起，只在最后一个分支结束时使用break语句；
                4：default不是必须的；当所有的case都无法匹配时，将会走进default;
                
        3：? :   三目运算符；

    3：循环：
        for(int i=0;i<n;i++)
        {

        }
        --------------------------
        while(表达式)
        {

        }
        --------------------------
        do
        {

        }while(表达式);(;一定要有)

    4：跳出循环：
        1：break;结束当前循环；
        2：continue;结束当前循环，并开始新的循环！

十一数据类型：
    基本数据类型：
        1：整数类型：
            short int                     2字节(16位)                -32768到32767
            (short)                 
            unsigned short int            2字节(16位)                0~65535
            (unsigned short) 

            int                           2/4字节(16位/32位)         -32768到32767或者-2e32到2e32-1       
            unsigned int                  2/4字节(16位/32位)         0~65535或者0~2e33-1
            (unsigned)

            long int                      8字节                     -2e64到2e64-1
            (long)
            unsigned long int             8字节                     0~2e65-1
            (unsigned long)

            long long int                 8字节                     -2e64到2e64-1
            (long long)
            unsigned long long int        8字节                     0~2e65-1
            (unsigned long long)

            修饰类型：
                signed      有符号(默认类型，无需携带)
                unsigned    无符号，最小值从0开始
            数据溢出：
                向上溢出
                    有符号类型溢出之后，将直接从负值最小值开始从新计数(向上递增)；
                    无符号类型溢出之后，将直接从0开始从新计数(向上递增)；
                向下溢出：
                    无论有符号还是无符号，均是从正值最大值从新计数(向下递减)；只是正值最大值在有符号和无符号之间不同！
        2：浮点数：
            float                       4字节                 6位小数（精确度）、单精度
            double                      8字节                 15位小数（精确度）、双精度
            long double                 16字节                19位小数（精确度）
            备注：
                1：c语言中浮点数无法精确表示浮点数值，只能近似的表示指定值；
                2：浮点数可以使用小数形式表达，也可使用指数形式表达；在内存中，整数部分和小数部分是分开存储的；
                3：对于一些算数运算，浮点数之间运算时损失的精度会更多；（原因在于在任何区间内都存在无穷多个实数，浮点数不能表示区间内所有的值，只是实际值的近似值）
        
        3：字符类型：
            1：C语言基本数据类型中没有字符串类型，只有字符类型；
            2：C语言中以''包裹的字符称为字符类型，以""包裹的字符串称之为字符串类型；
            3：字符类型标识：char;
            4：char用于声明字符时使用，但是字符实际保存时仍然保存的是字符对应的编码值；
            5：char的大小是一个字节，标识范围在-128~127之间；unsigned char的表示范围在0~255之间；
            6：宽窄字符：
                1：以char声明的，以''包裹的称之为窄字符，由窄字符组成的字符串称之为窄字符串；
                2：窄字符以ASCII编码存储；
                3：由于在windows平台中文字符采用utf-16存储，即使用2个字节存储一个中文字符，但是在unix平台采用utf-32存储，即使用4个字节存储一个中文字符；由于中文字符在不同平台中编译器的长度表示不一致，c标准推出了wchar_t类型，wchar_t的类型的长度由编译器决定！wchar_t类型位于<wchar.h>头文件中！
                4：使用wchar_t类型表示的字符称之为宽字符，由宽字符表示的字符串称之为宽字符串；
                5：使用wchar_t这种宽字符需要在字符前加L；如：wchar_t d = L'国';  //中文汉字 
            7：宽字符的打印：
            putwchar():只能输出宽单个字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
            wprintf():  用于输出宽字符串
                        宽字符标识：%ls;
                        用法：和printf完全一样
            8：常用的转义字符：
                1：转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制编码值，对于转义字符来说，只能使用八进制或者十六进制；
                2：转义字符的初衷是用于ASCII编码，因此取值范围有限：
                    八进制形式的转义字符最多后跟三个数字，即\ddd,最大取值\177;
                    十六进制形式的转义字符最多后跟两个数字，即\xdd，最大取值\7f
                    超出范围的转义字符是未定义的，如果是用超出范围的转义字符，编译器要么报错，要么直接输出！
                3：对于ASCII编码，0~31范围内的字符为控制字符，只能用转义字符来表示：
                    \a 	响铃(BEL)     
                    \b 	退格(BS)  
                    \f 	换页(FF)  
                    \n 	换行(LF)  
                    \r 	回车(CR)
                    \t 	水平制表(HT)     一般相当于四个空格，或者 tab 键的功能    
                    \v 	垂直制表(VT)    
                    \' 	单引号 
                    \" 	双引号 
                    \\ 	反斜杠 

        4：布尔类型：
            C99标准中添加了_Bool类型，用于表示布尔值；即：true和false
            _Bool大小仅为一位，存储0/1；0表示false,1表示true；
            C99标准中能够自动将其余数据类型转换为布尔类型的值；
        
        5：NULL类型：
            NULL本质上不是一种数据类型，而是一个宏：#define NULL ((void *)0)
            备注：
                1：void *仅仅表明：该指针变量的类型是未定义的；
                1：(void *)0 意为将整数0强制转换为一个指针，整体上来看，NULL即指向了地址为0的内存；
                2：C语言并未规定NULL的指向，只是大部分标准库约定俗成将NULL指向了0，因此，NULL和0并不等价；
        
        5：基本数据类型之间的转换：
            1：自动类型转换：
                自动类型转换是由编译器根据计算需求，自动将数据类型进行转换的一种方式；
                自动类型转换发生在两种情况下：
                    1：赋值时：如果类型转换合法，将会把右侧的变量转换为左侧变量的数据类型，然后赋值！(将高精度值赋给低精度值将会发生精度损失)
                    2：运算中：在运算时，编译器会将所有的数据的类型转换为同一种数据类型，然后再进行计算！
                        转换方向：
                            char/short->int->long
                                             ->float->double
                              转换方向为数据长度增加方向(高精度方向)进行;
                       所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也将全部转换为double进行运算；
                       需要注意运算结果的溢出！
            2：手动类型转换：
                强制类型转换方式：(目标数据类型)待转换变量  
            备注：
               1：无论是强制类型转换还是自动类型转换，转换改变的仅仅是结果，源数据的类型并不会改变！
               2：有些类型能够自动转换也能够强制转换，有些类型则只能强制转换不能自动转换！
               3：数据类型转换要合适，不能在不相干的数据类型之间随意转换！
            
    复杂数据类型：
        指针：
            1：内存地址：
                1：数据必须先要加载至内存中，才能够被CPU获取并处理；
                2：计算机的内存在系统中会被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，代表该存储单元，称之为存储单元的地址或者内存地址；                  
                3：内存中存储单元的地址是从0开始的，以十六进制表示；
                4：理论上：一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向
            
            2：指针：
                一个虚拟概念，代表指向某一个存储单元的地址；指针的值即为某个存储单元的地址！
            
            3：指针和数据：
                指针指的是某一个存储单元的地址；
                数据指的是某一个存储单元中存储的内容；
            
            4：指针变量：
                指针变量和普通的变量一样都是变量；区别在于：
                    1：指针变量存储的值表示某一个存储单元的地址；普通变量存储的值表示某一个存储单元中的内容；
                    2：指针变量的数据类型固定为unsigned int类型的16进制整数；普通变量的数据类型根据声明而定；
                特别注意：虽然指针变量存储的是unsigned int类型的整数，但是不可以将指针变量和存储unsigned int类型的普通变量进行运算！

                **关于指针变量和普通边声明的思考**：
                    1：变量代表的就是一个内存块(一个或者多个存储单元)中的内容，申请一个普通变量，系统即分配一块内存块，由一个或者多个存储单元组成，变量的值即为该内存块的内容；
                    2：申请一个指针变量，同样系统会分配一块内存块，有四个存储单元组成(unsigned int类型，因此有四个存储单元)，指针变量的值就是这块内存块的内容，只是这个内存块的内容代表的是某一个存储单元的地址而已；
                
            
            5：指针变量的声明：
                声明方式1：数据类型 *变量名
                声明方式2：数据类型 * 变量名
                备注： 
                    1：类型名称是指该指针指向的存储单元中存储的数据的数据类型；一旦声明完成之后，该指针指向的存储单元将只能存储声明的数据类型的数据；
                    2：*表明该变量是一个指针变量，*在指针变量声明时，可以有空格也可以紧贴变量名；
                    3：变量的命名规范和普通的变量命名规范一致；
            
            6：指针变量允许的运算；
                1：&:该符号是取地址符；可以通过&符号获取变量所引用的值在内存中的地址；
                2：*:该符号是取值符，可以通过*获取指针变量指向的内存单元所存储的值；
                3：设置存储单元中的内容：*指针变量 = 值；即可将值赋值给指针变量指向的存储单元；
                4：赋值：指针变量的值可以赋值给另一个指针变量(1：赋值双方必须都是指针变量；2：两个指针变量必须是相同的数据类型)
                5：加减运算：指针变量允许加上或者减去一个整数；
                6：自增/自减运算：指针变量允许进行自增自减运算；
                7：指针变量加减整数或者自增自减运算说明：
                    1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起所数据在内存中存储地址的改变；
                    2：指针变量加减某个整数m或者自增自减运算:
                        微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                        宏观上看：指针变量的加减运算改变的是当前指针指向存储单元的地址；
                    3：不允许对指针变量做除过加减/自增自减以外的任何其他算术运算；
                    4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
                    5：对于数组或者字符串，指针变量的加减/自增自减改变的是指针指向的元素位置，其值是可以预料的，是有意义的；
            7：空指针：
                1：在函数中声明一个指针变量，如果不为该指针变量进行初始化，该指针变量的值就是不确定的，因此该指针变量指向那一块存储单元也是未知的，大多数情况下是未分配或者没有读写权限的；如果对于这种指针变量不做处理，对程序的健壮性有影响；
                2：如果一个局部指针变量未被初始化的时候，推荐赋值为NULL，即将该指针设置为空指针；
                3：空指针的意思为：将一个指针变量的值设置为NULL；即该指针指向地址为0的存储单元，但是该存储单元中存储的数据类型是未知的！
            
            8：二级指针：
                1：指向另外一个指针的指针称之为二级指针；即二级指针指向另一个指针的存储地址；
                2：二级指针变量仍然只是一个普通的指针变量，数据类型仍然为unsigned int，其值仍然代表的是某一个存储单元的地址，只是该存储单元中存放的内容代表的是另外一个指针变量的地址；
                3：二级指针需要使用**来声明，同理三级指针需要使用***来声明；
                4：二级指针使用*取值运算符运算之后得到的是另一个指针的指向存储单元的地址，再次使用*取值运算之后得到另一个指针指向的存储单元的值；
        
        数组：
            1：数组：
                数据的集合称之为数组，数组中的每一个值称为数组的元素，数组中值的个数称之为数组的长度！
            2：数组的声明：
                1：数组在使用之前需要先声明后使用；
                2：数组的声明方式：数据类型 数组名[数组程度]；
                3：如果在函数内部声明数组，声明完成之后如果未初始化，那么数组的值是不确定的；
            3：数组的赋值：
                1：数组可以在声明的同时完成赋值：
                    1：完全赋值：即按照所声明的数组长度，填入相同个数的值；
                                如：int arr[3] = {1,2,3}
                            备注：完全赋值时数组可以不用显式指定长度；
                                如：int arr[] = {1,2,3}

                    2：不完全赋值：赋值的个数少于数组声明时指定的个数；
                                如：int arr[3] = {1}
                            备注：不完全赋值时，数组未赋值的部分也会按照基本规则进行初始化：
                                1：如果数组类型为：int,short,long,将直接赋值为整数0；
                                2：如果数组类型为：char,将赋值为\0；
                                3：如果数组类型为：float或者double，则将会赋值为0.0；
                2：数组在声明完成之后也可以进行赋值：
                    数组在声明完成之后只能通过下标一个一个进行赋值，不能再使用{}整体进行赋值;
            4：数组使用时的注意事项：
                1：数组元素在赋值的时候只能赋值指定数据类型的值，不能赋值其他数据类型的值；
                2：数组中元素的长度不能超过数组声明时指定的长度；
                3：C语言中数组是静态数组，即长度一旦声明好之后将不能再改变，不能随意插入数据，也不能随意删除数据；
                4：固定长度的数组是在编译期间分配内存的；
            5：二维数组：
                二维数组的声明：
                    数据类型 数组名[一维长度][二维长度];
                二维数组的本质：
                    二维数组本质上类似于一个矩阵：一维长度指的是矩阵的行数，二维长度指的是矩阵的列数；
                二维数组的存储：
                    二维数组在概念上是二维状态存在，但是在内存中则是按照一维顺序排列的；
                二维数组的赋值：
                    1：分段赋值：
                        1：完全赋值：每一行都完全赋值；
                        2：部分赋值：默认从左向右赋值，其余则按照数据类型填充；
                    2：连续赋值：
                        1：完全赋值：从左向右按行赋值；此时可不必给出一维长度；
                        2：部分赋值：从左向右按行赋值；其余则按照数据类型填充；
            
            6：数组与指针：
                1：数组一旦声明完成之后将占用的是一段连续的存储单元，占用存储单元的个数=数组长度*数组元素类型在当前平台占用的字节个数；数组的元素按顺序存储在这段连续的存储单元中；

                2：数组指针：
                    1：指向数组中某一个元素的指针称之为某个数组的数组指针，数组指针和普通的指针并无区别，仅仅只是在意义上数组指针指向的是某个数组中的某一个元素而已；
                    2：数组指针指向数组中的某一个元素，也仅仅只能够代表其所指向的数组元素，并不能够代表整个数组；即便数组指针指向的是数组的第一个元素，也只能代表数组的第一个元素，无法代表整个数组；
                    3：由于数组占用的是一段连续的存储单元，因此数组指针的加减和自曾自减即指向上一个或者下一个数组元素；
                3：数组名：
                    1：数组名仍然是一个变量，代表的是某一个数组；既可以看做整个数组的首地址，也可以看做整个数组；
                    2：C语言中在&运算符、sizeof运算符、数组声明时数组名代表整个数组，除上述三种情况以外，数组名均代表数组的首地址，即数组的第一个元素；
                    3：如果数组名代表的是数组的首地址，则和指向数组第一个元素的指针变量等价，否则和数组指针不等价！
            7：数组的基本操作：
                1：获取数组长度：
                    int len = sizeof(数组名)/sizeof(数组元素类型)
                    注意：
                        1：此种方式计算数组长度时，数组名必须代表的是整个数组，不能是指向第一个元素的数组指针；
                        2：如果函数要求传入数组类型的数据，此时如果传入数组名则仅仅代表的是数组的首地址，并不能代表整个数组，根据传入的数组名也无法使用sizeof来计算数组的长度，数组长度需要单独传入；
                2：数组的取值：
                    1：通过数组名访问：数组名[下标]
                    2：通过指针的方式访问：*(数组名+下标)
                    3：通过数组指针访问：*(数组指针+n)

                3：数组的赋值：
                    1：通过数组名赋值：数组名[下标] = 值
                    2：通过指针的方式赋值：*(数组名+下标) = 值
                    3：通过数组指针赋值：*(数组指针+n) = 值  

            8：指针数组：
                1：指针数组是指数组的每一项都代表一个指针；本质上和普通的数组并无区别！
                2：指针数组的声明方式：
                    1：数据类型名 *数组名[数组长度]
                    2：数据类型名 *(数组名[数组长度])
                3：数组指针指的是指向数组中某一个元素的指针；指针数组是一个数组，只是数组的每一项都是一个指针！
            
            9：指针与二维数组：
                  1：二维数组在概念上是二维的，但是在存储上是一维线性连续存储的；
                  2：二维数组通过指针的方式声明：数据类型 (*数组名)[n]; 如int (*p)[2]
                  3：关于二维数组和指针的理解：
                    声明一个数组如：int a[3][2] = {{1,2},{3,4},{5,6}}
                    那么a即等价于a[0]，a[0]本质上则是指向数组{1,2};
                    对于使用指针声明的方式而言：int (*p)[2]:p即代表a[0],等价于数组名a,p即指向数组{1,2}
        字符串：
            1：C语言中并没有专门存储字符串的基本数据类型，但并表示C语言不支持字符串！在C语言中使用数组来存储字符串、使用字符数组或者""来声明字符串！
            2：字符串的声明及初始化方式：
                声明方式1：char str1[2];   赋值：str1[0]='a';str1[1]='b';

                声明方式2：char str2[2] = {'a','b'};
                声明方式3：char str3[]  = {'a','b'};

                声明方式4：char str4[2] = {"ab"};
                声明方式5：char str5[]  = {"ab"};

                声明方式6：char *str6   = "ab";
                声明方式7：char *str7   = {"ab"};

                **备注：无论是通过字符数组的方式声明还是通过字符指针的方式声明、无论是通过单个字符的方式初始化还是通过""的方式初始化，本质上都是通过字符数组的方式来存储字符串！因此对于字符串的处理，可以完全使用处理字符数组的方式处理！

            3：获取字符串中的字符：
                字符串本质上是通过字符数组进行存储的，因此无论使用哪种声明方式都可以通过一下方式获取字符串中的字符：
                    1：数组的方式获取字符串中的字符：str1[0]; 或者：str6[0];
                    2：指针的方式获取字符串中的字符：*str1;   或者：*str6;
            4：字符串的存储位置：
                1：通过字符数组的方式声明的字符串，其存储位置是在栈区或者全局数据区；应用程序具备读取和写入的权限！因此可以对字符串本身进行修改！
                2：通过字符指针的方式声明的字符串，其存储位置是在常量区；应用程序只有读权限，没有写入权限！不能够对字符串本身进行修改，但是可以指向其他字符串！
            5：字符串的长度：
                1：字符串如果通过字符数组的方式声明，并以单个字符进行初始化，那么字符串的长度即为数组中的元素个数：
                    1：使用sizeof(字符数组名) 计算得到的长度是字符数组的声明长度，并非字符串实际长度！
                    2：使用strlen(字符数组名) 计算得到的长度则是字符串的实际长度！
                2：字符串如果通过字符指针的方式声明或者通过数组的方式声明但是通过""的方式初始化:
                    1：使用sizeof(字符数组名) 计算得到的长度是字符个数+1；原因在于：使用""初始化字符串时，程序只能够获取到字符串的起始位置，无法获取到终止位置，因此程序会自动在字符串的末尾添加一个\0来表示字符串的结尾；
                    2：使用strlen(字符数组名) 计算得到的长度则是字符串的实际长度！
                3：注意'x'和"x"不同，'x'代表字符，"x"代表单字符字符串；
                4：string.h头文件声明了对字符串的所有操作；包括最常用的strlen();


                                          

                


                


                

                



