php中的错误和异常：
    1：在php中错误和异常是两个概念，
        1：错误：php脚本自身的问题导致程序无法正常运行；
        2：异常：php脚本自身没有问题，但是在运行时出现超出预期的错误；
        3：php中错误不等同于异常，异常可以被try..catch捕获，但是错误无法被try..catch捕获
    2：php中抛出错误和异常
        1：php本身并不会主动抛出错误异常信息；需要手动抛出；
        2：手动抛出异常：throw new Exception("msg")
        3：手动抛出错误：trigger_error("error_msg",ERR_TYPE)
    3：错误和异常的产生分为两种：
        1：系统产生的错误和异常
        2：业务逻辑需要抛出的错误和异常
    4：php中的错误级别：
        E_ERROR：致命错误，运行时产生；
        E_WARING：警告，运行时产生；
        E_NOTICE：通知，运行时产生；
        E_CORE_ERROR：致命错误，php初始化启动过程中产生；
        E_CORE_WARING：警告，php初始化启动过程中产生；
        E_CORE_NOTICE：通知，php初始化启动过程中产生；
        E_COMPILE_ERROR：致命错误，编译时产生；
        E_COMPILE_WARING：警告，编译时产生；
        E_COMPILE_NOTICE：通知，编译时产生；
        E_USER_ERROR：致命错误，用户主动抛出；
        E_USER_WARING：警告，用户主动抛出；
        E_USER_NOTICE：通知，用户主动抛出；
        E_PARSE：编译时语法解析错误
        E_ALL：所有错误
        注意：所有的错误需要使用E_ALL&~E_NOTICE
    5：php本身处理错误异常机制：
        1：关于是否报告错误信息：
            是否报告错误信息：
                1：display_errors:在php.ini配置文件中设置该项；是否输出错误信息；
                2：ini_set("display_errors",0/1/on/off):0不显示，1显示；
                    在php.ini的配置文件里面设置display_errors = on/off:选择是否输出错误信息；
                    ini_set()这种设置方式仅仅在当前脚本有效；
            错误报告级别：
                1：error_reporting:在php.ini配置文件中设置该项；设置错误报告级别
                2：ini_set("error_reporting",E_ALL&~E_NOTICE):当前脚本中设置
                    在php.ini的配置文件中设置error_reporting的常量值；
                    ini_set()这种设置方式仅仅在当前脚本有效；
            记录错误日志：
                1：log_errors:设置是否将错误信息记录到日志中；在php.ini的配置文件里，设置log_errors的值；
                2：ini_set("log_errors",0/1);当前脚本中设置；
                3：log_errors_max_len :设置记录信息的最大字节数，0位不限制，默认是1024；、
            错误日志记录位置：
                1：error_log:设置记录错误信息的位置：在php.ini的配置文件中设置对应值；
                2：可设值：syslog:记录到系统日志；
                          log/mylog：记录错误信息至文件(对该文件必须要有写的权限)；
                3：ini_set("error_log","log/mylog.log");
        2：通过try...catch...捕获处理
                语法：try{
                        code...
                    }catch(Exception $e){
                        code...
                    }
                执行逻辑：
                    1：try中执行正常但有可能发生错误或者异常的代码
                    2：catch中执行发生错误或者异常之后的代码
                    3：catch捕获的是异常对象；
                    4：异常对象提供的方法：
                        $e->getMessage():获取异常信息；
                        $e->getCode():获取异常代码；
                        $e->getFile():返回发生异常的文件名；
                        $e->getLine():返回发生异常的代码行号
                        $e->getTrace():返回错误栈；
                    5：由于php无法自动抛出错误或者异常，因此需要在try块中手动抛出异常：
                        语法：
                            1：throw new Exception("自定义的异常提示信息")
                            2：异常提示信息被捕获之后可以通过$e->getMessage()来获取；
                        分析：使用try--catch块来捕获throw抛出的异常信息一般用于业务逻辑的需要抛出异常信息；系统本身的错误或者异常信息不推荐使用这种方式
        3：通过自定义错误或者异常信息处理函数来处理未被try..catch捕获的异常信息；
                1：自定义错误处理函数：
                    语法：set_error_handler("my_error_function_name",$type);
                    参数：参数为自定义的错误处理函数名称；
                         $type:允许自定义错误处理器处理的级别；
                    错误处理函数：
                        function my_error_handler($code,$message,$file,$line,$trace){}
                        参数说明：
                            $code:发生错误时的错误码
                            $message:发生错误时的信息
                            $file:发生错误时的文件
                            $line:发生错误时的行号
                            $trace:发生错误时的上下文信息
                    备注：该函数不能捕获E_ERROR,E_PARSE类型的错误
                2：自定义异常处理函数：
                    语法：set_exception_handler("my_exception_function_name",$type);
                    参数：参数为自定义的异常处理函数名称；
                         $type:允许自定义异常处理器处理的级别；
                    异常处理函数：
                        function my_exception_handler($exception){}
                        参数说明：
                            $exception：异常对象；
                            通过异常对象可以获取错误异常信息
                3：捕获php错误：
                    语法：
                        register_shutdown_function("my_shutdown_func")
                    功能：
                        捕获php的Fatal Error,Prase Error等；比如脚本错误，die(),exit(),异常，正常结束都会调用该函数；通过该函数可以判断脚本此次执行是否有错误产生；重点在于这个函数可以捕获E_ERROR和E_PARSE；
                    获取本次脚本执行产生的所有错误：
                        error_get_last();
                        返回值：返回一个数组，包含错误类型，错误消息，发生错误所在的文件，发生错误所在的行；
                        该函数需要放在my_shutdown_func中调用
                    备注：
                        1：该函数只能捕获运行时发生的错误或者异常信息，parse-time时期根本不会执行；
                        2：框架中之所有能够触发该函数原因在于：框架中一定会有一个index.php文件，其余所有待执行的代码都会通过include引入到index.php中，只要index.php不出错，其他文件出错均属于运行时出错；
    
    错误异常处理示例：
        function halt($error){
            ob_start();
            if(is_array($error)){
                print_r($error);
            }
        }

        function my_error_handler($code,$message,$file,$line,$trace){
            ob_end_clean();
            $error = array(
                "code"=>$code,
                "message"=>$message,
                "file"=>$file,
                "line"=>$line,
                "trace"=>$trace,
            );
            halt($error);
        }
        function my_exception_handler($exception){
            ob_end_clean();
            $e = array(
                "code"=>$exception->getCode(),
                "message"=>$exception->getMessage(),
                "file"=>$exception->getFile(),
                "line"=>$exception->getLine(),
                "trace"=>$exception->getTrace(),
            );
            halt($e);
        }

        function shutdown_fun(){
            $info = error_get_last();
            if($info){
                ob_end_clean();
                $e = array(
                    "code"=>$info['type'],
                    "message"=>$info['message'],
                    "file"=>$info['file'],
                    "line"=>$info['line'],
                    "trace"=>array(),
                );
                halt($e);
            }
        }		

        set_error_handler("my_error_handler",E_ALL&~E_NOTICE);

        set_exception_handler("my_exception_handler");

        register_shutdown_function("shutdown_fun");
                    
                    

                    
                                

                    
                    


   


