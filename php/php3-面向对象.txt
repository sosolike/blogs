<?php
面向对象思想：
	可以将任何事物都可以看成一个独立的个体，也就是对象；对于一个独立的事务当成一个对象时，也就具备了静态属性以及动态属性两种特征；静态属性代表该对象具备的一些特征，动态属性则代表该对象具备的一些行为；对于面向对象而言，即把对象看做一个资源，通过组织调用对象的特征以及对象的行为来解决问题；

面向对象编程：
	按照面向对象的思想，将能够执行某些任务的程序块进行集中管理成类，将类抽象成现实中的对象，而对象能够对外提供相关的服务；最终将某个问题的解决变为调动一系列对象，并利用对象所向外提供的服务来解决问题的方式，即为面向对象编程；面向对象编程需要语言本身支持；

面向对象编程和面向过程编程：
	从思维方式上：面向对象针对的目标是资源；
				 面向过程针对的目标是实现；
	从编码方式上：面向对象可以实现代码的组合，继承；
				面向过程编程仅能够实现代码的组合；
	从代码结构上：面向对象可以通过面向对象的封装，继承，多态等特征保证代码的松耦合，高内聚；
				面向过程编程对设计模式的利用更弱一些，相对于面向对象编程，代码结构更加臃肿；
	从代码组成上：面向过程编程是面向对象编程的基本组成；
	面向对象编程需要语言本身的支持；


面向对象编程的基本组成要素：
类：
	1：特征：
		1：类对于程序而言就是代码块，但是在面向对象的思想中，类是创建具体对象的模板，是对一些列特征的抽象；
		2：对象在程序中是对类的一种封装，但是在面向对象的思想中，对象是类的具体化的实例；
		3：类中包含了一系列属性和方法(实例属性，静态属性，实例方法，静态方法等)；类在实例化得到具体的对象之后，即可通过对象调用类中的实例属性以及实例方法；
	2：类的声明：
		class ClassName{
			//类成员；
		}
	3：声明语法规则：
		class关键字应该小写；
		ClassName在没有具体要求的时候严格遵守php标识符命名规则；应该采用驼峰式命名法命名；每一个单词首字母都应该大写；
		其中在框架里面类的创建按照框架语法进行；
	4：类中的成员：
		属性：静态属性/实例属性；
		方法：静态方法/实例方法/魔术方法/构造方法/析构方法；
		常量：const；
	5：类的三大特性：
		1：封装；2：继承；3：多态；
		类的三大特性是设计模式的根基；
对象：
	特征：
		1：对象就是类的一种封装概念；由对象可以代表类中的一些基本特征；
		2：在创建对象时系统会分配堆内存来存储对象的实例属性和实例方法；由同一个类实例化出的对象具备相同的基本特征；

	2：对象的创建：
		$link_name = new ClassName();//无需传入参数
			
		$link_name = new ClassName(a,b,c);//需要传入参数；

		$link_name = new ClassName;

		$var = ClassName;
		$link_name = new $var();//通过变量创建对象；
			
		创建对象时，是否传入参数完全根据构造函数而定；

	3：直接打印对象：
		在5.1版本以下直接打印对象可得到包含对象ID的字符串；
		在5.2版本之后无此功能，必须重写类的__tostring()方法；该魔术方法的返回值即为打印对象后的内容；

	4：对象的赋值：
		$link = $link_name;
		$link = &$link_name;

	5：对象的销毁：
		1：php中对象是在执行完脚本后会将该脚本执行期间所创建的所有对象进行销毁；
		2：如过在执行期间需要强制销毁的话：unset($link_name);
		3：当一个对象没有任何变量引用的时候将会被自动销毁；

属性：
	1：属性类别：
		静态属性；
		实例属性；
	2：属性的声明方式：
		实例属性：访问权限修饰符  属性名  [= 值]；
		静态属性：访问权限修饰符  static  属性名  [= 值]；
	3：访问：
		实例属性：
			类内：$this->abtName;
			对象：$obj->abtName;
		静态属性：
			类内：self::$var_name
			类外：Class_name::$var_name;
	4：存储位置：
		静态属性：静态存储区域；
		实例属性：随着对象的创建存储在对象所属的堆内存中；
	5：生命周期：
		静态属性：在类加载过程中，就会将静态属性加载至内存中；在脚本执行期间一直有效；脚本执行完毕将会被销毁；
		实例属性：在对象创建过程中才会分配内存空间，对象销毁，该对象的实例属性也将会被销毁；
方法：
	1：种类：
		静态方法；
		实例方法；
	2：声明：
		实例方法： 访问权限修饰符 修饰性关键字 function  function_name(){};
		静态方法： 访问权限修饰符 修饰性关键字 static function function_name(){};
	3：访问：
		实例方法：
			类：$this->function_name();
			对象：$link->function_name();
		静态方法：
			类内：self::function_name();
			类外：Class_name::function_name();
	4：存储位置：
		静态：在静态存储区域；
		实例：随着对象的创建分配在堆内存中；
	5：所属关系：
		静态方法：属于类；
		实例方法：属于对象；	
	6：注意：
		实例方法中调用静态方法和静态属性是允许的；
		在静态方法中调用实例属性和方法是不允许的；如果非调不可；可以在静态方法中创建对象，通过对象来调用；
魔术方法：
		1：__get($a):
			1：功能：该魔术方法用于获取属性的值；
			2：参数：
				$a:仅接收一个参数，表示需要访问的属性的名称；
			3：使用：
				1：可通过该方法访问私有属性,不受权限限制；
				2：可以利用此方法设置属性访问规则，以及对需要访问的属性做处理；类似于其他语言中的getter；
				3：在访问不存在属性的时候也会主动调用该方法；可以通过该方法定制错误提示；
			4：备注：1：该方法必须是public的且一定不能为static；
				    2：该方法不能手动调用，在实际调用的时候以访问属性的方式直接访问即可；

		2：__set($a,$b):
			1：功能：此方法用于设置属性的值；也可设置私有属性的值；
			2：参数：
				第一个参数为要设置的属性，
				第二个参数为要设置的值；
			3：使用：
				1：该方法可以设置私有属性的值；
				2：该方法可以设置属性的设置规则；类似于其他语言的setter；
				3：在设置不存在的属性时，可以返回自定义的错误提示；
				4：可以将类实现为存储类；类似于标准类；
			4：备注：1：该方法必须是public的且一定不能为static；
				    2：该方法不能手动调用，在实际调用的时候以访问属性的方式直接访问即可；

		3：__isset($a):
			1：功能：
				此方法用于检测所查属性是否存在；
			2：参数：
				$a：表示需要检测的属性名；
			3：使用：
				1：通过该方法可以检查私有属性是否存在；
				2：通过该方法可以设置属性的检测规则；
				3：通过该魔术方法可以自定义不存在属性时的错误提示；
			4：备注：1：该方法必须是public的且一定不能为static；
				    2：该方法不能手动调用，在实际调用的时候以isset()的方式访问即可；

		4：__unset($a):
			1：功能：在删除不存的属性的时候会调用；
			2：参数：
				$a：待删除的属性名称；
			3：使用：
				1：通过该方法可以设置属性的删除规则；
				2：通过该方法可以删除私有属性；
				3：删除不存在的属性时，会主动调用该方法，可以通过该方法设置自定义的错误提示；
			4：备注：1：该方法必须是public的且一定不能为static；
				    2：该方法不能手动调用，在实际调用的时候以unset()的方式访问即可
			
		5：__call($function_name,$argument):
			1：此方法在调用不存在的方法时会自动调用；
			2：可以用此方法更好的处理上述这种错误；
			3：利用此方法可以根据参数的个数实现方法的重载；

		   __callstatic($function_name,$argument):
		   	1：此方法在调用不存在的静态方法时会自动调用；
			2：可以用此方法更好的处理这种错误；
			3：通过该方法同样也可以实现静态方法的重载；

		6：__tostring()
			通过改写这个函数，可以在echo对象的时候输出相关信息，该函数的返回值即为echo对象之后的信息；

构造函数和析构函数：
		构造方法：
			1:声明：public function __contruct(){};
			2：注意：
				1：必须使用public作为修饰符，如果私有化之后将无法初始化所创建的对象；
				2：函数名必须使用__contruct作为函数名；
				3：构造函数是用于初始化对象的，并非创建对象；
				4：如果构造函数有参数，在创建对象时必须给予参数；

		析构方法：
			1：声明：public function __destruct(){
				//进行销毁操作；一般进行资源释放
			}
			2：注意：
				1：一个对象被销毁之前会主动调用该方法；
				2：该方法不能带参数；
				3：系统会先调用该析构方法，然后进行销毁操作；
常量：
	1：常量的声明：
		const NAME = value;
	2：const声明的常量是可以识别命名空间；
	3：const声明的常量名严格区分大小写；
	3：常量赋值只能进行一次，可以在声明之时进行赋值，可以在以后赋值，但只能赋值一次；
	4：调用方式：
		ClassName::CONST_NAME
类的三大特性：
封装：
	1：封装：保护内部实现，预留一定接口供外部调用；
	2：封装的基本原则是：保护好封装体的内部，只预留必要接口；
	3：php面向对象中的封装：设置属性以及方法的访问权限来实现封装的；
	4：访问权限：
		1：private:
			私有权限；
			被private修饰的属性或者方法只能在本类中调用；
			在类的外部以及子类中无法使用；
		2：protect：
			保护权限；
			被protect修饰的属性或者方法只能在本类和本类的子类中使用；
			类的外部不能使用；
		3：public：
			公共权限；
			任何地方都可调用；

继承：
	1：继承：一个类扩展另一个类的过程；一个类继承另一个类，被继承的称为父类，继承者称为子类；
	2：继承的结果：
		1：子类继承父类之后将会具备父类的所有非private权限的实例属性和实例方法；
		2：所继承的实例属性以及实例方法可以直接通过子类的实例对象访问；
		3：也可以在子类中直接访问父类的实例属性和实例方法；

	3：php只支持单继承；即一个子类最多只能继承一个父类；

	4：继承要用extends关键字；如：class ChildrenClass extends ParentClass{}

	5：子类内部调用父类方法：
		对于实例属性以及实例方法：
			$this->实例属性名
			$this->实例方法名
			或者：
			parent::实例属性名
			parent::实例方法名
			(在方法重写时只能使用parent访问父类实例属性和实例方法)
			(子类中使用$this调用实例属性以及实例方法时，会优先调用子类内部的同名属性以及同名方法，如果没有将会调用父类的实例属性和实例方法)

		对于静态方法和静态属性，
			ParentClassName::属性名；
			ParentClassName::方法名；
			或者：
			parent::实例属性名
			parent::实例方法名

	6：重写父类方法：
		1：只能重写非private，非static,非final的方法；
		2：需要保持方法名和参数与父类中的方法名和参数一致；
		3：重写之后的方法权限必须等于或高于原方法；
		4：在重写父类方法时，如有需要调用父类原方法需要通过parent来调用父类的实例方法；

	7：子类的构造和析构方法：
		1：如果子类有自己的构造和析构方法，将在创建对象或者对象销毁的时候，调用子类的构造方法和析构方法；
		2：如果子类没有将会调用父类的构造方法和析构方法；
		3：在子类中调用父类的构造方法：
			parent::__contruct();
		4：调用位置可以在子类的任何方法的任何位置；

多态：
	同属于一个父类的子类，具有相同的父类类型；能够接受父类类型的地方同样能够接受子类类型；即称之为多态；
	多态的特征在强数据类型(如java)中尤其重要；

	多态的实际使用：如果每个子类具有相同的方法，在需要调用的地方只需声明父类类型即可，并且通过每个不同的子类调用同一个方法可以得到不同的结果；这就是接口的提现；

	多态的特征对于面向对象中接口以及抽象类的意义非常重要；也正是由于多态的存在，才使得面向对象中的接口以及抽象类有了实际的意义；

类的三种特殊形式：

1：最终类/最终属性/最终方法：
	1：最终类：
		1：在类的前面加上final关键字；final class ClassName{}
		2：最终类将不能被继承；属性和方法更不会被重写；
	2：最终方法：
		在方法前加上final关键字；public final function function_name(){};
		该方法子类将不能重写；
	3：最终属性：
		在属性前面加上final关键字；public final $var = $value;
		加上final关键字之后属性只能赋值一次；
2：抽象类：
	1：有抽象方法的类称为抽象类；
	2：抽象方法：只有方法声明，没有方法体的方法，必须要有abstract修饰；public abstract function function_name();
	3：抽象方法不能是static的，不能是final的，不能是private的；
	5：抽象类前面也必须要有abstract修饰；abstract class ClassNmae{}
	6：抽象类的特点在于实现了一部分方法，但仍有方法没有实现，却声明了这些方法的标准；抽象类是无法创建对象的；
	7：抽象类多做为模板使用，及抽象类搭建好了基础，预留一定的diy空间；继承抽象类的子类只有完全实现了抽象类的抽象方法才能实例化对象，否则仍然不能实例化对象；
	8：abstract class My{
			public function myfuction();
		}	
	9：抽象类存在的意义在于模板；

3：接口：
	1：超级抽象类；
	2：接口名必须要有interface修饰，而非class；interface InterfaceName{}
	3：接口要求：
		1：所有的属性必须是public的静态最终量；public final static $a
		2：方法不能被private修饰,不能被final修饰，不能存在static的方法，且必须全部为抽象方法

	4：接口可以继承接口，使用extends，接口继承接口只能是单继承;
	5：类可以继承多个接口，多个接口之间用','隔开，继承时需要使用implements关键字；
	6：类在继承类的同时仍然可以继承接口；
	8：由于接口中全部为抽象方法，因此接口不能直接创建实例；
	9：接口更多的是标准，是规范；是对未来子类的约束；(在实际中类似usb接口，可以插入不同设备实现不同功能，但是这些设备都必须要最受usb协议；)

面向对象中常用的方法：
	1：instanceof关键字：
		1：用于检测一个对象是否是指定类的对象；
		2：$a instanceof Class_name;
	2:其他一些方法：
		1：class_exists():检测类是否存在；class_exists('ClassName')
		2：interface_exists():检测接口是否存在；interface_exists('ClassName)
		3：get_class($obj):获取指定对象的类名；
		4：get_parent_class($obj):获取指定对象所属类的父类名称；
		5：get_class_methods($class):获取一个类的所有方法名；只能获取public权限的实例方法以及静态方法；
		6：get_class_vars($class):获取一个类的所有属性名；
	3:和类有关的常量：
		1：__CLASS__:类名
		2：__METHOD__:方法名
	4:克隆：
		1：$b = clone $a;
		2：克隆之后两个对象一模一样；但是保持独立；这种复制只是浅复制；对于引用属性依然保持原来的引用；
		3：如果希望克隆之后新的对象有自己特殊的属性或者方法，只需要在相应类里面重写clone方法：
				private __clone(){
					$this->ins = new_value;
				}
	5:对象的遍历：
		1：只能遍历访问权限为public的实例属性；
		2：foreach($a as $key => $value)
		3：对于私有属性或者静态属性的遍历可以在类内部提供方法实现；

	6:php标准类：
			1：php内部有很多已经写好的类；
			2：stdclass:内置标准类；
			3:主要作用就是用来存储一些数据；原理和__set类似；
			4：$obj = new stdclass;
	7:类型转换：
		php中面向对象的类型转换：
			1：只能是由子类的对象转换成父类的对象；
			2：数组转换为对象：转换完成后键名将变成属性名，键值将成为属性值；只能转换关联数组，不能转换索引数组；				
			3：null转换为对象之后将成为空对象；
	8:类型约束：
		1：php为弱数据类型语言，基本不支持类型约束；
		2：只有方法的形参支持类型约束；
		3：约束只能是某个类，数组，接口；
		4：约束之后再调用该方法类型必须符合要求；
	9:序列化和反序列化：
		序列化：把对象转变为一个字符串流；
			serialize();  
			file_put_contents('store', $s);
			存入文件，按顺序存储，取得时候必须按顺序取；
		反序列化：把序列化的字符串流转变对象；
			unserialize(); 
			file_get_contents('store', $s);
			从文件中取出来的时候是按序列化时的顺序取的；
			取出来之后类文件必需引入当前文件，否则将会出错；
	10:对象的比较：
		当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等;
		而且两个对象是同一个类的实例，那么这两个对象变量相等。

			而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。
