<?php
面向对象思想：
	将任何具体的事物都看成一个独立的个体，当这个个体作为某种目标的时候，即称为对象；该个体有独立的属性和动作；个体是以一种资源的形式存在；
面向对象编程：
	按照面向对象的思想，将能够执行某些任务的程序块进行集中管理成类，将类抽象成现实中的对象，而对象能够对外提供相关的服务；最终将某个问题的解决变为调动一系列对象，并利用对象所向外提供的服务来解决问题的方式，即为面向对象编程；
面向对象编程和面向过程编程：
	面向对象编程：1：对象的实现；
				2：对象的调用；
				---编程者更多的是处于对资源合理调用的状态，以及抽象资源的状态；
				由于面向对象更符合对现实环境的描述，因此程序也能够更贴近现实解决问题；
				能够更多的进行代码的复用；
				能够模拟现实更多的场景--即设计模式的应用汇更合理；
				程序更易于理解；
	面向过程编程：1：某一步过程的实现；
				---编程者是按照解决问题的方式进行一步一步的编程；
				代码的复用性查；
				代码的结构差；
类：
	1：类是一类对象的集合；对于程序而言就是代码块，这种代码块里面包含了属性和方法；
		属性即是对现实环境中具体事物的静态特征的抽象；
		方法即是对现实环境具体事物的动态行为的抽象；
		对象是该类的实例；
	2：类的声明：
		class ClassName{
			//类成员；
		}
	3：声明语法规则：
		class关键字应该小写；
		ClassName在没有具体要求的时候应该采用驼峰式命名法命名；每一个单词首字母都应该大写；
		在框架里面类的创建按照框架语法进行；
	4：类中的成员：
		属性：静态属性/实例属性；
		方法：静态方法/实例方法/魔术方法/构造方法/析构方法；
		常量：const,final；
	5：类的三大特性：
		1：封装；2：继承；3：多态；
		类的三大特性是设计模式的根基；
对象：
	1：对象就是对类的抽象；包含了该类的实力属性和方法；能够通过调用对象的属性和方法向外提供服务；
	2：对象的创建：
		$link_name = new ClassName;
		$link_name = new ClassName();
			//无需传入参数
		$link_name = new ClassName(a,b,c);
			//需要传入参数；
		$var = ClassName;
		$link_name = new $var();
			//通过变量创建对象；
		是否传入参数完全根据构造函数而定；
	3：直接输出对象：
		在5.1版本一下直接输出对象可得到包含对象ID的字符串；
		在5.2版本之后五次功能，必须重写类的__tostring()方法；
	4：对象的赋值：
		$link = $link_name;
		$link = &$link_name;
	5：对象的销毁：
		1：php中对象是在执行完脚本后会将该脚本的所有对象销毁，在执行过程中是无法销毁的；
		2：如过在执行期间需要强制销毁的话：unset($link_name);
		3：销毁之前如果对象有赋值操作，要注意结果；对象有可能无法完全销毁；
属性：
	1：属性种类：
		静态和非静态(实例属性)两种；
	2：属性的声明方式：
		实例属性：访问权限修饰符  var  属性名  [= 值]；
		静态属性：访问权限修饰符    static  属性名  [= 值]；
	3：访问：
		实例属性：
			类内：this->abtName;
			对象：$link->abtName;
		静态属性：
			类内：self::$var_name
			类外：Class_name::$var_name;
	4:操作：
		取值/赋值；
	5：存储位置：
		静态属性：静态存储区域；
		实例属性：堆内存中；
	6：生命周期：
		静态属性：在类加载过程中，就会将静态属性加载至内存中；在脚本执行期间一直有效；脚本执行完毕将会被销毁；
		实例属性：在对象创建过程中才会分配内存空间，对象销毁，实例属性也将会被销毁；
方法：
	1：种类：
		静态方法和非静态方法(实例方法)以及魔术方法三种；
	2：声明：
		实例方法： 访问权限修饰符 修饰性关键字 function  function_name(){};
		静态方法：	public 修饰性关键字 static function function_name(){};
	3：访问：
		实例方法：
			类：$this->function_name();
			对象：$link->function_name();
		静态方法：
			类内：self::$function_name();
			类外：Class_name::function_name();
	4：存储位置：
		静态：在静态存储区域；
		实例：在堆内存中；
	5：所属关系：
		静态：属于类；
		实例：属于对象；	
	6：注意：
		实例方法中调用静态方法和静态属性是允许的；
		在静态方法中调用实例属性和方法是不允许的；如果非调不可；可以在静态方法中创建对象，通过对象来调用；
魔术方法：
		1：__get($a):
			1：用于获取属性的值；对于私有属性只要重写该方法即可获取相应的值；
			2：该方法接收一个参数---属性名称；
			3：该方法是系统主动调用的，不允许人为手动调用；
			4：在外部访问私有属性的时候按照正常形式访问即可；
			5：可以利用此方法设置属性访问规则；
			6：在访问不存在属性的时候也会主动调用该方法；可以通过该方法定制错误提示；
		2：__set($a,$b):
			1:此方法用于设置属性的值；也可设置私有属性的值；
			2：第一个参数为要设置的属性，第二个参数为要设置的值；
			3：该方法是系统自动调用的，应该私有化，禁止手动调用；
			4：该方法可以设置私有属性的值；
					可以更好的返回错误提示；
					可以将类实现为存储类；类似于标准类；
		3：__isset($a):
			1：此方法用于检测所查私有属性是否存在；
			2：该方法会主动调用，应该私有化，防止主动调用；
			3：在外部检测时任然用常规isset()方法检测；
			4：可以利用此方法人性化处理属性不存在的情况；
		4：__unset($a):
			1:在删除不存的属性的时候会调用；
			2：通过该方法可以实现更合理的错误提示；
			3：避免手动调用；
			4：参数为属性的名称；
			5：可以通过该函数删除私有属性；
		5：__call($function_name,$argument):
			1:此方法在调用不存在的方法时会自动调用；
			2：可以用此方法更好的处理这种错误；
			3：该方法应该避免主动调用；主动修改，
			4：第二个参数是数组，保存所传进来的参数；
			5：利用此方法可以根据参数的个数实现方法的重载；
		   __callstatic($function_name,$argument):
		   	1:此方法在调用不存在的静态方法时会自动调用；
			2：可以用此方法更好的处理这种错误；
		6：__tostring()
			通过改写这个函数，可以在echo对象的时候输出相关信息	
构造函数和析构函数：
		构造方法：
			1:声明：public __contruct(){};
			2：注意：
				1：必须使用public作为修饰符，如果私有化之后将不能在类外部创建对象；
				2：函数名必须使用__contruct作为函数名；
				3：用于进行对象的初始化操作；即给实例属性赋初值；
				4：构造函数并不能创建对象，构造函数仅仅是初始化对象；
				5：如果构造函数有参数，在创建对象时必须给予参数；

		析构方法：
			1：声明：public __destruct(){
				//进行销毁操作；一般进行资源释放
			}
			2：注意：
				1：一个对象被销毁之前会主动调用该方法；
				2：该方法不能带参数；
				3：不能人为调用该方法，是系统主动调用的；
				4：系统先调用析构方法，然后进行销毁操作；
常量：
	1：常量的声明：
		const NAME = value;
	2：const声明的常量是可以识别命名空间；
	3：常量赋值只能进行一次，可以在声明之初进行赋值，可以在以后赋值，但只能赋值一次；
	4：调用方式：
		ClassName::CONST_NAME
封装：
	1：封装：对象本质上就是对类的封装；也认为将类的属性或者方法设置一定的权限，禁止外界与其直接接触，只预留一定接口给外部使用；称为封装；
	2：封装的基本原则是：保护好封装体的内部，只预留必要接口；
	3：访问权限：
		1：private:
			私有权限；
			被private修饰的属性或者方法只能在本类中调用；
			在类的外部以及子类中无法使用；
		2：protect：
			保护权限；
			被protect修饰的属性或者方法只能在本类和本类的子类中使用；
			类的外部不能使用；
		3：public：
			公共权限；
			任何地方都可调用；
继承：
	1：继承：一个类扩展另一个类的过程；一个类继承另一个类，被继承的称为父类，继承者称为子类；
	2：继承的结果：
		子类具有父类的所有的实例属性和实例方法(私有属性和方法除外)；这些方法和属性可以通过子类对象直接调用；
		也可以在子类中调用父类的属性和方法；静态属性、方法和动态属性、方法均可直接调用；
	3：php只支持单继承；
	4：继承要用extends关键字；
	5：子类调用父类方法：
		parent::属性名；
		parent::方法名；
		对于实例方法和实例属性，
			$this->function_name()
			$this->attr_name;
	6：重写父类方法：
		1：只能重写非private，非final的方法；
		2：需要保持方法名和参数一致；
		3：重写之后的方法权限必须等于或高于原方法；
	7：子类的构造和析构方法：
		1：如果子类有自己的构造和析构方法，将在创建对象或者对象销毁的时候，调用子类的构造方法和析构方法；
		2：如果子类没有将会调用父类的方法；
		3：在子类中调用父类的构造方法：
			parent::parent_contruct();
		4：调用位置可以在父类的任何方法的任何位置；
最终类/最终属性/最终方法：
	1：最终类：
		1：在类的前面加上final关键字；final class ClassName{}
		2：最终类将不能被继承；属性和方法更不会被改写；
	2：最终方法：
		在方法前加上final关键字；public final function function_name(){};
		该方法子类将不能重写；
	3：最终属性：
		在属性前面加上final关键字；public final $var = $value;
		加上final关键字之后属性只能赋值一次；
		类似于常量；	
抽象类：
	1：有抽象方法的类称为抽象类；
	2：抽象方法：只有方法声明，没有方法体的方法；public abstract function function_name();
	3：抽象方法前面必须要有abstract修饰；
	4：抽象类前面也必须要有abstract修饰；abstract class ClassNmae{}
	5：抽象类更多的是作为基础模板使用的；无法直接创建对象；
	6：继承抽象类之后，如果实现了抽象类的所有抽象方法之后才可以创建对象，否则仍然无法创建对象；
	7：abstract class My{
			public function myfuction();
		}	
	8：抽象类更多是个半成品，且允许自定义的形象；类内部实现了一些必备的方法；预留一些抽象方法供自定义；
接口：
	1：超级抽象类；
	2：类名必须要有interface修饰；
	3：接口要求：
		1：所有的属性必须是public的静态常量；public final static $a
		2：所有方法权限均为public;
		3：所有方法均为抽象方法；
		4：方法不能被private修饰
		5：方法不能被final修饰；
		6：方法不能是静态的；
	4：接口可以继承接口，使用extends;
	5：类可以继承多个接口，多个接口之间用','隔开；
	6：类继承接口必须使用implements关键字；
	7：类在继承其他类的时候仍然可以继承其他接口；
	8：接口不能直接创建实例；
	9：接口更多的是模板，是规范，是一种标准；在实际中类似usb接口，可以插入不同设备实现不同功能，但是这些设备都必须要最受usb协议；
		主要用于API的开发；是对某一个模块功能的标准化；
面向对象中常用的方法：
	1：instanceof关键字：
		1：用于检测一个对象是否是指定类的对象；
		2：$a instanceof Class_name;
	7:其他一些方法：
		1：class_exists():检测类是否存在；
		2：interface_exists():检测接口是否存在；
		3：get_class($obj):获取指定对象的类名；
		4：get_parent_class($obj):获取指定对象所属类的父类名称；
		5：get_class_method($class):获取一个类的所有方法名；
		6：get_class_vars($class):获取一个类的所有属性名；
		7：__CLASS__:类名
		8：__METHOD__:方法名
其他规范：
	克隆：
		1：$b = clone $a;
		2：克隆之后两个对象一模一样；但是保持独立；这种复制只是浅复制；对于引用属性依然保持原来的引用；
		3：如果希望克隆之后新的对象有自己特殊的属性或者方法，只需要在相应类里面重写clone方法：
				private __clone(){
				$this->ins = new value;
				}
	对象的遍历：
		1：只能遍历实例属性（public修饰的）
		2：foreach($a as $key => $value)
		3：对于私有属性或者静态属性的遍历可以在类内部提供方法实现；
	php标准类：
			1：php内部有很多已经写好的类；
			2：stdclass:内置标准类；
			3:主要作用就是用来存储一些数据；原理和__set类似；
			4：$obj = new stdclass;
	类型转换：
		php中面向对象的类型转换：
			1：只能是由子类的对象转换成父类的对象；
			2：数组转换为对象：转换完成后键名将变成属性名，键值将成为属性值；只能转换关联数组，不能转换索引数组；				
			3：null转换为对象之后将成为空对象；
	类型约束：
		1：php为弱数据类型语言，基本不支持类型约束；
		2：只有方法的形参支持类型约束；
		3：约束只能是某个类，数组，接口；
		4：约束之后再调用该方法类型必须符合要求；
	序列化和反序列化：
		序列化：把对象转变为一个字符串流；
			serialize();  
			file_put_contents('store', $s);
			存入文件，按顺序存储，取得时候必须按顺序取；
		反序列化：把序列化的字符串流转变对象；
			unserialize(); 
			file_get_contents('store', $s);
			从文件中取出来的时候是按序列化时的顺序取的；
			取出来之后类文件必需引入当前文件，否则将会出错；
		对象的比较：
			当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等;
			而且两个对象是同一个类的实例，那么这两个对象变量相等。

			而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。
