c指针+c数组+c字符串+结构体+c常量+预处理

一：指针：
    1：内存地址：
        数据要被cpu获取到必须先加载至内存中，
        内存在计算机中会被分割为若干个1个字节大小的存储单元，
        每一个存储单元都有一个编号，这个编号即为该存储单元的地址！
        内存中存储单元的地址从0开始，以十六进制表示！
            
    2：指针：
        指向存储单元的标记(内存中存储单元的编号)，就是存储单元的地址！
    
    3：指针和数据：
        指针指的是存储单元的地址(即内存中存储单元的编号)，数据指的是这个地址的存储单元中存放的数据内容；

    4：指针变量： 
        指针变量和普通的变量一样都是变量；
        但是指针变量引用的数据代表的是存储单元的地址；普通变量引用的数据是存储单元中的内容； 
        指针变量存储的数据类型为16进制的unsigned int类型的整数；但是不能直接将指针变量等同于指向无符号整数的普通变量！更不能直接参与算数运算！
    
    5：指针变量的声明：
        1：数据类型名称 *变量名
        2：数据类型名称 * 变量名
        备注：
            1：类型名称是指该指针指向的存储单元中存储的数据的类型；
            2：*指明该变量是指针变量，*在声明时和变量之间可以有空格也可以没有空格；
            3：变量的声明规范和普通变量的声明规范一致；
            4：*作为取值运算符时必须和变量紧紧挨在一起；

    6：指针变量允许的运算：
        1：&:该符号是取地址符；可以通过&符号获取变量所引用的值在内存中的地址；
        2：*:该符号是取值符，可以通过*获取指针变量指向的内存单元所存储的值；
        3：设置存储单元中的内容：*指针变量 = 值；即可将值赋值给指针变量指向的存储单元；
        4：赋值：指针变量的值可以赋值给另一个指针变量(1：赋值双方必须都是指针变量2：两个指针变量必须是相同的数据类型)
        5：加减运算：指针变量允许加上或者减去一个整数；
        6：自增/自减运算：指针变量允许进行自增自减运算；
        对指针变量加减整数/自增自减运算的说明：
            1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起所操作数据在内存中地址的改变；
            2：指针变量加减某个整数m:
                微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                宏观上看：指针变量的加减运算改变的是当前指针指向存储单元的地址；
            3：不允许对指针变量做除过加减/自增自减以外的任何其他算数运算；
            4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
            5：对于数组或者字符串，指针变量的加减/自增自减改变的是指针指向的元素位置，是有意义的；
    7：空指针：NULL：
        1：一个指针变量可以指向任意一块内存区域，无论该内存区域有没有被分配，也不管该内存有没有使用权限，只要给定地址，指针变量就能指向该块内存；
        2：如果指针变量未被初始化，则指针变量指向的存储单元是不确定的，因此对没有初始化的指针赋值为NULL;
        3：计算机系统在低地址的内存空间不存储任何数据，也不能被用户程序访问；
        4：NULL本质上是一个宏，((void *)0);void *表示的是一个实际有效的指针，指向的也是实际的内存空间，但是该快内存空间存储什么类型的值，并不确定；
    8：二级指针：
        1：指针本质上就是一个普通的变量，只是其中所存储的值代表的是某个存储单元的地址；而值本身则是一个十六进制的整数；指针变量本身存储的那个十六进制的整数也是需要占用内存空间的；
        2：指向存储某个指针值的存储单元地址的变量称为二级指针；即二级指针任然是个普通变量，存储十六进制的整数，该整数代表的是另一个指针值的地址；
        3：二级指针需要使用**来声明，同理，三级指针需要使用***来声明；
        4：可以理解指针变量就是普通的变量，仅仅是其所存储的值具备不同的含义，但是编写代码要遵守c语言语法规范；
        5：二级指针取值时需要两个*来取值，三级指针需要三个*来取值，以此类推！

    9：指针与函数：
        1：指针作为函数的参数：
            1：c语言中实参到形参的传递是单向的；即：形参在对应函数中做了修改以后并不会影响实参变量的值；
            2：如果函数中需要改变外部变量的值则必须传递外部变量的内存地址；
            3：对于数组和结构体等数据集合类型的数据建议不要直接传递数据集合本身，而是传递指针；
        2：指针作为函数的返回值：
            1：如果函数将指针作为返回值，则称该函数是指针函数；
            2：指针函数的声明：返回值类型 *函数名(形参){code...}
            3：函数执行完毕之后将会销毁在函数内部声明的所有变量；因此不要将返回指针指向函数内部声明的变量以及形参；
            4：注意函数执行完毕之后会对函数内部所声明的所有变量以及形参销毁，但是销毁并非是直接清空掉函数运行期间申请的内存空间；而是弃之不用，即函数执行完毕之后，其执行期间所申请的内存空间现在可以被写入任意内容；
        3：使用指针调用函数：
            1：函数在内存中占用的也是一段连续的内存区域，一般以函数名作为这段内存区域的首地址；
            2：可以将函数名称声明为指针变量即可使用指针来调用函数；
            3：声明方式：返回值类型/void (*函数名)(形参列表){
                ...函数体
            }
            4：*函数名必须要带(),否则就成为了普通的函数声明，只是返回值是指针而已；
    10：指针与数组：
        1：数组：
            数据的集合称为数组，数组中的每一个值称为数组元素，数组中值的个数称为数组的长度！
            数组长度的计算： length = sizeof(数组名)/sizeof(数组元素数据类型)；
        2：数组的声明：
            数组的使用同样需要先声明后使用；
            数组声明的方式：数据类型 数组名[数组长度]；
            数组的声明包括需要声明数组中所要存储的数据元素的类型，数组名以及数组的长度；
            数组声明完成之后，系统将会为数组分配内存空间，但是并不会对数组进行初始化，因此数组声明完成之后如果未进行赋值，数组元素的值是不确定的；
        3：数组的赋值：
            1：数组可以在声明的同时进行赋值；此时有两种赋值方式：
                1：完全赋值：即按照所声明的数组长度，填入相同个数的值；
                                如：int arr[3] = {1,2,3}
                            备注：完全赋值时数组可以不用显式指定长度；
                                如：int arr[] = {1,2,3}
                2：不完全赋值：赋值的个数少于数组声明时指定的个数；
                                如：int arr[3] = {1}
                            备注：不完全赋值时，数组未赋值的部分也会按照基本规则进行初始化：
                                1：如果数组类型为：int,short,long,将直接赋值为整数0；
                                2：如果数组类型为：char,将赋值为\0；
                                3：如果数组类型为：float或者double，则将会赋值为0.0；
            2：数组可以在声明完成之后赋值：
                数组在声明完成之后赋值将只能通过下标一个一个赋值，不能再使用{}进行赋值；
        4：数组使用的注意事项：
            1：数组在赋值时只能赋值指定数据类型的值，不能赋值其他数据类型的值；
            2：数组中元素的长度不能超过数组声明时指定的长度；
            3：c语言中的数组是静态数组，即长度一旦固定将不能改变，不能随意插入数据，也不能随意删除数据；
            4：固定长度的数组是在编译期间分配内存的；
        5：二维数组：
            二维数组的声明：
                数据类型  数组名[一维长度][二维长度];
            二维数组的本质：
                二维数组本质上类似于一个矩阵：一维长度指的是矩阵的行数；
                                            二维长度指的是矩阵的列数；
            二维数组的理解：
                二维数组可以理解为一维数组，只不过每一个元素的值又指向一个数组
            二维数组的赋值：
                1：分段赋值：
                    1：完全赋值：每一行都完全赋值；
                    2：部分赋值：默认从左向右赋值，其余则按照数据类型填充；
                2：连续赋值：
                    1：完全赋值：从左向右按行赋值；此时可不必给出一维长度；
                    2：部分赋值：从左向右按行赋值；其余则按照数据类型填充；
        6：数组的基本操作：
            取值：数组名[下标]
            赋值：数组名[下标] = 值
        7：数组与指针关系：
            1：数组一旦声明好之后将占用的是一段连续的内存区域；占用存储单元的个数是数组的长度*数组元素类型在当前平台所占字节个数；数组的每一个元素均按顺序存储在这快内存区域；
            2：数组指针：
                指向数组中某个元素的指针称之为数组指针，数组指针和普通的指针并无区别，仅仅只是该指针变量指向的存储单元是存储某个数组的元素的；
            3：数组指针的特征：
                1：数组指针指向数组中某个元素的地址，也仅仅只能够代表其所指向的数组元素，并不能代表整个数组；
                2：由于数组占用一段连续的内存空间，因此数组指针加减某个整数可以指向数组中的其他数组元素；
            4：数组名和数组指针：
                1：数组名在C中既可看做数组的首地址，也可看做整个数组；
                2：在c中除过&运算符，sizeof运算符，数组声明中表示整个数组，除过上述三种情况以外，数组名均只表示数组的首地址；
                3：当数组名代表数组首地址时，其和指向数组第一个元素的数组指针等价；当其代表的是整个数组时则和数组指针不同！
            5：数组元素的访问既可以使用数组名通过下标的方式访问，也可以通过指针来进行访问；
            6：如果函数要求传入数组类型的数据，此时如果传入数组名则仅仅代表的是数组的首地址，并不能代表整个数组，根据传入的数组名也无法使用sizeof来计算数组的长度，数组长度需要单独传入；
        8：指针与二维数组：
            1：二维数组在声明时有行和列，在形式上是二维的，但是在实际存储中是按照一维线性存储的，占用的也是一串连续的内存空间；
            2：由与二维数组在语法上是看做二维处理的，因此二维数组的名称同样指的是数组的首地址；
            3：不同的声明方式：
                int *(p1[5]); //指针数组，等价于int *p1[5]/int * p1[5];声明的是一个一维数组，数组的每一项都是一个指针；
                int (*p1)[5]; //二维数组指针；不能去掉括号，等价于二维数组名；此时p1是一个指针，指向一个数组，数组长度为5，类型为int;
        9：指针数组：和普通数组相同，仅仅只是数组中的数组元素是指针而已；
    11：字符串：
        1：c中并没有专门存储字符串的数据类型，字符串使用字符数组来存储；
        2：c中可以通过""直接声明字符串；
        3：由于字符串本质上是字符数组，因此字符串的名称就类似与字符数组的名称，代表字符串的首地址，字符串的结尾位置则是通过\0来确定的；
        4：只有在""包裹的字符串后面才会添加\0；而单个字符组成的字符数组则不会添加\0；
        5：字符串长度：如果是字符数组组成，则字符串长度为字符数组元素个数；如果是由""包裹的字符串组成，则长度等于""包裹的字符个数+1；
        6：字符串如果是通过""来声明：
            长度推荐采用strlen()来获取，strlen获取的是字符串本身的长度，并不包括\0；sizeof()则会将结束符也计算在内；
           如果使用通过字符数组来声明：
            则strlen获取的是实际字符的个数，而非数组的声明长度；sizeof则获取的是声明的长度；
        7：字符和单字符串是不同的：'x'和"x"是不一样的；
        8：string.h头文件包含了针对字符串的所有操作；
        9：字符串的声明以及初始化方式：
            char str[] = {'a','b','c','d','e'};  //sizeof值为5
            char str2[] = "abcde";               //sizeof值为6
            char str3[] = {"abcde"}              //sizeof值为6
            char *str4 = "abcde"                 
            char *str5 = {"abcde"}
            备注：
                1：以char str[n]类似这种数组声明的方式：
                    1：无论是否初始化，无论以何种方式初始化，系统在声明时均会当成字符数组处理，为其分配内存空间；
                    2：其存储位置是在全局数据区或者栈区，具备读写权限；
                    3：以数组的方式声明时既可以通过数组的方式初始化也可以通过""的方式初始化；
                2：对于char *str类似这种字符指针的声明方式：
                    1：在未被初始化时，只能确定该变量是字符指针变量，无法确定该指针的指向；初始化完成之后，该字符指针变量便会指向给定的字符串首个字符的地址；即字符串的首地址；
                    2：以指针的形式声明的称之为字符串常量，存储在常量区，只具备读权限，无法更改字符串内容；
        
    12：结构体：
        结构体：结构体仍然是一种数据集合；用于存放一组数据；
        结构体与数组：
            结构体：既可以存放数据类型相同的数据也可以存放数据类型不同的数据；
                   结构体中的数据通过数据名称操作；
            数组：只能存放数据类型相同的数据；
                 数据仅仅包含数据本身；
                 需要通过数据元素在数组中的索引来操作数据；
        结构体的声明：
            struct 结构体名称{
                数据类型名 数据名称1;
                数据类型名 数据名称2;
                数据类型名 数据名称3;
                         .
                         .
                         .
            }
            如：
                struct stu{
                    short age; //年龄
                    int   num; //学号
                    char *name;//姓名
                }
            备注：
                1：stu即为结构体名称，结构体名称必须符合c语言标识符命名规范；
                2：结构体声明中，一行只能声明一个成员，由成员类型，成员名称组成；
                3：结构体中的成员数据类型没有任何限制，只需要是合法的数据类型以及使用typedef声明的数据类型；
                4：结构体本身只是声明了一个数据集合模板，指明了多个数据的组织方式，代表一种数据类型，并不包含任何实际数据值，因此并不占用任何内存空间；
                5：结构体名称类似于自定义了一种数据类型，并非变量，因此不知想任何内存地址；
                6：结构体可以按照顺序嵌套；
        结构体变量：
            1：通过自定义的结构体类型声明的变量称之为结构体变量；
            2：结构体变量的声明方式：
                struct 结构体名 结构体变量名1,结构体变量名2;
                备注：1：struct指明了该变量是一个结构体变量；
                     2：结构体变量名指明该变量所代表的结构体成员组成；
                     3：声明一个结构体变量系统将会为该变量分配一定的内存空间；内存空间可以通过sizeof(结构体名)来获取；
                     4：结构体变量也可以在结构体声明时就创建，只需要将变量名跟在}后面即可，多个变量名以,分割；
        结构体指针：
            结构体指针变量指向结构体变量在内存中的地址；
            声明方式：struct 结构体名 *pointer;
            备注：
                1：数组名除过数组声明，sizeof运算，以及使用取地址符的时候才回当做整个数组，其余时候都会转换为指向第0个元素的指针；
                2：结构体变量名则不会，无论在任何表达式中，结构体变量名都代表的是整个结构体本身！
                3：结构体指针指的是指向结构体变量的指针，并非指向结构体的指针，结构体本身不占内存空间，只是一种数据类型，因此指针指向结构体无从谈起；
                4：结构体指针不同于数组指针，结构体指针也代表的是整个结构体本身；
        结构体数组：
            结构体数组仍然是数组，只是数组中每一个元素的类型都是结构体；
        结构体的操作：
            取值：1：结构体变量名.结构体成员名
                 2：结构体指针名->结构体成员名
                 3：(*结构体指针变量名).结构体成员名
            赋值：1：结构体变量名.结构体成员名 = 值
                 2：结构体指针变量名->结构体成员名 = 值
                 3：(*结构体指针变量名).结构体成员名 = 值
        结构体作为函数参数：
            结构体，数组这一类集合数据类型一般作为函数参数时都是传递指针，而非整个数据集合；
            如果传递数据集合牵扯到数据的拷贝，浪费内存空间，且速度较慢；
            如果传递数据集合的指针，则仅仅拷贝一个16进制 int类型的整数；内存开销以及时间开销都会小很多；
        结构体占用内存空间的大小：
            结构体中每一个成员在内存中的存储是连续且有序的存储；
            结构体占用内存大小有可能是每个成员的数据类型在当前平台占用内存大小的总和，也有可能大于该值！
            在编译器的具体实现中，因为内存对齐的原因，各个成员之间可能会存在缝隙；如：
                struct tmp {
                    char name[8];
                    int length;
                };
                该结构体在win32位平台下，sizeof的值是12；
                struct tmp {
                    char name[10];
                    int length;
                };
                该结构体在win32位平台下，sizeof的值是16；多出的两个字节是由于32位平台内存以4字节对齐，前10个字节刚好差两个字节成功成为4的倍数，实现4字节对齐，因此name数组和length之间就存在两个字节的缝隙；
            内存对齐：
                1：计算机内存被分割为1字节大小的多个存储单元，理论上cpu可以访问任意编号的存储单元，
                2：实际上cpu通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据(32位平台的cpu一次可以处理4个字节的数据，64位平台的cpu一次可以处理8个字节的数据)；
                3：每次可以读取的字节个数称之为步长；
                4：将一个数据尽量放在一个步长之内，避免跨步长存储，可以提高数据读取效率，这称为内存对齐；
                5：在32位平台默认以4字节对齐，在64位平台默认以8字节对齐；
                6：c语言编译器为了提高数据的存取效率会自动根据平台进行内存对齐；因此会出现结构体存在存储缝隙的现象；
数据类型定义别名：
    c语言中可以通过typedef oldname newname;来定义新的数据类型；
    1：为基本数据类型定义别名：
        如：typedef int INTEGER;那么INTEGER就代表int类型的数据
    2：为数组类型定义别名：
        如：typedef char arrtype[20];
            arrtype a1,a2;等价于char char a1[20],a2[20];
    3：为结构体定义别名：
        如：typedef struct stu{
            char *name;
            short age;
        } STU;
        STU stu1;等价于struct stu stu1;
c语言中的常量：
    1：在c语言中常量是指值不能被修改的变量称作常量；
    2：c语言中的常量通过const修饰一个变量得到；
    3：const的使用方式：const type var_name = value;
        1：const要求在声明变量时即初始化，否则将无法再赋值；
        2：const来修饰普通变量，则该变量将不能再重新赋值；使用方式：const type var_name = value;
        3：const来修饰指针变量，则有三种情况：
            情况1：const 修饰的是指针符号和变量名，那么指针变量所指向的内存空间中的值不能被修改；指针变量本身可以修改指向不同的内存空间！如：
                const int *pointer;
                int const *pointer;
            情况2：const 修饰的是变量名，不包括指针符号，那么指针变量本身不能修改，即指针变量不能再被修改指向其他内存空间：
                int * const pointer;
            情况3：const 既修饰指针又修饰变量，则指针变量本身不能再被修改，即指针变量不能再被修改为指向其他内存空间，且指针变量指向的内存空间中的值也不能再改变！
                int const * const pointer
        4：一般在函数的形式参数处，如果函数需要保证某个参数不会被函数内部修改，就可以使用const修饰；
c语言预处理：
    预处理概述：
        1：预处理是指在编译之前对源文件进行的一些处理；处理完成之后仍然是c代码文件；
        2：预处理是指以#开头的命令，预处理命令要放在所有的函数外面，而且一般放在源文件的最前面；
        3：编译器会将预处理的结果保存到和源文件同名的.i文件中
        4：获取预处理文件：gcc -E ./test.c -o test.i
        5：预处理包括：宏定义，文件包含，条件编译；
    预处理--文件包含：
        1：文件包含使用：#include命令；
        2：处理过程为：将包含的头文件的语句直接替换成所包含的头文件的内容；
        3：使用方式：
            #include <stdio.h>
            #include "myheader.h"
            备注：<>这种包含语法用来包含c库；""用来包含自定义头文件；
        4：文件包含允许嵌套；
    预处理--宏定义：
        宏定义：#define 宏名称 宏值
        1：宏定义不是语句，不是表达式，因此无需使用;作为结束符！
        2：宏定义必须写在函数外面，其作用域为宏定义命令到源程序结束！
        3：如果需要提前结束宏的作用域，则可以使用#undef 宏名；
        4：宏在使用时本质上只是字符串替换；
        5：宏定义允许嵌套；
        6：宏名称必须遵守c语言标识符命名规范，并且推荐以大写加_的方式命名；
        7：宏可以有参数：
            声明方式：#define 宏名(形参列表) 字符串(字符串中可以包含各个形参)
            调用方式：宏名(实参列表);
            注意事项：
                1：带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现；
                2：在带参宏定义中，不会为形参分配内存，因此不必指明数据类型；无论何值，都将转换为字符串直接替换；
                3：宏永远只是字符替换而已，即便是表达式也只是表达式字符的替换；
        8：#和##：
            #会在参数的两端添加双引号，将宏参数转换为字符串；
            ##可以将多个参数连接起来；
        9：c语言中常见的宏：
            __LINE__:表示当前的源代码行号；
            __FILE__:表示当前源文件的名称；
            __DATE__:表示当前编译日期；
            __TIME__:表示当前编译时间；
    预处理--条件编译：
        条件编译是指在编译阶段对宏进行判断，编译不同的代码：
            宏判断语法：
                a：语法：
                    #if 整型常量表达式1
                        程序段1
                    #elif 整型常量表达式2
                        程序段2
                    #else
                        程序段4
                    #endif
                注意：#if后面是整型常量表达式，即表达式的结果必须是整数；
            b语法：
                #ifdef 宏名a
                    程序段1
                #else
                   程序段2
                #endif

                #ifndef 宏名
                    程序段1
                #else
                    程序段2
                #endif
                  
c文件操作：
    linux系统文件概念：
        1：linux上面为了统一对硬件设备的操作，将硬件映射成为文件，因此在linux上面一切皆文件！
        2：linux上面的文件大体分为两部分，二进制文件和文本文件；
        3：二进制文件和文本文件的区别：
            1：二进制文件和文本文件在物理上均以二进制方式存储；
            2：二进制文件和文本文件组织形式不一样；二进制文件有文件头，用来表名文件的基本信息；文本文件没有文件头，第一个字节就是文本的内容；
            3：文本文件是基于字符编码的，常见的编码形式有ASCII,UNICODE,UTF-8等；二进制是自定义编码的；
            4：二进制文件在读取时会直接读取二进制文件的所有内容，写入时原封不动将内存缓冲区中的内容原封不动的写到文件中；文本文件以CRLF作为换行符，而C语言文本以LF作为换行符，所以文本写入数据时，会将LF转换为替换为CRLF，读取数据时再替换回来；文本文件打开时遇到结束符CTRLZ就认为文件已经结束；
    c语言文件内容操作：
        1：打开文件：
            1：打开文件是指获取文件的基本信息，并存储在FILE类型的结构体中；(FILE结构体是在stdio.h中定义的一个结构体)
            2：操作：FILE *fp = fopen(char *filename,char *mode);
            3：参数：第一个参数是文件的路径；第二个参数是文件的打开模式；
            4：返回值：返回FILE结构体的指针；如果文件打开出错，将返回一个空指针NULL；
            5：文件打开模式：
                r,r+,rb+,rt+;
                w,w+,wb+,wt+;
                a,a+,ab+,at+;
        2：文件关闭：
            1：清除FILE结构体中关于文件的信息；
            2：操作：int fclose(FILE *fp);
            3：参数：FILE结构体的指针
            4：返回值：正常关闭时返回值是0，其他值表示关闭出错！
        3：文件内容读取：
            1：以字符的方式读取：fgetc();
                1：原型：int fgetc(FILE *fp);
                2：参数：fp:文件指针；
                3：返回值：如果读取成功返回读取到的字符，读取到文件末尾或者读取失败时返回EOF；(EOF是一个负数，具体看编译器的实现)
                4：需要读取文件所有内容需要遍历读取；
                eg:
                    while((int ch = fgetc(fp)) != EOF){
                        putchar(ch);
                    }
                    //遍历读取文件内容
                5：关于EOF：
                    1：在文件读取出错或者文件读取到末尾的时候均返回EOF；
                    2：可以使用feof()和ferror()来检测读取结束时是文件出错还是文件读取到末尾了；
                    3：int feof(FILE *fp);  //如果返回非0值，则表示指向文件末尾，
                    4：int ferror(FILE *fp); //如果返回非0值，则表示出错；
            2：以字符串的方式读取：fgets();
                1：原型：char *fgets(char *str,int n,FILE *fp);
                2：参数：str为要存储读取到的字符数组，n为要读取的字符数目，fp为文件指针；
                3：返回值：读取成功时返回字符数组首地址，也即str,读取失败时返回NULL;返回值会在结尾添加\0,n个字符是包括\0的；
                4：该函数在读取n个字符时如果遇到了换行符或者文件结束符时即读取结束，因此无论n值多大，最多只能读取一行数据；并且fgets可以读取到换行符；
                5：在c语言中没有按行读取的函数，因此可以借助fgets将n值设的足够大即可；
                6：如果需要读取文件所有内容直到结束，则需要遍历读取；
                7：遍历读取结束之后可以通过ferror(fp)和feof(fp)来检测读取结束时是出错还是结束；
            3：通过数据块的方式读取文件：fread();
                1：原型：size_t fread(void *ptr,size_t size,size_t count,FILE *fp);
                2：参数：ptr为内存块的指针，可以是数组，结构体，指定的内存块用于存储读取到的数据；
                        szie每个数据块的字节数；如果使用数组，类型为int，int所占用的字节个数就是每个数据块的字节个数；
                        count表示数据块的个数；如果使用数组，类型为int，那么数组的长度就是数据块的个数；
                        fp表示文件指针；
                        理论上每次最多读取size*count个字节的数据，存储读取到的数据的内存块的大小至少是size*count;如果实际读取到的数据超过size*count的话，则会占用紧跟着申请到的内存后面；
                3：size_t 是在stddef.h头文件中使用typedef定义的数据类型，表示无符号整数，也即非负数；常用来表示数量
                4：返回值：读取成功返回读取成功的块数，即count数；如果返回值小于count，对于fread来说可能读到了文件末尾，也可能发生了错误；

            
            

            


                
            
            
            






        


