mysql中的事务与锁：
    1：事务：一组原子性的sql查询组成的一个独立的工作单元称为一个事务！；
    2：事务需要满足的特征：事务是由一个或者多个原子性sql组成的工作单元，要求这个工作单元中的所有sql要么全部执行成功，要么全部执行失败；
    3：mysql的事务功能是在存储引擎中实现的，并非在服务器层实现；要尽量避免再事务中使用不同的存储引擎；
    4：在mysql常用的存储引擎(MyISAM和InnoDB)中，只有InnoDB支持事务，MyISAM并不支持事务！
InnoDB中的事务：
    1：事务所需要满足的基本特征：
        1：A：原子性：一个事务必须被视为一个独立的不可再分割的最小的执行单元，整个事务中的所有操作要么全部成功，要么全部失败；

        2：C：一致性：即执行事务之前或者执行事务之后，都不能影响数据在逻辑上的合理性；

        3：I：隔离性：隔离性指的是数据在事务与事务之间的透明程度；

        4：D：持久性：事务一旦提交，数据的修改就会永久被保存到数据库中，此时即便系统崩溃，事务所提交的修改也不能被影响！

    2：事务的隔离级别：
        2.1：sql标准中定义了四种隔离级别：未提交读，提交读，可重复读，序列化

        2.2：隔离级别1：未提交读(READ UNCOMMITTED)
            该隔离级别最低，数据在事务之间的透明程度最高，但是性能未必最好！

            对于该隔离级别而言：事务A如果对数据做了修改，即便没有提交，另一个事务B也能看到被修改之后的数据；这种现象称作脏读现象！
        
        2.3：隔离级别2：提交读(READ COMMITTED)
            该隔离级别可以满足隔离的基本定义：其他事务无法感知另一个未提交的事务对数据做出的修改！

            对于该隔离级别而言：事务A修改了数据，在未提交的状态下，另一个事务B看到该数据仍然是事务A开始之前的原始数据；该隔离级别解决了脏读现象！

            但是在该隔离级别下仍然有其他问题：不可重复读！

            不可重复读：如果一个事务A对数据做了修改并提交之后，对于另一个执行时间较长的事务B如果在此时重新读取改数据将会得到和事务A提交之前不一样的数据；这种现象称作不可重复读！
        2.4：隔离级别3：可重复读(REPEATABLE READ)
            该隔离级别是mysql(InnoDB)默认的隔离级别;

            在该隔离级别下解决了脏读，不可重复读的问题；

            但是在该隔离级别下对于多行数据而言，则会出现幻读现象；

            幻读现象：如果一个事务修改满足某个条件的多行数据，另一个事务同时添加一行满足某个条件的数据；name当前一个事务再次读物某个条件下的数据时会发现有数据没有被修改！这种现象称为幻读！

        2.5：隔离级别4：可串行化(SERIALIZABLE):
            该隔离级别要求多个事务串行执行：即一个事务执行完成之后，另一个事务再开始执行；

            由于完全的串行话，即保证了不可能有多个事务同时执行，每一个事务看到的数据都是最终的数据；但是也不存在并发现象！

            该隔离级别解决了脏读，不可重复读，幻读现象！
        备注：InnoDB中通过多版本并发控制解决了不可重复读的问题，加上间隙锁解决幻读问题！

        2.6：事务中的隔离级别均是由锁机制来实现的！
            2.6.1：锁的作用：
                如果同一时刻对某个数据有多个不同的操作，将会造成并发问题；

                mysql在服务器层面和存储引擎层面处理并发问题；处理的方式便是加锁；

            2.6.2：锁类型：
                1：共享锁(读锁)：
                    当前连接：可读，不可写（不可插入新数据，不可更新数据，不可删除数据）
		            其他连接：可读，不可写（不可插入新数据，不可更新数据，不可删除数据）
                2：排它锁(写锁)：
                    当前连接：可读，可写（可插入新数据，可更新数据，可删除数据）
                    其他连接：不可读，不可写（不可插入新数据，不可更新数据，不可删除数据）
            2.6.3：锁粒度的大小：
                锁粒度指的是锁定数据的多少；
                锁粒度越大将会锁定的面积更大=>影响更多数据的读写，对于并发性能不好
	            锁粒度越小锁定的面积将会越小=>受影响的数据面小，对于并发性能比较好
                mysql中的锁包括表锁和行锁；
                表锁在服务器层面实现，行锁在存储引擎层面实现；
            
            2.6.4：加锁：
                InnoDB采用的是两阶段锁定协议；
                    1：
                        所有的读操作默认不加锁；
                        所有的写操作默认加写锁(排它锁)；
                        上述两种加锁方式成为隐式加锁。
                    2：
                        除此之外，也可以在sql语句中加锁：
                        SELECT ... LOCK IN SHARE MODE;(共享锁)
                        SELECT ... FOR UPDATE;(排它锁)
                        这种加锁方式成为显式加锁
            2.6.5：死锁：
                死锁是指两个或者多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象；
                一般来说：当多个事务视图以不同顺序锁定资源时，大概率会产生死锁！
                如： START TRANSACTION
                    UPDATE tablea SET age=12 WHERE id = 4;
                    UPDATE tablea SET age=12 WHERE id = 3;
                    COMMIT

                    START TRANSACTION
                    UPDATE tablea SET age=12 WHERE id = 3;
                    UPDATE tablea SET age=12 WHERE id = 4;
                    COMMIT
                innodb处理死锁的方式：将持有行级排它锁最少的事务进行回滚；
    3：事务日志：事务的隔离性是由锁来实现，其余特性则是由事务日志来实现；
        3.1：事务日志记录的是mysql的事务操作记录；mysql通过事务日志来实现ACD特性；
        3.2：事务日志包括：
            redo日志：
                redo日志包括两个部分：一是内存中的日志缓冲；而是磁盘上的重做值文件；
                
            undo日志：回滚日志，记录的是一部分完成并且写入硬盘的未完成的事务
        3.2：mysql修改数据的流程：
                1：mysql对于需要修改的数据会先将数据加载至内存，然后修改内存中的数据；
                2：
                脏页：mysql对于需要修改的数据会先将数据加载至内存，然后修改内存中的数据;(修改完成之后内存中的数据将和磁盘中的数据不一致，内存中的数据被称为脏页)；


        3.1：事务日志的作用：
            如果使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中；而不用每次都将修改的数据本身持久到磁盘中；可以提升事务的执行效率！

        3.2：事务日志的记录方式：
            事务日志采用的是追加的方式，因此，写日志是在一小块内存区域的顺序io，而不是向随机io需要在磁盘的多个地方移动磁头，因此效率较高；
        3.3：如果在事务日志记录完成之后，系统崩溃，当系统重启之后事务日志的操作记录将会被重新吧日志中的修改刷回磁盘！
    4：mysql的事务启用：
        mysql默认是每一个查询操作都会当做事务执行提交操作；因此如果需要显示的执行事务则需要通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式；

           
                





        
    