mysql中的事务与锁：
    1：事务：一组原子性的sql查询组成的一个独立的工作单元称为一个事务！；
    2：事务需要满足的特征：事务是由一个或者多个原子性sql组成的工作单元，要求这个工作单元中的所有sql要么全部执行成功，要么全部执行失败；
    3：mysql的事务功能是在存储引擎中实现的，并非在服务器层实现；要尽量避免再事务中使用不同的存储引擎；
    4：在mysql常用的存储引擎(MyISAM和InnoDB)中，只有InnoDB支持事务，MyISAM并不支持事务！
InnoDB中的事务：
    1：事务所需要满足的基本特征：
        1：A：原子性：一个事务必须被视为一个独立的不可再分割的最小的执行单元，整个事务中的所有操作要么全部成功，要么全部失败；

        2：C：一致性：即执行事务之前或者执行事务之后，都不能影响数据在逻辑上的合理性；

        3：I：隔离性：隔离性指的是数据在事务与事务之间的透明程度；

        4：D：持久性：事务一旦提交，数据的修改就会永久被保存到数据库中，此时即便系统崩溃，事务所提交的修改也不能被影响！

    2：事务的隔离级别：
        2.1：sql标准中定义了四种隔离级别：未提交读，提交读，可重复读，序列化

        2.2：隔离级别1：未提交读(READ UNCOMMITTED)
            该隔离级别最低，数据在事务之间的透明程度最高，但是性能未必最好！

            对于该隔离级别而言：事务A如果对数据做了修改，即便没有提交，另一个事务B也能看到被修改之后的数据；这种现象称作脏读现象！
        
        2.3：隔离级别2：提交读(READ COMMITTED)
            该隔离级别可以满足隔离的基本定义：其他事务无法感知另一个未提交的事务对数据做出的修改！

            对于该隔离级别而言：事务A修改了数据，在未提交的状态下，另一个事务B看到该数据仍然是事务A开始之前的原始数据；该隔离级别解决了脏读现象！

            但是在该隔离级别下仍然有其他问题：不可重复读！

            不可重复读：如果一个事务A对数据做了修改并提交之后，对于另一个执行时间较长的事务B如果在此时重新读取改数据将会得到和事务A提交之前不一样的数据；这种现象称作不可重复读！
        2.4：隔离级别3：可重复读(REPEATABLE READ)
            该隔离级别是mysql(InnoDB)默认的隔离级别;

            在该隔离级别下解决了脏读，不可重复读的问题；

            但是在该隔离级别下对于多行数据而言，则会出现幻读现象；

            幻读现象：如果一个事务修改满足某个条件的多行数据，另一个事务同时添加一行满足某个条件的数据；name当前一个事务再次读物某个条件下的数据时会发现有数据没有被修改！这种现象称为幻读！

        2.5：隔离级别4：可串行化(SERIALIZABLE):
            该隔离级别要求多个事务串行执行：即一个事务执行完成之后，另一个事务再开始执行；

            由于完全的串行话，即保证了不可能有多个事务同时执行，每一个事务看到的数据都是最终的数据；但是也不存在并发现象！

            该隔离级别解决了脏读，不可重复读，幻读现象！
        备注：InnoDB中通过多版本并发控制解决了不可重复读的问题，加上间隙锁解决幻读问题！

        2.6：事务中的隔离级别均是由锁机制来实现的！
            2.6.1：锁的作用：
                如果同一时刻对某个数据有多个不同的操作，将会造成并发问题；

                mysql在服务器层面和存储引擎层面处理并发问题；处理的方式便是加锁；

            2.6.2：锁类型：
                1：共享锁(读锁)：
                    当前连接：可读，不可写（不可插入新数据，不可更新数据，不可删除数据）
		            其他连接：可读，不可写（不可插入新数据，不可更新数据，不可删除数据）
                2：排它锁(写锁)：
                    当前连接：可读，可写（可插入新数据，可更新数据，可删除数据）
                    其他连接：不可读，不可写（不可插入新数据，不可更新数据，不可删除数据）
            2.6.3：锁粒度的大小：
                锁粒度指的是锁定数据的多少；
                锁粒度越大将会锁定的面积更大=>影响更多数据的读写，对于并发性能不好
	            锁粒度越小锁定的面积将会越小=>受影响的数据面小，对于并发性能比较好
                mysql中的锁包括表锁和行锁；
                表锁在服务器层面实现，行锁在存储引擎层面实现；
            
            2.6.4：加锁：
                InnoDB采用的是两阶段锁定协议；
                    1：
                        所有的读操作默认不加锁；
                        所有的写操作默认加写锁(排它锁)；
                        上述两种加锁方式成为隐式加锁。
                    2：
                        除此之外，也可以在sql语句中加锁：
                        SELECT ... LOCK IN SHARE MODE;(共享锁)
                        SELECT ... FOR UPDATE;(排它锁)
                        这种加锁方式成为显式加锁
            2.6.5：死锁：
                死锁是指两个或者多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象；
                一般来说：当多个事务视图以不同顺序锁定资源时，大概率会产生死锁！
                如： START TRANSACTION
                    UPDATE tablea SET age=12 WHERE id = 4;
                    UPDATE tablea SET age=12 WHERE id = 3;
                    COMMIT

                    START TRANSACTION
                    UPDATE tablea SET age=12 WHERE id = 3;
                    UPDATE tablea SET age=12 WHERE id = 4;
                    COMMIT
                innodb处理死锁的方式：将持有行级排它锁最少的事务进行回滚；
            2.6.6：InnoDB中的间隙锁：
                1：在使用范围条件而非相等条件检索数据的时候，innodb不但会为符合条件而且存在的数据行加锁，也会为符合条件但数据不存在的行加锁；为数据不存在但符合条件的数据加的锁称为间隙锁；

                2：间隙的锁定区域：间隙锁的锁定左边界是根据where条件从左查找最靠近条件的记录作为左边界；
                                 间隙锁的锁定右边界是根据where条件从右查找最靠近条件的记录作为右边界；
                                 两个边界即为间隙锁的锁定范围！

                3：间隙锁的主要作用就是为了防止幻读；本质上就是排它锁，但是该锁在防止幻读的优势下会引发满足符合条件的新数据无法插入；造成严重的锁等待；
                （优化：在并发插入比较多的情况下，尽量使用相等的条件来筛选数据，避免使用范围条件，而造成大批量的数据无法插入）

                4：使用相等条件给一个不存在的数据行加锁，该数据行同样也会被加上间隙锁；

                5：间隙锁主要通过两哥方面来实现这个目的：1：防止间隙内有新数据被插入，2：防止已存在的数据更新称为间隙内的数据！
                6：间隙锁的使用条件：
                    1：隔离级别必须是在可重复度级别下
                    2：检索条件必须有索引
    3：事务日志：事务的隔离性是由锁来实现，其余特性则是由事务日志来实现；
        3.1：事务日志记录的是mysql的事务操作记录；mysql通过事务日志来实现ACD特性；
        3.2：事务日志包括：
            redo日志：
                redo日志的组成：
                    redo日志包括两个部分：一是内存中的日志缓冲log buffer；而是磁盘上的重做文件log file；
                redo日志记录流程：
                    1：事务在提交之前，都会先将事务操作记录写入log buffer;
                    2：然后在commit的时候系统会根据服务器所配置的策略来将log buffer中的日志信息写入log file;
                redo日志刷入磁盘数据的策略：
                    由于log buffer到log file中间还需要经过一层os buffer;因此mysql提供了三种方式来将log buffer中的数据刷入磁盘的log file;

                    策略1：配置为0：当设置为0时，事务commit时并不会将log buffer中的日志写入到os buffer;而是每秒写入一次os buffer,然后再将os buffer中的数据刷入磁盘；当系统崩溃的时候将会损失一秒的数据；
                    策略2：配置为1：这也是mysql的默认配置，事务每次提交都会将log buffer中的日志写入os buffer,同时将os buffer中的数据刷入磁盘；

                    策略3：配置为2：每次提交都是仅将log buffer中的数据写入os buffer;之后每隔一秒，将os buffer中的日志写入到log file中！
                相关控制参数：
                    innodb_flush_log_at_trx_commit的值决定的是log buffer将数据刷新至log file的策略！
                    一般来说，将策略设置为0和2时，差距并不大，但是1则和其余两个差距较大；
                
                日志块：
                    innodb引擎中，redo log都是以块为单位进行存储，每一个块占据大小为512字节；无论是log buffer还是os buffer还是log file都是512字节；

                    每一个日志块都是三部分组成：日志块头，日志块尾，日志主体；日志块头占据12个字节，日志块尾占据8个字节，日志主体占用492个字节；如果日志主体超过492个字节时，将会使用更多的块来存储；

                    日志头：
                        log_block_hdr_no：(4字节)该日志块在redo log buffer中的位置ID。
                        log_block_hdr_data_len：(2字节)该log block中已记录的log大小。写满该log block时为0x200，表示512字节。
                        log_block_first_rec_group：(2字节)该log block中第一个log的开始偏移位置。
                        lock_block_checkpoint_no：(4字节)写入检查点信息的位置。
                    日志尾：log_block_trl_no 和日志头的log_block_trl_no相同；

                查看日志设置信息：show global variables like "innodb_log%";

                ...未完

            undo日志：回滚日志，记录的是一部分完成并且写入硬盘的未完成的事务
        3.2：mysql修改数据的流程：
                1：mysql对于需要修改的数据会先将数据加载至内存，然后修改内存中的数据；
                2：
                脏页：mysql对于需要修改的数据会先将数据加载至内存，然后修改内存中的数据;(修改完成之后内存中的数据将和磁盘中的数据不一致，内存中的数据被称为脏页)；


        3.1：事务日志的作用：
            如果使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中；而不用每次都将修改的数据本身持久到磁盘中；可以提升事务的执行效率！

        3.2：事务日志的记录方式：
            事务日志采用的是追加的方式，因此，写日志是在一小块内存区域的顺序io，而不是向随机io需要在磁盘的多个地方移动磁头，因此效率较高；
        3.3：如果在事务日志记录完成之后，系统崩溃，当系统重启之后事务日志的操作记录将会被重新吧日志中的修改刷回磁盘！
    4：mysql的事务启用：
        mysql默认是每一个查询操作都会当做事务执行提交操作；因此如果需要显示的执行事务则需要通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式；
    

           
                





        
    