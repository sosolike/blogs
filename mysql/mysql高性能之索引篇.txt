1：概述-----索引
	1：索引是存储引擎快速找到记录的一种数据结构，这是索引的基本功能；
		（a：这中种据结构记录了某个数据列和具体数据行物理位置的一种映射关系）
		（b：索引的功能均一样--增加数据查询速度；其余如唯一索引，主键索引等均是在数据列上保证索功能的基础上添加了额外的限制）
		（c：索引存储在磁盘上，按需加载至内存中）
	2：在mysql中索引是在存储引擎层实现的，而非服务器层；因此不同存储引擎的索引的工作方式并不一样；不同存储引擎也未必支持所有类型的索引；即使多个存储引擎支持同一种类型的索引，其底层实现也有可能不同；

	3：如果表足够大，索引本身也将比较大，不可能全部存放在内存里面，因此索引往往以索引文件的形式存储在磁盘上；在查询数据时按需加载索引数据至内存中；因此要选择一个减少查找过程中磁盘的I/O的存取次数的数据结构作为索引的存储方式；

2：常见的索引类型：

	1：B-Tree索引及其变种（B+Tree）
		1.1：B-Tree索引是指索引与具体数据行物理位置的映射是通过B-Tree这种数据结构来存储的；
		1.2：不同的存储引擎按照不同的方式来使用B-Tree索引：
			a：MyIsam使用前缀压缩的技术保证索引更小（可以在内存中加载更多的索引，索引的处理速度也会更快）
			b：MyIsam中存储的是索引行的数据和具体物理位置之间的映射；

			c：innodb按照元数据格式进行存储（可以使用索引来增加排序性能）
			d：innodb中存储的是索引行的数据和主键之间的映射，而主键则存储的是具体数据和行位置指针的映射；
		1.3：B-Tree索引意味着所有的列数据都是按顺序存储的（即意味着比较适合查找范围数据）；而且存储引擎不再需要进行全表扫描，只需从索引的根节点开始进行搜索，根节点的槽中放置了指向子节点的指针，存储引擎根据指针向下层查找；


	2：hash索引
		1：哈希索引是基于哈希表实现的；只能实现精确匹配；
		2：实现原理：哈希索引会将索引列中的数据计算出一个哈希码，索引中保存的是该哈希码和数据行物理位置之间的一个映射；因此必须计算出正确的哈希码才能找到数据的物理行位置；
		3：mysql中只有Memory引擎显示支持哈希索引；
		4：哈希索引的一些特征：
			1：只能实现精确匹配
			2：无法用于提升排序性能
			3：不支持部分索引列的查找；如建立索引key(a,b)，是无法使用a来查找数据的；
			4：哈希索引只支持等值比较查询，不支持任何范围查询；
3：索引的优势：
	1：大大减少服务器需要扫描的数据量
	2：帮助服务器免排序和临时表；
	3：可以将随机I/O变为顺序I/O；

	4：添加索引的一些注意事项：
		1：不能给每一行都添加索引；
		2：不能不使用索引（innodb强制使用主键索引）
		3：不能出现重复索引；
		4：尽量避免冗余索引；
		5：根据业务归纳where条件，order by,group by，条件来建立对应的索引；

4：高性能索引优化策略：
	1：尽量避免索引失效，如果在where条件中对索引使用运算表达式或者隐式数据类型转换，将会导致索引失效；
	   因此需要对索引列的数据做运算处理的尽量在业务层面完成，在写sql的时候注意数据类型；

	2：剪短索引列的数据长度：
		a：能使用整数尽量使用整数而非字符串；字符串的处理速度不如整数；
		b：使用前缀索引：如果索引列的数据比较长，将会让索引变的大且慢；此时可以使用前缀索引；
			1：所谓前缀索引是指：只选取数据具有代表性的前面几个字符作为索引即可，而非在索引中存储完整的数据；
			2：如何确定前缀索引：
				1：不能太短，否则选择性不够高，索引性能会变差；
				2：也不能太长，否则前缀将失去意义；索引存储的数据过长，处理速度会变慢，索引空间占用较大；
			3：确定具有合适选择性的前缀：
				1：找到最常见的值的列表；select count(*)....
				2：找到最频繁出现的城市前缀：select count(*),left(字段，n):先从n个前缀字母开始；
				3：如果每个前缀比原来的值出现的次数更多，将意味着该前缀的选择性太差；可以增加前缀长度再测试；直到这个前缀的选择性接近元数据的选择性，长短也合适即可；
			4：前缀索引的优缺点：
				1：优点：减少索引中存储的数据长度；减少索引占用的空间；提高索引处理速度；

				2：缺点：因为索引中存储的并非是完整的索引列数据，因此无法使用前缀索引来提升排序和分组性能
			5：创建前缀索引：
				alert table table_name add key (字段(n))
				字段指的是要建立前缀索引的列；n指的是上述方式（3）确定的前缀的长度；
			6：确定选择性高低的方式：
				select sum(staff_id = 2),sum(customer_id = 584) from payment;
				哪个字段的值最低，哪个字段的选择性就最高；

				select count(DISTINCT staff_id)/count(*),count(distinct customer_id)/count(*) from payment;
				哪个字段值最高，哪个字段的选择性就最高；
	3：使用多列索引：
		1：固定多条件查找：如果按照某个固定的组合条件查询较多也可建立该多个条件组成的多列索引；而非为每一个数据列单独建立一个索引；这两种方式多列索引的性能更好；

		2：对于innodb引擎，多列索引的存储方式是按照设置多列索引时的顺序进行存储的；
			如key(uid,uname,uage);则索引列在排序的时候先按照uid排序，uid一样按照uname排序，以此类推；

		3：多列索引的功能：
			1：按照全值匹配查找：即where条件中的筛选条件使用了多列索引的每一列；
				全键值查找：where last_name = '' and first_name = '' and age = 12;
			2：按照键值范围查找：即除过最左前缀以外其他索引使用范围查找；
				如果某个索引列按范围查找，多列索引中该列以后的列将无法再使用索引；
				键值范围查找：where last_name = '' and first_name = like 'a%';
			3：最左前缀查找：即在where条件中只使用多列索引的第一个索引作为筛选条件；
		4：多列索引的使用限制：
			1：多列索引使用时必须遵守最左前缀原则，即where筛选条件中必须将最左前缀放在第一个筛选条件；
			2：不能跳过多列索引的中间列；否则将无法使用索引列；
			3：如果where条件对多列索引中某个列使用了范围查找，该列右边的索引列在where条件中将无法再使用索引；
			所以在使用多列索引的时候顺序极其重要；
	4：使用覆盖索引
		1：何为覆盖索引：如果要查找的数据所在的列被索引覆盖，那么获取改数据将直接可以从索引中获取，而不用再回表查询；此时获取数据的速度比较快；

		2：所谓列被索引覆盖指的是该列上建立有索引如key(A),key(B,C),等就认为列A,B,C被索引覆盖；

		3：使用覆盖索引的好处：
			1：索引中存储有所需要的字段的数据，因此可以避免回表查询；
			2：索引条目远小于数据行的大小，如果只需要读取索引，那Mysql就会极大减少数据访问量；
			3：索引比数据更小，更易放入到内存；
			4：索引是按照数据顺序存储的，可以将随机io变为顺序io；提高查询性能；
			5：可以改善innodb引擎中的二次查询问题：innodb引擎中二级索引中存储的并非是数据行的物理位置，而是主键，因此通过二级索引查找数据如果不使用覆盖索引，将会导致二次查询，影响性能；
		4：确认覆盖索引：
			如果是覆盖索引的话：explain的值是useing index;

	5:使用聚簇索引
		1：何为聚簇索引：所谓聚簇索引只是一种将数据和索引进行关联的一种存储方式，并非是一种单独的索引；
		2：聚簇索引的数据存储特点：节点页中存储的是聚簇索引的值，而叶子页中存储的是该聚簇索引所在的行的全部数据；
		3：在innodb中，聚簇索引由主键承担；因此，inndb引擎的数据是按照主键顺序存储的；即：innodb引擎中，主键的选择必须唯一，有序；否则将会带来维护数据顺序的成本；
		4：聚簇索引的优缺点：
			优点：
				1：可以把相关数据保存在一起；如：按照用户id来聚簇邮箱数据，这样即可将一个用户的邮件数据聚簇在一起，提高查询效率；
				2：数据访问速度会更快，原因在于聚簇索引将索引和数据保存在同一个B-Tree中，因此聚簇索引中获取数据会跟快；
				3：使用覆盖索引扫描的查询可以直接使用页节点中的主键值；
			缺点：
				1：聚簇数据最大限度提高了I/0密集型应用的性能；如果数据全部放在内存中访问顺序将不再重要；
				2：插入速度严重依赖于插入顺序，因为数据是按照主键顺序存储的，如果不按照顺序插入数据，将要反复维护数据的顺序，进而造成性能问题；
				3：更新聚簇索引列的代价很高，聚簇索引列的更新意味着整个表的数据行全部要更新存储顺序；
				4：局簇索引的表在插入新航或者主键被更新导致需要移动行的时候，肯能面临页分裂的问题；
				5：聚簇索引可能导致全表扫描变慢，尤其是比较稀疏，或者由于页分裂导致数据存储不连续的时候；
				6：二级索引（非聚簇索引）可能变的要更大，因为在二级索引的叶子节点包含了引用行的主键列；
				7：二级索引访问需要两次索引查找，而不是一次；原因在于二级索引保存的并非指向行的物理位置的指针，而是行的主键值；
		5：MyIsam和innodb存储数据的分布方式：
			1;MyISAM存储数据是按照数据的插入顺序在磁盘上存储的；并且每一行都会有一个行号；
				（并非所有的非聚簇索引都能做到一次索引查询就找到行，当行更新的时候可能无法存储在原来的位置，这会导致表中出现行的碎片化或者移动行并在原位置保存目标指针）
			2：innodb由于支持聚簇索引，所以innodb中主键索引中保存了整行的数据以及事务ID和用于事务及MVCC回滚的指针；
		6：聚簇索引的选择（对于mysql来说如果使用innodb即为主键的选择）：
			1：有序
			2：唯一
			3：长度合适，不能太长
			4：尽量连续
			5：不要使用md5值，uuid值为索引；
			如果使用无需的主键会造成一下几个问题：
				1：写入目标可能已经刷到磁盘上并从缓存中移除，或者是还没有被夹在到缓存中，在插入新行之前则不得不先找到并从磁盘读取目标页到内存中，将导致大量I/O；
				2：因为写入是乱序的，因此innodb不得不频繁地做页分裂操作；页分裂会导致移动大量的数据，而且一次插入最少需要去修改三个页而非一个页；
				3：由于频繁的页分裂，页会变得稀疏，并被不规则的填充，最终会有碎片；
			顺序主键的问题：
				对于高并发工作负载，在innodb中按主键顺序插入有肯能会造成明显的争用，即主键的上界会成为热点；并发插入肯能导致间隙锁的竞争；另一个热点可能是auto_increment的锁机制；
	6：使用索引扫描来排序：
		1：mysql生成有序结果有两种:
			1：按照order by排序；
			2：通过索引扫描排序：如果explain出来的type列的值是index这说明mysql使用了索引扫描来排序；
		2：要使用索引扫描来排序需要满足一下几个条件：
				1：order by的排序列必须都是索引列；不能出现其他列；
				2：如果是联合索引，order by的字段顺序必须和多列索引的顺序一致；
				3：order by在使用多列索引的字段排序的时候，必须遵守最左前缀原则，否则无法使用扫描索引
				4：当多列索引的第一个字段是常量的时候，order by可以不必遵守最左前缀原则；
				5：如果where条件中某个索引列进行范围查找，也就无法在使用另一个索引（或者该索引的后续字段进行排序了）
		3：如果上述条件不满足，就会回表查询排序；因此尽量避免回表查询；如果遇到排序时回表查询，type列里面的值有using filesort;
	7：冗余和重复索引：
		1：重复索引：在相同列上按照相同的顺序创建的相同类型的索引，成为重复索引；如key(A),primiry(A)等；
					 其中列A成为重复索引；
		2：重复索引的问题：mysql是允许对同一个列建立多个相同的索引，但是这些索引均需要单独维护，而且在生成执行计划的时候也需要考虑这些索引，造成执行计划生成过慢，影响性能；

		因此，重复索引要尽量避免；

		冗余索引：
			何为冗余索引：如先创建了索引key(A,B)之后又创建了key(A),就称A未冗余索引；
			原因：虽然两个索引并不一样，但是在索引key(A,B)中，A列已经被索引覆盖，而且是作为最左前缀出现的，虽然是个多列索引，但是A列是可以使用索引的；
			例外：如已经有key(A,B),此时再创建key(B),B将不再是冗余索引；
	    冗余索引有时候针对不同的查询需求无法避免，因此在满足查询条件的基础上尽可能减少冗余索引；

	    对于innodb引擎：所有的多列索引在最后一个都会加上主键；主键是作为最后一个索引隐式出现的；因此不要显式的将主键列作为多列索引的最后一项；
	8：避免过度建立索引；对于使用不到的索引要及时删除掉；














