一：c语言基本特征：
    1：切近硬件，运行速度较快；
    2：是编译执行的语言；
    3：仅支持面向过程编程；
二：c语言运行流程：
    1：源程序：
        即c源代码文件；
        c源代码以.c作为后缀；
        一个c源程序可以由多个c源文件组成
    2：编译：
        即将c源代码文件编译为当前平台cpu能够识别的指令
        该指令以字节码表示，（汇编）
        并保存到同名的.o文件中
        编译的同时会检查c语言的基本语法错误；可以将错误消灭在编译期；
    3：链接：
        一个可执行的c程序包括：编译成功的c源代码，启动代码，库函数代码，因此单个编译成功的c文件是无法作为可执行文件的
        链接的过程即为：通过链接器将启动代码以及库函数代码与编译好的.o文件合并成一个可执行文件，并保存为.out文件

        链接时，仅仅会引入c源代码中使用到的库函数的代码，并不会引入整个库函数代码！

        链接完成之后得到的即为可执行文件！
    4：c程序文件执行过程：
        linux:.c => .o => .out
        windows:.c => .obj => .exe

三：linux和windows上的c编译器
    c语言是编译执行的语言，因此需要编译器！
    linux上的编译器为：gcc
    windows上的编译器为：Cygwin

四：c语言基本语法规范：
    1：代码组成：
        一个c文件由：预处理指令、函数、变量、语句、注释 五部分组成；
        一个c源程序由一个或者多个c源文件组成；
        c源代码文件以.c作为后缀；

    2：基本语法规则：
        1：以 ; 号作为语句结束符；
        2：以 {} 作为语句块确认符号
        3：以 /*....*/ 注释代码
        4：标识符基本命名规则：
            1：由数字、字母、下划线组成；
            2：不能以数字开头；
            3：不能和系统关键字冲突；
            4：c中严格区分标识符大小写；
            5：尽量避免使用_或者__开头；
            6：要有可读性；
        5：对于main函数：
            1：一个可执行的c源程序中必须要有且只能有一个main函数；
            2：main函数是整个程序的入口；执行时从main函数开始逐行执行；
            3：main的返回值可以是int或者void；
            4：一个c源程序可以有任意多个函数，但是主函数(main)只能有一个；
            5：main函数基本声明方式：int main(void){}/void main(void){}

五：c语言中的输出与输入：
    常见输出：
        1：puts();只能输出窄字符串；
        2：putchar();只能输出窄单个字符
        3：putwchar():只能输出宽单个字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
        4：printf():
            功能：用于输出任意内容
            用法: print("format_str",var_content)：将需要输出的内容格式化之后输出；
            格式化字符串：
                1：格式化字符串由自定义字符串和格式化字符共同组成（或者其中一个）；
                2：格式化字符从左向右依次对应需要格式化的内容；
                3：常用格式化字符：
                字符、字符串
                    %s                      输出一个字符串
                    %c                      输出一个字符
                浮点数
                    %f                      输出一个单精度小数格式的浮点数（十进制）
                    %lf                     输出一个以双精度小数格式的浮点数（十进制）
                    %e                      输出一个单精度指数形式的浮点数
                    %le                     输出一个双精度指数形式的浮点数
                    %E                      输出一个单精度指数形式的浮点数
                    %lE                     输出一个双精度指数形式的浮点数
                十进制整数
                    %d                      以十进制、有符号的形式输出 int类型的整数  
                    %hd                     以十进制、有符号的形式输出 short类型的整数                    
                    %ld                     以十进制、有符号的形式输出 long类型的整数
                    %u                      以十进制、无符号的形式输出 int类型的整数    
                    %hu                     以十进制、无符号的形式输出 short类型的整数   
                    %lu                     以十进制、无符号的形式输出 long类型的整数 
                八进制：
                    %o                      以八进制、无符号的形式输出 int类型的整数 
                    %lo                     以八进制、无符号的形式输出 long类型的整数 
                    %ho                     以八进制、无符号的形式输出 short类型的整数  
                十六进制：
                    %X                      以十六进制、无符号的形式输出 int类型的整数 
                    %lX                     以十六进制、无符号的形式输出 long类型的整数 
                    %hX                     以十六进制、无符号的形式输出 short类型的整数  
                4：格式化字符完整形式：
                    %[flag][width][.precision]type
                    flag：标志符号：
                            -：表示左对齐，如果不填则默认右对齐
                            +：用于数字，表示输出符号，如果不填只有负数才会输出符号
                            空格：用于数字：正数加空格，负数加负号；
                            #：对于小数：强制输出小数点；对于八进制，十六进制，二进制，带上前缀；
                    width：最小输出宽度，不够是则以空格补齐，超过时则限制失效
                    .precision： 
                            对于 int，.precision 表示最小输出宽度
                            对于 float，.precision 表示输出精度。
                            对于 str，.precision 表示最大输出宽度。
            备注：----printf()输出以后并不会立刻将信息输出到屏幕；而是放入缓冲区；遇到换行符或者强制刷出的时候才会输出到屏幕；
        5：wprintf():
            功能：用于输出宽字符
            宽字符标识：%ls;
            用法：和printf完全一样

        输入：
            scanf()
                功能：用于捕获用户的标准输入；
                用法：scanf("format_str",param)
    
六：c语言变量：
    变量：
        1：变量特征：
            1：c语言要求变量使用之前必须先声明，后使用；
            2：声明时需要注明变量的数据类型；
            3：变量在使用过程中只能引用声明时数据类型的数据，不能引用其他类型的数据；
            4：变量声明的位置只能在调用变量的语句之前；
        2：变量命名：
            1：必须严格遵守c语言标识符命名规则；
            2：推荐以小写加_方式命名；
        3：变量的作用域：
            声明的位置：
                可以在函数外部声明变量：称为全局变量；
                可以在函数内部声明变量：称为局部变量；
            局部变量：
                函数中声明变量称为局部变量；
                局部变量的声明位置：
                    对于c89规定，在任何执行语句之前，在块的开头声明所有局部变量；
                    对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置； 
                局部变量如果声明之后未赋值，只会为其分配指定大小的内存空间，值是未知的；
                局部变量的作用域是函数内部的代码块
                自动局部变量 auto
                    1：声明方式如：int b=3; 等同于auto int b=3;
                    2：该变量只能在所声明的函数中使用；其他函数不能调用；
                    3：其生命周期和函数保持一致，函数执行完毕，变量所占用的内存即被释放；
                    4：并且，自动局部变量如果不赋初值，其值是不确定的；
                静态局部变量 static
                    1：该变量只能在所声明的函数中使用；其他函数不能调用；
                    2：其生命周期和程序运行的生命周期一致，
                        1：在调用声明该静态变量的函数时，系统为该静态变量创建内存空间，但是只有程序运行完毕，该静态变量的内存空间才会释放！
                        即：静态局部变量的值在函数调用结束后不消失，而是保留原值，其所占用的内存空间也不释放！下次再调用该函数时，该变量已经有值，将不会再从新声明该变量！值就是上一次调用函数结束时为其赋的值；只有程序运行结束，该静态局部变量所占内存空间才会释放；
                    3：如果静态局部变量不赋初值，其值不确定；
                    4：声明方式：static int a=12;
                在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是通常认为的“零”值。

            全局变量：
                在函数外部声明的变量；
                全局变量如果声明之后未赋值，则值默认是0
                全局变量的作用域是文件，(这里的文件并不单单指当前文件，而是包括所有的c源代码文件以及头文件)
                全局变量只能在函数体外声明并初始化，但是不能参与任何运算！任何运算操作只能在函数体内进行！
                普通全局变量：
                    声明方式：int a=23;(无需添加任何修饰词)
                    全局变量的生命周期和程序的生命周期一致，即程序运行结束变量所占内存空间才会释放！
                    如果源程序由多个源文件组成，多个文件出现相同名称的全局变量将会出现冲突；
                    普通全局变量可以在别的文件中通过extern引用
                静态全局变量
                     声明方式：static int a=23;(需添加static修饰词)
                     全局变量的生命周期和程序的生命周期一致，即程序运行结束变量所占内存空间才会释放！
                     如果源程序由多个源文件组成，多个文件出现相同名称的全局变量将不会出现冲突；
                     静态全局变量不可以在别的文件中通过extern引用


        

七：c语言数据类型：
        1：基本类型：(整数/浮点数)
            1.1--整数：
                类型列表:
                    short int              2字节                  -32768到32767
                    (short)
                    unsigned short         2字节                  0~65535

                    int                    2字节/4字节             -32768到32767或者-2e32到2e32-1
                    unsigned short         2字节                   0~65535或者0~2e33-1

                    long int               4字节                   -2e32到2e32-1
                    (long)

                    long long int          8字节                   -2e64到2e64-1
                    (long long)

                修饰类型：
                    singed                 有符号(默认类型)
                    unsigned               无符号，最小值从0开始
                数据溢出：
                    向上溢出
                        有符号类型溢出之后，将直接从负值最小值开始从新计数(向上递增)；
                        无符号类型溢出之后，将直接从0开始从新计数(向上递增)；
                    向下溢出：
                        无论有符号还是无符号，均是从正值最大值从新计数(向下递减)；只是正值最大值在有符号和无符号之间不通！
                数据类型选择：
                    1：优先使用无符号类型
                    2：确保‘够用’的情况下选择最小的数据类型
                    3：在数据类型交叉的时候，选择必须的数据类型：如要求使用long型数据，就不要使用int型数据！
            1.2 字符类型
                基本特征：
                    c语言中的基本数据类型中没有字符串，而是字符类型；
                    字符类型以''包裹，""包裹的是字符串！
                    字符类型符号：char；
                    由char声明，并由''包裹的字符称为窄字符！char类型的字符数组则成为窄字符串！
                    char虽然用于表示字符类型，但是存储时以数字存储！
                    char类型的大小固定是1个字节；表示范围在：-128 ~ 127之间；
                    unsinged char 类型大小固定是1个字节，表示范围在：0-255之间 ；
                    char类型实际存储的是数字，而非字符；且char类型的字符以ASCII编码存储！

                对于中文字符的存储：
                    微软编译器（内嵌于 Visual Studio 或者 Visual C++ 中）采用 UTF-16 编码，使用 2 个字节存储一个中文字符，用 unsigned short 类型就可以容纳。
                    GCC、LLVM/Clang（内嵌于 Xcode 中）采用 UTF-32 编码，使用 4 个字节存储一个中文字符，用 unsigned int 类型就可以容纳。 

                    对于在windows上和linux上中文字符长度不一致的问题，c语言推出wchar_t类型，wchar_t的类型由编译器决定！wchar_t类型位于<wchar.h>头文件中！

                    使用wchar_t来表示的字符类型称为宽字符；由wchar_t表示的字符数组称为宽字符串！

                    使用wchar_t这种宽字符需要在字符前加L；如：wchar_t d = L'国';  //中文汉字

                char类型在使用时具体存储的数字和编码表有关：
                    ASCII编码表：只能表示有限的字符，中文等一些特殊字符无法表示；
                    Unicode编码表：是ASCII编码的超集，可以表示更多的字符；
                    在C语言中，
                        只有 char 类型的窄字符才使用 ASCII 编码，
                        char 类型的窄字符串使用的编码依据平台和编译器决定；
                        wchar_t 类型的宽字符和宽字符串则使用utf-16或者utf-32编码！（unicode编码）
                输出字符：
                    对于puts/putchar只能输出窄字符或者窄字符串！
                    对于putwchar/wprintf专门用来输出宽字符的！在输出宽字符之前还要使用 setlocale 函数进行本地化设置
                       如果是在windows环境下：setlocale(LC_ALL,"zh-CN");
                       如果是在linux环境下：setlocale(LC_ALL,"zh_CN");
                       setlocal函数在<locale.h>头文件中！
                    对于wprintf输出字符串时，对应的格式控制符号为：%ls;
                转义字符：
                    c语言支持的转义字符包括：
                     \r \n \v \f \b \a \\ \' \" \t \?等
                    反转义：
                        使用\\即可；
            1.3--浮点数
                类型列表：                           
                float                               4字节                              6位小数（精确度）
                double                              8字节                              15位小数（精确度）
                long double                         16字节                             19位小数（精确度）
                备注：
                    1：c语言中浮点数无法精确表示浮点数值，只能近似的表示指定值，因此如果比较两个看起来一样的浮点数是否相同；结果一定是不同；
                    2：浮点数可以使用小数形式表达，也可使用指数形式表达；但是在内存中，整数部分和小数部分是分开存储的；
                    3：对于一些算数运算，浮点数之间运算时损失的精度会更多；（原因在于在任何区间内都存在无穷多个实数，浮点数不能表示区间内所有的值，只是实际值的近似值）
            1.4--布尔类型：
                C99标准中添加了_Bool类型，用于表示布尔值；即：true和false
                _Bool大小仅为一位，存储0/1；0表示false,1表示true；
                c语言中能够自动将其余数据类型转换为布尔类型的值；
            
            总结：
                基本类型包括：整形，浮点型，字符型，布尔型
                获取基本类型在当前系统的大小：sizeof(type);如：sizeof(int)
                推荐变量命名的时候带上前缀：如i_var代表整形，ui_var代表unsigned int，si_var代表signed int;
        2:其他复合数据类型：
            2.1：数组类型：
                c语言中的数组：
                    数据的集合称为数组，数组中的每一个值称为数组元素，数组中值的个数称为数组的长度！
                    数组长度的计算： length = sizeof(数组名)/sizeof(数组元素数据类型)；

                c语言中数组的声明：
                    1：需要声明数组的数据类型以及数组可以存放的数据量，以及数组名称；
                    2：类型 数组名[长度]
                    3：eg：int age[2]
                    4：数组声明完成之后，系统将为数组分配指定大小的连续内存空间,但是并不会进行初始化：

                数组的赋值：
                    1：数组赋值可以在声明时同时赋值，也可以在声明之后进行赋值！但是仅可以在声明的同时维数组赋上所有的值，一旦声明完成，之后赋值将只能按个赋值；
                    2：赋值时，数组元素需要使用{}来包裹数组元素！元素之间使用,来进行分割！
                    3：赋值时如果赋值元素少于总体元素个数时剩余的元素自动按照数据类型进行填充！
                        1：如果数组类型为：int,short,long,将直接赋值为整数0；
                        2：如果数组类型为：char,将赋值为\0；
                        3：如果数组类型为：float或者double，则将会赋值为0.0；
                    4：数组声明的同时如果全部进行赋值，那么数组声明时可以不用指定长度！
                c语言中数组的特征：
                    1：使用时必须先声明；
                    2：声明时必须注明数据类型；指定数据类型的数组只能存放对应类型的数据，不能存储其他类型的数据；
                    3：数组的下标只能是数字，不能是字符串；（相对于弱数据类型语言中的数组，如php）
                    4：数组中的数据不能超过数组声明的长度；也不能小于0；
                    5：数组在内存中的存储空间是连续的；数组名表示数组的首地址;也代表整个数组
                    6：数组元素指针的加减运算：
                        1：从宏观上来看：存放每一个数组元素地址的指针变量+1；即是指向了下一个元素的存放地址；
                        2：从微观上来看：存放每一个数组元素地址的指针变量+1；则是跳过了m个字节，m指的是所存储的数据元素的类型在内存中所占用的字节个数；
                    7：c语言中的数组是静态数组，即长度一旦固定将不能改变，不能随意插入数据，也不能随意删除数据；
                    8：固定长度的数组是在编译期间分配内存的；

                c语言中数组的取值：
                    值 = 数组名[下标];

                二维数组：
                    二维数组的声明：
                        数据类型  数组名[一维长度][二维长度];
                    二维数组的本质：
                        二维数组本质上类似于一个矩阵：一维长度指的是矩阵的行数；
                                                   二维长度指的是矩阵的列数；
                    二维数组的理解：
                        二维数组可以理解为一维数组，只不过每一个元素的值又指向一个数组
                    二维数组的赋值：
                        1：分段赋值：
                            1：完全赋值：每一行都完全赋值；
                            2：部分赋值：默认从左向右赋值，其余则填0；
                        2：连续赋值：
                            1：完全赋值：从左向右按行赋值；此时可不必给出一维长度；
                            2：部分赋值：从左向右按行赋值；其余则填0；
                    二维数组的取值：
                        值 = 数组名[一维下标][二维下标]
            2.2：字符串类型：
                1：c语言中没有专门存储字符串的数据类型；字符串使用字符数组来存储；字符数组由连续的存储单元组成；每个单元存储一个字符；

                2：字符串的符号是"";

                3：由于字符串本质上是字符数组，因此字符串的名称就类似于字符数组的名称；
                
                4：因此字符串的起始位置可以由字符串的名称确定，其终止位置则是根据\0来确定

                5：但是要注意：只有在""包裹的字符串后面才会添加\0；而由单个字符组成的字符数组则不会添加\0；

                6：对于字符串长度：如果是字符数组组成，则字符串长度为字符数组元素个数；如果是由""包裹的字符串组成，则长度等于""包裹的字符个数+1；

                7：字符串的长度使用strlen()来获取；但是strlen仅仅获取的是字符串本身的长度，并未计算结束符，也并非是实际声明的长度；sizeof()则会将结束符计算在内(获取的是实际声明的长度)；

                8：字符和单字符串不同："x"和'x'是不一样的，"x"长度为2，存储了两个字符；而'x'长度为1；存储了一个字符；

                9：string.h头文件包含了针对字符串的所有操作；
                
                10：字符串初始化方式：
                    char str[] = {'a','b','c','d','e'};

                    char str2[] = "abcde";

                    char str3[] = { "abcde" };

                    char *str4 = "abcde";

                    char *str5 = {"abcde"};
                **1：不同string声明方式的差别：
                    对于char str[n] 类似这种字符数组的声明方式：
                        无论是否初始化，无论以何种方式初始化，系统在声明时均会为其分配内存空间！
                    对于char *str 类似这种字符指针的声明方式：
                        在未被初始化时，只能确定该变量是字符指针变量，无法确定该指针的指向！
                        初始化完成之后，该字符指针变量便会指向给定的字符串首个字符的地址！
                **2：对于其代表的意义：
                    对于str:
                        str的sizeof值为5；
                        因此 str 代表的是整个数组；
                    对于str2和str3
                        str2和str3完全等价，sizeof值为6，原因在于系统会在""包裹的字符串后面+\0；
                        因此str2和str3代表的是整个数组；
                    对于str4和str5
                        str4和str5完全等价，代表的仅仅是一个字符指针，其指向后面字符串的首个字符的地址；
                **3：数据存储位置
                    对于str str2 str3其本质上是字符数组，存储位置在全局数据区，或者栈区，具备可读写权限！
                    对于 str4和str5其本质上是字符串常量，存储在常量区，只有读权限，无法更改字符串内容！
                **4：字符串赋值：
                    对于str,str2,str3而言，全部字符一次赋值给数组只能在声明的同时进行，声明完成之后将只能按个赋值；
                    对于str4和str5而言，则可以多次完全赋值！         

        3：c语言中的进制：
            3.1：进制组成：
                二进制：由0/1组成，以0b或者0B开头；逢2进位；
                八进制：由0~7八个数字组成，以0开头，逢8进位；
                十进制：由0~9是个数字组成，逢10进位；
                十六进制：由数字0~9、字母A~F或者a~f组成；以0x或者0X开头；
            3.2：进制输出：
                输出八进制：%o,%lo,%ho
                输出十进制：%d,%ld,%hd、%u,%lu,%hu；
                输出十六进制：%x,%lx,%hx、%X,%lX,%hX;
                备注：输出时，需要加上#来带上输出时的前缀；
                      只有十进制，printf才提供了有符号和无符号的区分！对于八进制和十六进制输出的均是无符号数；
                      printf在以八进制或者十六进制读取数值时，将会把内存中的所有位都当做数值位！

        4：c语言中的正负符号：
            数字如果不带符号则默认为正数；如果带上‘-’则为负数；
            c语言规定，把内存的最高位规定为符号位；如：int类型占用32位，则0~30位存储数字，31位存储符号；
            c语言规定，1代表负号-，0代表正数；

        5：整数在内存中的存储方式：
            5.1：原码：将一个整数转换成二进制的形式，就是其原码！
            5.2：反码：将一个整数转换成二进制的形式，如果该整数是正数，那么反码就是原码，如果该整数是负数，那么反码就是除过符号位以外的数值位取反！
            5.3：补码：对于整数：补码就是其原码；
                    对于负数：补码是其反码加1；
            内存中存储的整数均是以补码的形式来存储！运算也是以补码的形式来运算的！

        6：小数在内存中的存储方式：
            6.1：c语言在内存中以定点数存储整数，以浮点数存储小数！
            6.2：定点数：指小数点在固定位置的数值；
               浮点数：这种以指数的形式来存储小数的解决方案就叫做浮点数
            6.3：分析：
                用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。
        7：数据类型转换：
            7.1：自动类型转换：
                自动类型转换是由编译器根据计算需求，自动将数据类型进行转换的一种方式；
                自动类型转换发生在两种情况下：
                    1：赋值时：如果类型转换合法，将自动进行转换！(将高精度值赋给低精度值将会发生精度损失)
                    2：运算中：运算中，编译器会将所有的数据的类型转换为同一种数据类型，然后再进行计算！
                              转换方向为数据长度增加方向(高精度方向)进行;
                              所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也将全部转换为double进行运算；
                              需要注意的是：运算结果的溢出！
                              char/short->int->long
                                             ->float->double
            7.2：强制类型转换：
                强制类型转换方式：(目标数据类型)待转换变量
            备注： 
                1：无论是强制类型转换还是自动类型转换，转换改变的仅仅是结果，源数据的类型并不会改变！
                2：有些类型能够自动转换也能够强制转换，有些类型则只能强制转换不能自动转换！
                3：数据类型转换要合适，不能够在各种数据类型之间随意转换！

            
八：c语言运算：
    级别：赋值运算符(=) < &&和|| < 关系运算符 < 算术运算符 < 非(!)<()
        1：()运算符：优先级最高，表示先计算括号中的表达式；
        2：逻辑运算符：
            运算符：&& || !
            方向：左结合；
            级别：&& 和 ||低于比较运算符；!高于算数运算符，低于()运算符：
        3：算数运算符：
            运算符 + - * / % ++ --(只能用于数字)
            方向：从左向右运算
            级别：级别仅次于逻辑运算中的!;
            备注： 
                对于除法：
                    如果除数以及被除数均是整数，那么运算结果也是整数，即使不能整除，也将舍去小数部分；
                    如果除数或者被除数有一个是小数，那么运算结果也是小数，并且是double类型的小数！
                对于取余运算：
                    c语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
                对于前自增和后自增运算：
                    前自增在赋值时先运算后赋值，
                    后自增在赋值时先赋值后运算，
        4：关系运算：
            运算符：< > == <= >= !=
            方向：从左向右结合，
            级别：比算数运算符级别低，比逻辑运算符中的&&和||运算符高；< > <= >= 运算符级别相同 ，且比剩下的两个级别高；
        5：赋值运算符：
            运算符= += -= *= /= %= 
            方向：将右侧的值赋给左侧
            级别：级别最低；
        6：位运算
            直接对二进制位操作的方式：位运算
            c语言包括6中位运算：& | ^ ~ << >>
            &：按照二进制位求交运算
            |：按照二进制位求或运算
            ^：按照二进制位求异或运算
            ~：按照二进制位取反
            <<:按照二进制位全部左移，高位丢弃，低位补0；
                （如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。）
            >>：按照二进制位全部右移，低位丢弃，高位补0或者1；最高位是0就补0，最高位是1就补1；
                （如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1）
 c语言流程：
    1：条件：
        1：if..else条件语句：
            if(表达式){}
            if(表达式){}else if(表达式){}else{}
            if(表达式){}else{}
        2:switch条件语句：
            switch(var){
                case 1:
                    code..
                    break;
                case 2:
                    code..
                    break;
                default:
                    code...
            }
            备注： 
                1：switch中只能是整数，不能是浮点数；
                2：case只能是整数，不能是浮点数或者其余变量类型
                3：多个分支有共同处理方式，则多个分支可以放在一起，并只在最后一个分支结束时使用break语句；
                4：default不是必须的；当所有的case都无法匹配时，将会走进default;
        3：? :   三目运算符；

    3：循环：
        for(int i=0;i<n;i++){}
        while(表达式){}
        do{}while(表达式);(;一定要有)
    4：跳出循环：
        1：break;结束当前循环；
        2:continue;结束当前循环，并开始新的循环！
九：c语言中的随机数
    c语言中需要使用rand()函数来产生随机数；随机数范围在0~MAX_NUM之间
    设置随机数种子：srand();一般使用时间来播种：srand((unsigned)time(NULL));
    备注： 
        rand和srand函数需要引入<stdlib.h>头文件
        time函数需要引入<time.h>头文件

十：c语言函数
    1：函数即声明的代码块，c代码文件中可以有任意多个函数；
    2：函数的声明：
        返回值类型/void function_name(int a,int b){
                code....
        }
        备注：  
            1：函数声明要注明返回值类型，没有返回值时要写void；
            2：函数名要遵守c语言标识符命名规范；推荐以小写加下划线方式命名；
            3：形参需要通过数据类型 变量的方式声明，多个形参使用,隔开；
            4：在函数体中使用return语句返回数据。

    3：形参：
        1：形参是声明函数在调用时必须传入的参数，要写在()中；多个形参以 ，分割；且形参要注明数据类型；
        2：形参不允许赋初值；
        3：形参和实参在数量上，顺序上，类型上必须严格一致；
        4：函数调用中参数传递是单向的，即：只能将实参的值赋值给形参，不能把形参的值赋给实参，因此，形参的值发生改变并不会影响实参的值；
        5：形参变量只有在函数调用时才会分配内存，调用结束后，立刻释放内存；
    4：函数的返回值：
        1：返回值使用return;即：return 表达式;
        2：一个函数可以有多个return语句，但是只会执行第一个；
    5：函数调用：
        1：函数调用：函数名(实参) 即可调用；如果函数有返回值则可以使用变量接收返回值；如果没有返回值则不要使用变量接收函数调用的结果；
        2：c语言的执行逻辑是从main函数开始执行，而且是依次从上往下逐条执行；原则上函数的定义要出现在函数的调用之前；否则将会报错；
        3：如果函数在定义之前需要使用则需要提前声明；
    6：函数的声明：
        1：声明格式：返回值类型 函数名 （类型 形参，类型 形参,...）;或者返回值类型 函数名 （类型,类型,...）;
        2：在函数调用之前有了函数的声明，函数实体将可以出现在任何地方，可以使其他文件，静态链接库，动态链接库；
    7：递归：
        1：函数中自己调用自己的过程称为递归；
        2：在函数中每递归一次，就等同于从新调用一次该函数；
        3：基于第二条，因此在递归中每递归一次，函数被调用一次，函数所使用到的局部变量都将被重新创建一次；并放在栈中！
        4：基于第三条：递归的调用速度是低于循环的，而且占用额外的内存空间；并且递归的深度取决于内存的大小；
        
  c语言中的函数库：       
    基本库：<stdio.h>、<ctype.h>、<stdlib.h>、<string.h>
    常用库：<assert.h>、<limits.h>、<stddef.h>、<time.h>
    其他库：<float.h>、<math.h>、<error.h>、<locale.h>、<setjmp.h>、<signal.h>、<stdarg.h>

十一：预处理命令：
    预处理概述：
        1：预处理指的是：在编译之前对源文件进行的一些处理操作
        2：预处理主要是处理以#开头的命令，预处理命令要放在所有的函数外面，而且一般放在源文件的最前面；
        3：编译器会将预处理的结果保存到和源文件同名的.i文件中；
        4：预处理包括：宏定义，文件包含，条件编译；
    预处理--文件包含：
        1：文件包含使用：#include命令；
        2：处理过程为：将头文件中的内容复制粘贴到该命令所在的位置；
        3：使用方式：
            #include <stdio.h>
            #include "myHeader.h"
            备注：区别在于头文件搜索路径不同；在包含标准库的头文件时建议使用<>,包含自定义头文件时建议使用"";
        4：文件包含允许嵌套；
    预处理--宏定义
        宏定义：#define 宏名称 宏值
        备注：
            1：宏定义不是说明；不是语句；不是表达式，因此无需使用;作为结束符！
            2：宏定义必须写在函数外面，其作用域为宏定义命令到源程序结束！
            3：如果需要提前结束宏的作用域：可使用#undef 宏名；
            4：宏在使用时只是简单的字符串替换而已；
            4：宏定义允许嵌套；
            5：宏名：
                1：必须严格遵守c语言标识符命名规则；
                2：推荐以大写加下划线的方式命名；
            6：可以通过宏来定义数据类型，但是宏定义的数据类型在使用时仅仅只是简单的字符串替换，而不是真正的定义某种数据类型的别名！和typedef完全不同；
            7：宏可以有参数：
                声明方式：#define 宏名(形参列表) 字符串(字符串中可以包含各个形参)
                调用方式：宏名(实参列表)；
                注意事项：
                    1：带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现；
                    2：在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型；无论何值，都将转换为字符串直接替换！
                    3：宏只是简单的字符替换！即便是表达式也只是表达式字符的替换！
                    4：带参数的宏替换只替换参数，不做其他字符的替换！
            8：#和##
                #会在参数的两端添加双引号，将宏参数转换为字符串；
                ##可以将多个参数连接起来；
            
            9：c语言中常见的宏：
                __LINE__：表示当前源代码的行号；
                __FILE__：表示当前源文件的名称；
                __DATE__：表示当前的编译日期；
                __TIME__：表示当前的编译时间；
                __STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
                __cplusplus：当编写C++程序时该标识符被定义。
    预处理--条件编译：
        条件编译指在编译阶段对宏进行判断，编译不同的代码；
        宏判断语法：
            a语法：
                #if 整型常量表达式1
                    程序段1
                #elif 整型常量表达式2
                    程序段2
                #elif 整型常量表达式3
                    程序段3
                #else
                    程序段4
                #endif
            注意：#if后面是整形常量表达式，即表达式的结果必须是整数；

            b语法：
                #ifdef  宏名a
                    程序段1
                #else
                    程序段2
                #endif
                指如果已经对宏 宏名a 定义过则执行程序段1，否则执行程序段2；相反的有：

                #ifndef 宏名
                    程序段1 
                #else 
                    程序段2 
                #endif
        宏判断语法指的是在编译阶段对宏进行判断，并编译不同的代码；
        普通的条件语句对宏的判断则指的是根据不同的宏值执行不同的代码；
        

十二：c语言指针：
    1：内存地址：
        数据要被cpu获取到必须先加载至内存中，
        内存在计算机中会被分割为若干个1个字节大小的存储单元，
        每一个存储单元都有一个编号，这个编号即为内存的地址！
        内存地址从0开始，以十六进制表示！
            
    2：指针：
        指向内存块的一个标记，就是内存块的地址！
    
    3：指针和数据：
        指针指的是内存块的地址，数据指的是这个地址的内存块中存放的数据内容；

    4：指针变量： 
        指针变量和普通的变量一样都是变量；
        但是指针变量存储的是内存块的地址；普通变量存储的是内存块中的数据； 
        指针变量本身的数据类型为16进制的unsigned int类型的整数，
        但是不能直接将指针变量等同于指向无符号整数的普通变量！

    5：指针变量的声明：
        1：类型名称 * 变量名
        2：数据类型名称 *变量名
        备注： 
            1：类型名称指的是该指针变量指向的内存中可以存储的数据的类型；
            2：*指明该变量是一个指针变量；
            3：变量名遵守c标识符命名规范；
            4：*和变量名之间空格可有可无；但是*作为取值运算符时必须要和变量紧挨在一起！

    6：和指针相关的两种运算：
        1：&:该符号为取地址符，可以通过&获取变量引用的值在内存中的地址；
        2：*:该符号为取值符，可以通过*获取指针变量指定内存块地址所存储的值；

    7：指针变量允许的运算：
        1：赋值：即可以将一个指针变量赋值给同类型的指针变量；（1：必须是相同的数据类型；2：必须是指针变量）
        2：取值：即可以通过*取值运算符获取指针变量指定的内存地址的值；
        3：获取指针：即可以通过&取地址运算符获取变量的内存地址；

        4：加上一个整数
        5：自增
        6：减去一个整数
        7：自减
        备注：
            普通变量加减整数：是指给内存中存放的数据本身加/减n；不会引起所操作数据在内存中地址的改变； 
            指针变量加法：
                微观上看：指针变量+n指的是指针变量的指向跳过n*m个内存块；其中m字节指的是指针所指的内存空间的数据的数据类型在当前系统中所占用的字节的个数；
                宏观上看：指针变量的加减运算改变的是当前指针变量所指内存地址；
            指针变量可以参与比较运算，比较大小并无任何意义，比较是否相等则可以判断两个指针变量是否指向同一块内存区域；
            不能对指针变量进行乘法，除法，或者取余运算，并无任何实际意义；
            对于指向普通变量的指针变量加减某个值改变其内存指向并无任何实际意义，对于数组或者字符串改变其指针变量的值则可精确推算改变之后所指内存区域的内容；

    8：给指定内存地址的内存块赋值：
        *变量名 = vlaue
        备注：
            1：注意：*指针变量代表的是内存块中所存放的数据；指针变量代表的是某个内存地址；
            2：该赋值方式是直接改变内存块中的数据内容，所有指向该内存块的指针变量的值都会是新设的值！
    9：指针作为函数的参数：
        1：c语言中实参到形参的传递是单向的；即：形参在对应函数中做了修改以后并不会影响实参变量的值；
        2：如果函数中需要改变外部变量的值则必须传递外部变量的内存地址；
        3：对于数组和结构体等数据结合类型的数据建议不要直接传递数据集合本身，而是传递指针；
    10：指针作为函数的返回值：
        1：如果函数将指针作为返回值，则称该函数是指针函数；
        2：指针函数的声明：返回值类型 *函数名(形参){code...}
        3：函数执行完毕之后将会销毁在函数内部声明的所有变量；因此不要将返回指针指向函数内部声明的变量以及形参；
        4：注意函数执行完毕之后会对函数内部所声明的所有变量以及形参销毁，但是销毁并非是直接清空掉函数运行期间申请的内存空间；而是弃之不用，即函数执行完毕之后，其执行期间所申请的内存空间现在可以被写入任意内容；
    11：二级指针：
        1：指针本质上就是一个普通的变量，只是其中所存储的值代表的是某个内存块的地址；而值本身则是一个十六进制的整数；指针变量本身存储的那个十六进制的整数也是需要占用内存空间的；
        2：指向存储某个指针值的内存块地址的变量称为二级指针；即二级指针任然是个普通变量，存储十六进制的整数，改整数代表的是另一个指针值的地址；
        3：二级指针需要使用**来声明，同理，三级指针需要使用***来声明；
        4：可以理解指针变量就是普通的变量，仅仅是其所存储的值具备不同的含义，但是编写代码要遵守c语言语法规范；
        5：二级指针取值时需要两个*来取值，三级指针需要三个*来取值，以此类推！
    12：空指针 NULL：
        1：一个指针变量可以指向任意一块内存区域；无论该内存区域有没有被分配；也不管改内存有没有使用权限；只要给定地址，指针变量就能指向该内存块；
        2：如果指针变量未被初始化，则该指针变量指向的哪个内存块是不确定的；因此一般对没有初始化的指针赋值为NULL;
            即：该指针的值是空的，不指向任何内存区域；（注意：NULL只能是大写的，不能是小写的）
        3：计算机系统在低地址的内存空间不存储任何数据，也不能被用户程序访问；
        4：NULL 本质上是一个宏：((void*)0);而void*则表示一个实际有效的指针，指向的也是实际的内存空间，但是该块内存个空间存储什么类型的值，并不确定；使用的时候需要强制转换；
    13：指针数组：
        1：指针数组和普通数组一样，都是一个数据集合，只是指针数组中的每一个元素代表的不是数据值的内容，而是某个内存块的地址，也就是指针；
        2：指针数组的声明：dateType *arrayName[length] 或者 dataType *(arrayName[length]);
        3：对于指针数组，该数组的数组名就是一个二级指针；
        4：特别的，对于字符串数组而言，本质上就是一个指针数组，数组中的每一个元素虽然赋值的是整个字符串，其实只是存储了字符串的首地址，字符本身在其他位置存储；如：
                char *str[3] = {
                    "this is test",
                    "this is test3",
                };
            等价于：
                char *str1 = "this is test";
                char *str2 = "this is test3";
                char *str[2] = {str0, str1};
        5：数组相关的规则同样适用于指针数组！
    数组（字符串）和指针：
        1：数组开辟的是一块连续的内存区域；数组的每一个元素均按顺序保存在这块内存区域中！

        2：数组指针：指向某个数组元素的指针称为数组指针；和普通的指针没有任何区别，本身存储的一个16进制的unsigned int类型的整数，指向的是某个内存块的地址，只是这个地址的内存区域是为某个数组分配的内存之一！

        3：数组指针的特点：
            数组指针指向数组中某个元素的地址，也只能够代表其所指向的元素；
            由于数组占用的是一块连续的内存空间，因此数组指针的加减操作能够指向数组中其他元素；
            数组指针仅仅能够代表其指向的某个数组元素，不能代表整个数组！和数组名完全不同；

        2：数组名和数组指针：
            1：数组名即是数组的首地址，代表的是整个数组；而数组指针是指向某个数组元素的指针，仅代表其指向的数组元素！
            2：在除过&运算符，sizeof运算符，数组声明以外的其他运算中一般将数组名转换为指向数组第一个元素的指针，但是数组名和指向数组第一个元素的指针并不等价；
            3：数组指针不能代表整个数组，sizeof值也只是unsigned int在当前平台的大小！

        3：对于数组元素的访问既可以通过使用数组名通过下标也可以使用指针来进行访问！

        4：如果函数形参要求传入数组类型的数据，此时传入的数组名实际是数组的首地址，而不代表整个数组；根据传入的数组名也无法使用sizeof来计算数组长度，数组长度需要单独传入；

        5：实参到形参本质上是数据拷贝的过程，因此形参如果是数组，或者函数调用需要传递数组尽量传递数组的首地址，而非整个数组，可以减少内存开销以及时间开销；

    指针与二维数组：
        1：二维数组在声明时有行和列，在形式上是二维的；
        2：二维数组在存储上仍然是一维线性的，占用的是一块连续的内存空间；其组织形式是按照行排列；
        3：二维数组在语义上以及语法上是当做二维处理的；即：二维数组的数组名指向的是第一维的首地址；此时对首地址进行加减1即是改变了当前指针指向的维数；
        4：区分下面两种指针的不同：[ ]的优先级高于*
                int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];p1指向的是一个指针数组的首地址；
                int (*p2)[5];  //二维数组指针，不能去掉括号；p2指向的是一个长度为5，数据类型为int的数组的首地址；

c语言结构体：
    结构体：数据的集合；存放一组数据；
    结构体与数组：
        结构体：
            既可存放一组不同数据类型的数据，也可存放一组相同数据类型的数据；
            数据由两部分组成：类型 名称；
            通过数据名称操作数据值；
        数组：
            只能存放同种数据类型的数据；
            数据仅含数据值本身；
            通过数据的索引操作数据值；
    结构体的声明：
        struct 结构体名{
            数据类型1 数据名称1;
            数据类型2 数据名称2;
            数据类型3 数据名称3;
                    .
                    .
                    .
        }
        如:
            struct stu{
                char *name;//姓名
                int num;//学号
                int age;//年龄
                int group;//所在学习小组
            }
        备注：
            1：stu即为结构体名称，结构体名必须符合c语言标识符命名规范；
            2：结构体中的成员声明中，一行只能声明一个成员，由成员的类型，成员的名称组成;
            3：结构体成员的数据类型并没有限制，可以是任意合法的数据类型以及使用typedef声明的数据类型；
            4：结构体本身只是声明了一组数据的存储模板；指明了一组数据的组织方式，是一种数据类型，并不包含任何实际的数据值；因此并不占用任何内存空间！
            5：结构体名称只是该模板的名称，并非变量名，因此其只能代表结构体模板，不指向任何内存地址；
            6：结构体可以存储任意数据类型的数据，因此结构体可以按顺序嵌套；
            
    结构体变量：
        1：由结构体类型创建出的变量称为结构体变量；
        2：结构体变量的声明方式：
            struct 结构体名 结构体变量名1,结构体变量名2...;
            备注：1：struct指明该变量是一个结构体变量;
                 2：结构体名则指明该变量中数据的构成以及组织方式；
                 3：每声明一个结构体变量，系统就为该变量分配一定的内存空间；内存空间的大小可以由sizeof(结构体名)来获取；
        3：结构体变量也可以在结构体声明时创建：只需要将结构体变量名跟在}后面即可，多个结构体变量名以,号分割！
    结构体指针：
        结构体指针变量指向结构体变量在内存中的地址；
        声明方式：   
            struct 结构体名 *pointer;
        备注： 
            1：数组名除过数组声明，sizeof运算，以及使用取地址符的时候才回当做整个数组，其余时候都会转换为指向第0个元素的指针；
            2：结构体变量名则不会，无论在任何表达式中，结构体变量名都代表的是整个集合本身！
            3：结构体指针指的是指向结构体变量的指针，并非指向结构体的指针，结构体本身不占内存空间，只是一种数据类型，因此指针指向结构体无从谈起；
    结构体数组：
        结构体数组仍然是数组，只是数组中每一个元素的类型都是结构体！        
    结构体的操作：
        取值：结构体变量名.结构体成员名
             结构体指针变量名->结构体成员名
             (*结构体指针变量名).结构体成员名

        赋值：结构体变量名.结构体成员名 = 值
             结构体指针变量名->结构体成员名 = 值
             (*结构体指针变量名).结构体成员名 = 值
    结构体作为函数参数：
        结构体，数组这一类集合数据类型一般作为函数参数时都是传递指针，而非整个数据集合；
            如果传递数据集合牵扯到数据的拷贝，浪费内存空间，且速度较慢；
            如果传递数据集合的指针，则仅仅拷贝一个16进制 int类型的整数；内存开销以及时间开销都会小很多；
    结构体占用内存空间的大小：
        结构体中每一个成员在内存中的存储时连续且有序的存储；
        结构体占用内存大小有可能是每个成员的数据类型在当前平台占用内存大小的总和，也有可能大于该值！
        在编译器的具体实现中，因为内存对齐的原因，各个成员之间可能会存在缝隙；如：
            struct tmp {
                char name[8];
                int length;
            };
            该结构体在win32位平台下，sizeof的值是12；
            struct tmp {
                char name[10];
                int length;
            };
            该结构体在win32位平台下，sizeof的值是16；多出的两个字节是由于32位平台内存以4字节对齐，前10个字节刚好差两个字节成功称为4的倍数，实现4字节对齐，因此name数组和length之间就存在两个字节的缝隙；
枚举类型：
        枚举类型：有些情况只需要使用很少量的整数，但是有需要有一定的语义，此时可以给每一个整数取名来代表该整数；
                 此时，便可以将这一群整数定义为枚举类型
        
        枚举的定义形式：
            enum 枚举类型的名称{枚举值1,枚举值2}；
            eg: enum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };
        枚举类型的基本特征：
            1：enum是一个关键字，定义枚举类型的数据类型；
            2：week是枚举类的名称，通过该枚举类名即可定义枚举变量；
            3：Mon,Tues等是枚举成员，其值从左往右从0开始，即week.Mon的值为0；
            4：也可以单独为每一个枚举成员设置具体的值；
                如: enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
            5：也可以只为第一个枚举成员设置初始值，其余枚举成员将自动在前一个基础上+1；
            6：枚举成员都是常量，在编译时期其值就已经被编译到代码中，并不占用数据区(常量区、全局数据区、栈区和堆区),因此也无法通过&获取枚举成员地址；
        枚举变量：
            数据类型为枚举类型的变量称为枚举变量；
                eg:enum week a = Mon, b = Wed, c = Sat;

共用体(联合、联合体)：
        联合体声明：
            union 共用体名{
                成员列表;
            }
        联合体和结构体区别：
            1：结构体中的各个成员会占用不同的内存，互相之间没影响；而联合体的所有成员占用同一段内存，修改一个成员会影响其余所有成员！
            2：结构体占用的内存大于等于所有成员占用的内存总和(成员之间可能会有缝隙)
              共用体占用的内存等于最长的成员占用的内存，同一时刻只能保存一个成员的值，如果对新成员赋值就会吧原来的成员的值覆盖掉
        联合体变量：
            联合体也是一种自定义类型，可以通过它来创建变量:
                union data{
                    int n;
                    char ch;
                    double f;
                };
                union data a, b, c;  
        
位域：
        有时候存储有些数据并不需要一个完整的字节(8位)，只需要其中几个位而已；因此在声明结构体是即可声明数据的位数：
        eg:
            struct bs{
                unsigned m;
                unsigned n: 4;
                unsigned char ch: 6;
            }
            其中n:4即声明结构体成员n所占二进制的位数为4；
        备注：
            1：位域的宽度最大不能超过器数据类型的宽度；
            2：只有有限的集中数据类型才可以使用位域：int,sined int和unsigned int
    结构体特征：
        1：可以存储不同数据类型的数据，包括基本类型的数据以及复合类型的数据以及其他结构体等复杂类型的数据！
        2：结构体的声明只是自定义一种数据类型，并不包含真实的数据，因此并不占用内存空间；
        3：结构体变量是结构体模板的实现，包含了真实的数据，因此结构体变量是需要内存空间的；
        2：结构体理论上在内存中是连续存储的，但是在编译器的具体实现中各个成员之间可能存在缝隙；

c语言为数据类型定义别名：typedef
    使用方式：typedef oldName newName;
    为基本数据类型定义别名：
        如：typedef int INTEGER;那么INTEGER就代表int类型的数据！
    为数组类型定义别名：
        如：typedef char arr_type[20];
            arr_type a1,a2;等价于char a1[20],a2[20]
    为结构体定义基本类型：
        如：typedef struct stu{
                    char *name;
                    int age
            } STU;
            STU stu1;等价于 struct stu stu1;
c语言中的常量：
    1：在c语言中常量指值不能被修改的变量称为常量！
    2：c语言中的常量通过const修饰一个变量得到！
    3：const使用方式：
        基本使用方式：const type var_name = value;
        3.1：const要求在声明变量时即初始化，否则将无法再赋值！
        3.2：const来修饰普通变量，则该变量将不能再重新赋值：使用方式：const type var_name = value;
        3.3：const来修饰指针变量，则有三种情况：
            情况1：const 修饰的是指针符号和变量名，那么指针变量所指向的内存空间中的值不能被修改；指针变量本身可以修改指向不同的内存空间！如：
                const int *pointer;
                int const *pointer;
            情况2：const 修饰的是变量名，不包括指针符号，那么指针变量本身不能修改，即指针变量不能再被修改指向其他内存空间：
                int * const pointer;
            情况3：const 既修饰指针又修饰变量，则指针变量本身不能再被修改，即指针变量不能再被修改为指向其他内存空间，且指针变量指向的内存空间中的值也不能再改变！
                int const * const pointer
    4：const使用类型：
        一般多用在函数形参中，如果函数某个形参需要保证不会被函数内部修改，那么就可以使用const修饰！
      





    
    




    
    
    
    
    
    
        





        
        



        
        






               
            
    
        
    



        
    

        

    
        
        



    
    

        

        
    

    

    
    


            


            


                
                


                





                         



