c-多线程
    1：c语言在linux上的多线程编程需要使用POSIX提供的线程库--pthread.h；
    2：POSIX-可移植操作系统接口简称，由IEEE开发，由ISO和ANSY标准化，POSIX标准定义了操作系统应该为应用程序提供的接口集；目的在于使程序在源码上具备系统可移植性；
    3：Linux上使用c语言实现多线程需要引入pthread.h线程库，线程库中的函数全部由pthread_开头；

Linux上pthread线程之间的关系：
    1：main函数所在线程称为主线程，任何其他子线程只能在主线程中创建；
    2：如果在主线程中，即main函数中调用了return或者exit函数，则主线程退出，整个进程也终止运行，其他属于该进程的线程全部退出；
    3：如果在主线程中调用pthread_exit()来退出主线程;则仅仅是主线程结束运行，进程不会结束，进程内的其他线程也不会结束，直到所有线程结束进程才会终止；
    4：在任何一个线程中调用exit函数都会导致进程结束，其余线程也将会结束；
    5：线程中调用pthread_exit()仅仅会终止当前线程，不影响进程的运行，不影响其他线程的运行；

线程结束后资源释放问题：
    1：线程创建之后要么是PTHREAD_CREATE_JOINABLE状态，要么是PTHREAD_CREATE_DETACH状态；
    2：如果线程是PTHREAD_CREATE_JOINABLE状态，那么线程结束后线程所占用的资源必须通过pthread_join()来释放；
    3：如果线程是PTHREAD_CREATE_DETACH状态，那么线程结束后会自动释放所占用的资源；

c-多线程：创建线程
    创建方式：
        pthread_create(pthread_t *thread,const pthread_attr_t * attr,void *(*thread_fun)(void *),void *args);
         参数: thread--创建好的线程的id；
              attr--用于设置线程运行状态的属性；
              thread_fun--是线程被调用的函数；
              args--是线程被调用的函数的参数；
         参数说明: 
            thread:当前创建的线程的id；类型为pthread_t;类型定义为typedef unsigned long int pthread_t;
            attr：设置当前线程运行状态的属性；是 struct pthread_attr_t类型的结构体；该结构体包含以下项：
                    __detachstate,
                        1：表示新线程是否与进程中其他线程脱离同步；默认为PTHREAD_CREATE_JOINABLE状态；
                        2：如果设置为1则脱离同步，新线程将不能使用pthread_join来同步，而且在退出时自行释放所占用的资源；
                        3：如果设置0或者使用默认值，新线程将可以使用pthread_join来同步，也可以在创建运行之后使用pthread_detach()来设置脱离同步；
                        4：一旦设置为PTHREAD_CREATE_DETACH状态，将不能再恢复到PTHREAD_CREATE_JOINABLE状态；
                    __schedpolicy,
                        1：表示新线程的调度策略，包括SCHED_OTHER(正常，非实时)、SCHED_RR(实时，轮转法)和SCHED_FIFO(实时、先入先出)，
                        2：默认是SCHED_OTHER,后两种调度策略进队root用户有效；
                        3：运行时可以通过pthread_setschedparam()来改变；
                    __schedparam，
                        1：struct sched_param结构，目前仅有一个sched_priority整型变量表示线程的运行优先级。
                        2：这个参数仅当调度策略为实时（即SCHED_RR或SCHED_FIFO）时才有效，
                        3：可以在运行时通过pthread_setschedparam()函数来改变，缺省为0。  
                    __inheritsched，
                        1：有两种值可供选择：pthread_EXPLICIT_SCHED和pthread_INHERIT_SCHED，前者表示新线程使用显式指定调度策略和调度参数（即attr中的值），而后者表示继承调用者线程的值。
                        2：缺省为pthread_EXPLICIT_SCHED。  
                    __scop，
                        1：指定线程间竞争cpu的范围；包括仅在当前进程中竞争和系统中所有的进程中竞争；
                        2：POSIX实现了定义了两种标准，pthread_SCOPE_SYSTEM以及pthread_SCOPE_PROCESS，
                        3：目前linuxThreads仅实现了pthread_SCOPE_SYSTEM；即和全部的线程竞争cpu执行时间；
            thread_fun: 当前线程中执行的函数；
                    函数声明类型:void *fun(void *args);
                    备注：1:函数的返回值类型必须是void *;该返回值可以在pthread_join中获取；
                         2:函数接收到的参数是void *类型，因此在函数内部使用参数时需要强制转换为指定的数据类型；
            args: 传给当前线程中执行的函数的参数；
                  被执行函数只能接收一个参数的指针地址，因此多个参数需要使用结构体来包含；并传入结构体的地址；
        备注:1：线程创建只能在main函数中进行；不能在其他子线程中创建线程；
            2：如果不设置线程状态属性，线程创建完成之后将会是PTHREAD_CREATE_JOINABLE(合并)状态；如果需要设置为PTHREAD_CREATE_DETACH(脱离)状态，则可以使用pthread_detach()来设置脱离同步；一旦线程脱离同步将无法再设置为合并状态，线程所占用的资源由线程自身管理；
            3：线程创建完成之后会立即进入争夺cpu状态，等待cpu执行，无需调用其他方法启动线程；
            4：默认情况下，主线程运行结束，当前进程即结束，其他所有子线程无论是否运行完毕都将结束；
    
    等待线程： 可以让当前线程挂起等待指定线程的运行，等指定线程运行完毕之后从挂起处继续执行当前线程；
        等待线程--pthread_join()：
            功能：
                1：等待指定线程运行完毕；然后继续运行当前线程；
                2：管理joinable状态的线程的资源，并接收线程的返回值；
            原型：int pthread_join(pthread_t thread,void **retval)
            参数：thread为指定需要等待的线程id，retval是thread_exit的第一个参数，也即线程的返回值；
            返回值：0代表成功，失败则返回错误号；
            说明：1：该函数可以阻塞当前线程，等待指定线程的运行，等指定线程运行完毕之后才会返回当前线程继续运行；
                 2：如果在线程中使用pthread_join等待多个线程，那么被等待的线程将会一起争用cpu时间片；
                 3：一个线程只能被一个线程等待，不能多个线程等待一个线程，否则第一个接收到信号的线程返回成功，其余调用pthread_join的线程则返回错误码ESRCH；
                 4：pthread_join只能用于处于joinable状态的线程；对于unjoinable状态的线程无法使用pthread_join()；
                 5：pthread_join的另外一个作用在于回收线程所占用的资源；对于joinable状态的线程，如果不使用pthread_join的话该线程的资源将无法被释放；
                 6：pthread_join主要使用场景有两个：
                    1：阻塞当前线程，等待目标线程的执行完成后继续执行当前线程；
                    2：回收处于joinable状态的线程所占用的资源；
    分离线程：
        分离线程--pthread_detach(pthread_t thread);
            功能：分离当前线程；将当前线程状态设置为unjoinable状态(PTHREAD_CREATE_DETACH)；
            原型：int pthread_detach(pthread_t thread)
            参数：需要被分离的线程id
            返回值：0代表分离成功，如果出错将会返回错误码(EINVAL\ESRCH)；
            说明：1：pthread线程有两种状态，默认情况下线程创建完成之后的状态为joinable，该函数将会把线程设置为   unjoinable状态；
                 2：该函数可以在主线程创建完成子线程之后调用，也可以在线程内部调用；
                 3：线程的unjoinable状态可以在创建线程时指定，也可以使用pthread_detach()来设置；
                 4：线程如果处于分离状态(unjoinable)将不能再设置为结合(joinable)状态;
                 5：线程处于分离状态之后，线程所占有的资源在线程结束时自行释放，无需其他线程控制；

    结束线程：
        线程的退出有两种方式：
            1：线程在其主体函数退出时将会自动终止；
            2：在当前线程内部执行pthread_exit()来终止；
        线程结束--pthread_exit():
            功能：退出当前线程，用于在当前线程中的执行函数中调用；
            原型：void pthread_exit(void * value_ptr)
            参数：该参数代表当前线程中执行的函数的返回值；在线程结束时传入，该值可以使用pthread_join的第二个参数获取得到；
            返回值：无；
            说明：1：该函数是一个阻塞的线程函数，调用该函数的线程将只能等待指定线程运行完毕；
                 2：当函数返回时，被等待线程的资源被收回；
                 3：如果主线程中创建了子线程，如果不使用pthread_join的话，主线程结束整个进程也就结束；子线程有可能没有机会执行或者执行不完全！
                 4：为了保证子线程能够执行完毕再退出整个进程有以下几种方式：
                    1：使主线程在子线程结束后再结束主线程；
                    2：主线程结束时使用pthread_exit()结束，此时仅仅结束主线程，并不会结束主进程；
                    3：对于处于joinable状态的子线程使用pthread_join()来阻塞主线程，等待子线程执行完毕；

    取消线程：
        取消线程：线程的运行可由外部其他线程来发送取消命令，进而终止指定线程的运行；
        取消特征：取消线程的运行命令只能由外部的线程下达，取消线程并不等同于直接终止线程的运行；仅仅只是向目标线程发出取消通知；具体如何处理该通知则由目标线程决定；
        取消线程函数：
            int pthread_cancel(pthread thread):
                1：发送终止信号给thread线程，如果发送成功返回0，发送失败则返回非0值；发送成功仅仅只能代表信号被发往指定线程；但并不等同于thread会被终止；
            int pthread_setcancelstate(int state,int *oldstate):
                1：设置本线程对于cancel信号的处理方式；state有两种值：PTHREAD_CANCEL_ENABLE(默认值)和PTHREAD_CANCE_DISABLE;
                2：PTHREAD_CANCEL_ENABLE ：接收到信号之后将当前线程设置为cancel的状态；
                3：PTHREAD_CANCEL_DISABLE : 忽略接收到的信号，继续运行；
                4：old_state如果不为NULL则存入cancel状态以便恢复；
            int pthread_setcanceltype(int type,int *oldtype)
                1：设置本线程取消动作的时机，type有两种值：PTHREAD_CANCEL_DEFFERED和PTHREAD_CANCEL_ASYCHRONOUS；
                2：该函数设置的处理方式仅在cancel为enable时有效；
                3：PTHREAD_CANCEL_DEFFERED表示收到信号之后继续运行到下一个取消点再退出；
                4：PTHREAD_CANCEL_ASYCHRONOUS表示立即执行取消动作；
                3：oldtype如果不为NULL则存入用来存储取消动作类型值
            void pthread_testcancel(void):
                1：该函数用于在不包含取消点，但是又需要一个取消点的地方创建一个取消点；
        取消点：
            1：线程外部向线程发送取消信号之后，是否终止线程的执行，由线程本身决定，可以忽略，可以立即执行取消动作，或者继续运行至取消点；
            2：线程的默认处理是运行到取消点，然后退出；
            3：pthread指定的取消点：
                pthreads标准指定了几个取消点，其中包括：
                (1)通过pthread_testcancel调用以编程方式建立线程取消点。
                (2)线程等待pthread_cond_wait或pthread_cond_timewait()中的特定条件。
                (3)被sigwait(2)阻塞的函数
                (4)一些标准的库调用。通常，这些调用包括线程可基于阻塞的函数。 
            4：根据POSIX标准，pthread_join(),pthread_testcancel(),pthread_cond_wait(),pthread_cond_timedwait(),sem_wait(),sigwait()等函数还有read(),write()等会引起阻塞的系统调用都是取消点；但是pthread_cancel手册声明该库由于与c库结合不好，因而目前c库函数都不是取消点；如果需要将c库函数作为取消点，则需要在c库函数前后分别调用pthread_testcancel();
    线程同步：
        线程同步：由于多个线程共享进程中公共资源；如果同一时刻多个线程同时操作某些资源会导致逻辑错误；此时需要使得线程同步对资源进行操作；
        实现线程同步方式：互斥锁，条件变量，信号量；
        互斥锁：
            
            1：初始化锁：Linux中互斥锁的数据类型是pthread_mutex_t,在使用之前需要先进行初始化：
                静态初始化：
                    pthread_mutex_t mutex = PTHREAD_MUTEX_INITALIZER;
                动态初始化：
                    int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutex_attr_t *mutexattr);
                        功能：动态创建一个互斥锁；
                        参数：mutex:创建的互斥锁指针；
                             mutexattr:指定互斥锁属性；
                        互斥锁属性：
                             1：PTHREAD_MUTEX_TIMED_NP : 默认值，普通锁，一个线程加锁之后其余请求锁的线程将形成一个等待队列，并在解锁之后按照优先级获得锁，这种锁策略保证了资源分配的公平性；
                             2：PTHREAD_MUTEX_RECURSIVE_NP : 嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁；如果是不同线程请求，则在加锁线程解锁时重新竞争；
                             3：PTHREAD_MUTEX_ERRORCHECK_NP : 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同，这样就抱着当不允许多次加锁时不会出现最简单情况下的死锁；
                             4： PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。

            2：加锁：对于共享资源的访问，要进行加锁，如果互斥量已经加锁，那么线程对该资源的访问将会阻塞，直至互斥量解锁；
                int pthread_mutex_lock(pthread_mutex_t *mutex);
                int pthread_mutex_trylock(pthread_mutex_t *mutex);
            3：解锁：在完成对共享资源的访问之后要对互斥量进行解锁；
                int pthread_mutex_unlock(pthread_mutex_t *mutex);
            4：销毁锁：锁在使用完成之后要销毁，释放资源；
                int pthread_mutex_destory(pthread_mutex_t *mutex);
        条件变量：
            1：初始化条件变量：
                静态初始化：pthread_cond_t cond = PTHREAD_COND_INITIALIER;
                动态初始化: int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr);
            2:等待条件成立，释放锁，同事阻塞等待条件变量为真才行。timewait()设置等待时间仍未signal，返回ETIMEOUT(加锁保证只有一个线程wait)
                int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);
                int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);
            3:激活条件变量：
                int pthread_cond_signal(pthread_cond_t *cond);
                int pthread_cond_broadcast(pthread_cond_t *cond);
            4：清除条件变量。无线程等待否咋返回EBUSY
                int pthread_cond_destory(pthread_cond_t *cond);

        信号量：
            1：信号量初始化。
                int sem_init (sem_t *sem , int pshared, unsigned int value);
            这是对由sem指定的信号量进行初始化，设置好它的共享选项(linux 只支持为0，即表示它是当前进程的局部信号量)，然后给它一个初始值VALUE。
            2：等待信号量。给信号量减1，然后等待直到信号量的值大于0。
                int sem_wait(sem_t *sem);
            3：释放信号量。信号量值加1。并通知其他等待线程。
                int sem_post(sem_t *sem);
            4：销毁信号量。用完信号量后都它进行清理。归还占有的一切资源。
                int sem_destroy(sem_t *sem);
            

            

        
        
        



        

            
                    

