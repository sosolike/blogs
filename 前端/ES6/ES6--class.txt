ES--class
    ES5中创建对象：
        1：使用原始的模式创建对象:
            JS中通过{}可以创建一个JS对象，通过这种原始的方式可以基本实现面向对象：
            通过{}创建的JS对象只有属性一个元素，属性的值可以是任意常数，变量，函数，对象；
                var obj = {
                    name:"name_value",              //声明属性;
                    getName:function(){             //声明属性;
                        console.log(this.name);
                    }
                }

        2：通过构造函数：
            1：为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数的模式。
            2：构造函数本质上仍然只是一个普通的函数；但是构造函数中的this关键字和普通函数的this关键字指向不同：普通函数的this关键字指向window顶层对象；构造函数的this关键字指向该构造函数所实例化出来的对象；
            3：通过构造函数创建对象时，构造函数中同样只有一种元素：属性；属性的值可以是任意常数，变量，函数，对象；

            function consfun(){
                this.name = "name_value";       //声明属性;
                this.getName = function(){      //声明属性;
                    console.log(this.name);
                }
            }
            var obj = new consfun();            //创建对象;
            *在obj调用name属性的时候，this关键字指向的是obj*

        3：通过Object创建对象：
            JS中Object仍然是一个构造函数，因此通过Object也可以创建对象；但是每一个通过Object创建的对象都需要通过对象本身来绑定，比较繁琐；也无法实现实例属性的复用；

            var obj = new Object();             //创建对象;
            obj.name = "name_value";            //声明属性;
            obj.getName = function(){           //声明属性;
                console.log(this.name);
            }
        
    ES5中对象的继承：
        原型对象：
            1：原型对象本质上就是一个JavaScript对象；之所以叫做原型对象，是因为其他对象可以继承该对象，并拥有该对象的所有实例属性和实例方法；
            2：JavaScript中每一个函数都会有一个prototype属性，当函数作为普通函数调用时，该属性没有特殊意义；但是作为构造函数存在时，该属性指向一个对象，所指向的对象称作该构造函数的实例对象的原型对象；
            3：每一个JavaScript对象都会有一个__proto__属性，该属性指向该对象的构造函数的prototype属性，即指向对象的原型对象；
            4：每一个JavaScript对象都将会继承原型对象的所有实例属性和方法；
            5：对象在访问属性和方法时，会优先查找对象本身的实例属性和方法，如果找不到将会去对象的原型对象中查找，如果原型对象没有将会去原型对象的原型对象查找，一直到object.prototype，如果还是找不到将会返回undefined;
            6：每一个对象都可以作为其他对象的原型对象，被其他对象继承；

        原型链：
            1：每一个对象都会有一个原型对象，但是原型对象本质上任然是一个普通的js对象，所以原型对象也会有自己的原型对象，以此类推，将会形成一条原型链，代表继承的链条；
            2：原型链的顶端是object.prototype,而object.prototype的值是object对象，object对象的__proto__的值则是null;因此，原型链的顶端是null;
        检测对象所属类：instanceof, 该运算符用来检测左侧的构造函数的原型对象是否在右侧对象的原型链上；如果在则返回true,否则返回false;

        继承：
            构造函数的继承：
                1：构造函数绑定：可以使用call或者apply方法将父对象的构造函数绑定在子对象上即可：
                    实现方式如：
                        function A(){
                            this.name='parent attr';
                        }
                        function a(){
                            this.name = 'children attr';
                            A.apply(this,arguments);
                        }
                    备注：
                        1：通过apply或者call的方式实现继承，本质上是改变继承语句之后this关键字的指向；
                        2：由于改变了子对象中this关键字的指向，将会导致属性的访问不会按照预料之中的方式出现：如上，子对象的构造函数中，this.name声明在继承之前，那么通过子对象访问name属性将会获取父对象的name属性；如果this.name声明在继承之后，那么通过子对象访问name属性将会获取子对象的name属性；
    
    ES5中的对象属性：
        1：在ES5标准中，对象只有属性一个元素；属性的值可以为任意数据类型的常数、变量、函数、其他对象或者其他合法嵌套；
        2：JS中在获取一个对象的属性时，会先去查找对象本身的属性，如果没有找到将会去对象的原型查找，如果原型还没有将会继续去原型的原型查找，一直到object,prototype;如果还没找到将会报undefined;
        3:如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性

    ES6中创建对象：
        ES6标准中引入类(class)的概念，让对象的创建以及使用方式更加接近于传统的面向对象方式；
        类的声明：
            class 类名{
                //类元素
            }
            说明：
                1：class是类的声明关键字；
                2：类的内部默认就是严格模式，因此无需使用use strict指定运行模式；
        类的元素：
            类中包括：
                属性：实例属性、静态属性
                方法：实例方法、静态方法、构造方法
        构造方法：constructor()
            方法声明：constructor(){
                //do something...
            }
            备注：1：constructor是类的构造方法，和传统的面向对象的构造方法一致；
                 2：可以显式的声明构造方法，如果未声明，类会自动创建一个空的构造方法；
                 3：构造方法默认返回当前类的实例，也可显式指定返回其他对象；
        实例方法和静态方法：
            声明：
                实例方法：fun_name(){//do something...}
                静态方法：static fun_name(){//do something...}
            调用：
                类内部调用：
                    实例方法：this.fun_name();
                    静态方法：class_name.fun_name();
                类外部调用：
                    实例方法：obj.fun_name();
                    静态方法：class_name.fun_name();
                说明：静态方法内部不允许使用实例属性以及实例方法；如果必须使用，则需要手动new出一个实例；
        属性：
            实例属性：
                声明：1：可以在类中直接声明实例属性：
                        class Example{
                            myProp = 23;     //在类中声明实例属性；
                        }
                     2：也可以在实例方法或者构造函数中通过this.var_name来声明实例属性；
                        class Example{
                            constructor(){
                                this.myProp1 = 23;  //在构造函数中声明实例属性
                            }
                            fun_a(){
                                this.myProp2 = 24;  //在实例方法中声明实例属性
                            }
                        }
                调用：在类内部：this.var_name;
                     在类外部：obj.var_name;
            静态属性：
                目前只能在类外部通过类名添加类属性；如：
                    class Example{}
                    Example.prop_name = "prop_value";   //添加类属性
                但是目前有提案：在类内部通过static prop_name来声明静态属性；
        对象的创建：
            1：ES6标准中，对象的创建必须通过new关键字实例化类；
            2：ES6标准为new关键字提供了一个target属性，new.target如果作用在构造函数中，则代表当前构造函数，new.target如果作用在类中，则为当前类名；如果在子类中，则new.target返回子类类名；

class的继承：
    继承特征：
        1：ES6标准中，类通过extends继承父类；
        2：子类继承父类之后子类将拥有父类的属性以及方法：
    子类构造函数：
        1：子类构造函数也使用constuctor来创建；
        2：ES5中的继承本质是先创建子类的实例对象this,然后将父类的方法添加都this上面。
           ES6中的继承机制则是先将父类的属性和方法加到this上面，然后再用子类的构造函数修改this;
        3：由于ES6中子类实例的构建是基于父类的实例，只有super方法才能调用父类实例，因此必须在子类的构造函数中调用super方法创建父类实例；如果父类构造函数需要参数，则super()必须按照父类构造函数要求传入参数；
        4：如果子类没有显式的声明构造函数，则系统会默认添加上一个空的构造函数，并使用super()调用父类构造函数；
        5：构造函数中在使用super()之前无法使用this关键字；如果使用将会报错；

    判断父类：
        Object.getPrototypeOf(class_name)  //class_name是子类名称，通过该方法可以判断当前类是否是指定类的子类；该方法只能判断直接父类，无法判断父类的父类；

    子类调用父类属性以及方法：
        在子类内部调用父类属性以及方法需要通过super对象；super关键字在子类实例方法中代表父类原型对象，在子类静态方法中代表父类；
            1：子类实例方法中调用父类实例属性和实例方法：
                super.parent_prop;      
                    //调用父类实例属性；该操作只能调用父类原型链上的属性，无法调用父类实例的属性；
                    //A.prototype.prop_name = 2,子类中通过super.prop_name即可获取该属性值；
                    //如果在类A中实例方法中通过this.prop_name = 2,子类中通过super.prop_name无法获取该属性值；
                super.parent_fun;       
                    //调用父类实例方法；
                备注：
                    1：如果在子类中通过super调用父类方法时，父类方法中的this指向当前子类的实例；
                    2：如果在子类实例方法中调用静态属性以及静态方法则需要直接使用父类类名调用；
            2：子类实例在类外部调用父类方法以及属性直接通过子类实例对象调用父类实例方法以及实例属性即可；
            3：在子类静态方法中调用父类静态属性以及静态方法：
                super.parent_prop;
                super.parent_fun;
            
类的prototype和__proto__属性:
    ES5标准的浏览器中每一个对象都有__proto__属性；指向对应的构造函数的prototype属性；
    ES6标准中，class作为构造函数逇语法糖，同时有prototype属性以及__proto__属性；存在两条继承链；

    1：子类的__proto__属性，表述构造函数的继承，总是指向父类；
    2：子类的prototype属性的__proto__属性表示方法的继承，总是指向父类的prototype属性；
        class A {}
        class B extends A {}
        B.__proto__ === A // true
        B.prototype.__proto__ === A.prototype // true
        原因在于类的继承是通过下面的方式实现的：
            class A{}
            class B{}
            Object.setPrototypeOf(B.prototype,A.prototype); //B的实例继承A的实例
            Object.setPrototypeOf(B,A);     //B继承A的静态属性

        而setPrototypeOf的实现为：
            Object.setPrototypeOf = function(obj,proto){
                obj.__proto__ = proto;
                return obj;
            }
        因此得到最开始的结果；
    

    

            
        



        


            
