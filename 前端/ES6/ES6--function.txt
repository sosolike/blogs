ES6--函数扩展
基本用法：
    函数形参：
        1：函数形参默认值：
            ES5标准中，不允许为形参设置默认值；
            ES6标准中，允许为形参设置默认值；
        2：形参与变量：
            ES5标准中，允许在函数中声明和形参名称相同的变量；
            ES6标准中，不允许在函数中声明和形参名称相同的变量；
        3：形参可以将默认值设置为表达式，但是表达式是惰性求值的，每次调用函数时都会重新计算表达式的值；

        4：默认值的位置可以在形参列表的任意位置，但是如果尾形参没有设置默认值，在调用函数时那么尾形参前面的形参均不能直接跳过；

        5：每个函数都一个length属性，代表该函数的形参个数，但是如果为形参设置了默认值，那么该形参将不会计入length个数中；

        6：形参列表会形成一个单独的作用域；

        7：ES6标准支持rest参数：即以...变量名声明的形参将会接收函数在调用时传入的多余的参数；并以数组的形式保存起来；rest参数必须作为尾参数，即...变量名之后将不能再有其他形参；

    函数名：
        1：ES6标准中为函数提供了name属性，代表函数的名称；
    
    箭头函数：
        1：ES6允许使用=>定义函数：
            如：var sum = (add1,add2)=>{//函数体}
                备注：1：sum是函数的名称；
                     2：(add1,add2)是函数的形参，如果没有形参或者有多个形参就必须使用()；
                     3：{}代表函数的函数体；
                     4：如果只有一个参数则可以省掉形参的()：var sum = add1 => {return add1;}
                     5：如果函数体只有一句表达式，那么可以省略{},箭头左侧的表达式运算结果将会被直接返回:var sum = add1 => add1;

        2：由于{}会被解析为代码块，因此箭头函数如果直接返回一个对象，必须在对象外面加上()否则会报错；
            如：var f = (id)  =>  {id:id,name:"temp"}     //报错
                var f = (id)  =>  ({id:id,name:"temp"})  //不报错
        3：箭头函数的使用：
            1：箭头函数中的this关键字是函数定义时所在的对象，而不是使用时所在的对象；
            2：箭头函数不可以当做构造函数使用，即不可以使用new命令，否则会抛出一个错误；
            3：不可以使用arguments对象，该对象在函数体内不存在，如果需要接收多个参数可以使用rest参数；
            4：不可以使用yield函数，因此箭头函数不能用作generator函数；
            5：箭头函数可以按顺序嵌套；
        4：箭头函数中的this关键字：
            1：箭头函数中没有this关键字，而是使用定义函数时所在对象的this关键字；
            2：因为箭头函数没有this关键字，因此无法使用bind(),call(),apply()改变this的指向；
        5：尾调用优化：
            1：尾调用：在函数的末尾调用另一个函数，称之为尾调用；
                备注：尾调用只能是单纯的在函数结尾处调用某个函数，如果被调用函数存在其他运算或者不在最后一行，则不算尾调用；
            2：尾调用优化：函数在调用其他函数时会在内存中保存调用位置以及内部变量等信息，这些信息称之为调用帧；函数的调用嵌套会形成一个调用栈；但是在ES6中，尾调用无需保存调用帧，因为调用位置在最后一位，调用完成之后函数结束了，无需保存调用位置以及内部变量等信息；这种优化称之为尾调用优化；

            3：尾调用优化的意义--递归：
                递归：函数自己调用自己称之为递归；每一次递归相当于重新调用了函数，就需要保存调用帧；多次调用则会非常消耗内存；但是ES6由于实现了尾调用优化，如果调用函数在源函数的末尾则不会保留调用帧，则不会出现内存爆掉的现象；
            4：js的尾调用优化只在严格模式开启，普通模式不会使用尾调用优化；

            5：如果没有尾递归优化则可以使用一下几种方式实现尾递归优化：
                1：使用蹦床函数：
                    function sunb(f){
                        while(f && f instanceof Function){
                            f = f();
                        }
                        return f;
                    }
                    说明：蹦床函数主要通过while循环来执行一个新的函数，而非通过函数调用执行新的函数，因此不存在调用帧，也不存在调用栈溢出；
                    example:
                        //计算阶乘函数
                        function sun(n,total=1){
                            if(n===1){
                                return total;
                            }
                            return sun(n-1,n*total);
                        }

                        调用时可以通过sunb(sun(7));这种方式执行；
                2：通过
                

            


