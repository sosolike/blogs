ES6---let和const
ES5中创建变量：ES5中创建变量只能通过var关键字或者function关键字创建变量；
ES5--var声明变量：
    1：声明变量的方式： 
        var 变量名=变量值;或者 var 变量名1,变量名2;

    2：变量名称：
        变量名称需要符合JS标识符命名规范，推荐采用驼峰式命名法命名；

    3：变量的作用域：var声明的变量作用域只有两个：
        1：在函数外部通过var声明变量，其作用域是全局作用域，称之为全局变量；
        2：在函数内部通过var声明变量，起作用域是局部作用域，称之为局部变量；
        3：全局变量可以在函数外部以及函数内部访问；局部变量只能在函数内部访问；

    4：变量绑定作用域：
        1：全局变量声明完成之后将会绑定至全局作用域上；
        2：局部变量声明完成之后将会绑定至函数内部；绑定之后，函数内部使用该变量，不再受外部的同名变量影响；
    
    5：变量提升现象：
        无论是全局变量还是局部变量，在声明完成之前访问变量，该变量的值都会被设置为undefined，而不是直接报错，这种现象称之为变量提升现象；

    6：暂时性死区：
        暂时性死区是针对局部变量的，即外部已经声明了指定变量，但是函数内部仍然声明了该变量，那么忧郁变量会绑定作用域以及变量提升现象，会导致局部变量在声明之前访问时出现其值为undefined而不是外部的全局变量的值；这种现象称之为暂时性死区；

    7：var声明变量时，允许声明多个同名变量，变量的值以最后一次声明所赋的值为准；

    8：var声明局部变量时，允许声明和函数形参同名的变量；

    9：var声明的全局变量会被当做顶层对象window的属性；

    10：var声明变量的弊端：1：扩大了变量的作用范围，影响变量的安全性；2：在for循环中会将局部变量暴露为全局变量；

ES6--let声明变量：
    ES6标准中添加了let关键字来声明变量，实现了局部作用域；
    1：声明变量的方式：
        let 变量名=变量值;或者 let 变量名1,变量名2;

    2：变量名称：
        变量名称需要符合JS标识符命名规范，推荐采用驼峰式命名法命名；

    3：变量的作用域：
        let声明的变量作用域只在当前代码块中或者子级代码块中；其作用域称之为局部作用域；

    4：变量绑定作用域：
        1：let声明的变量将会绑定在声明时所在的代码块中；绑定之后，在该代码块中使用该变量将和外部的同名变量无关；
    
    5：无变量提升现象：
        无论是全局变量还是局部变量，在声明完成之前访问变量，该变量的值都会被设置为undefined，而不是直接报错，这种现象称之为变量提升现象；但是ES6中通过let声明的变量无变量提升现象，在变量声明之前访问该变量，将会直接报错；

    6：暂时性死区：
        暂时性死区是针对局部变量的，即外部已经声明了指定变量，但是函数内部仍然声明了该变量，那么忧郁变量会绑定作用域以及变量提升现象，会导致局部变量在声明之前访问时出现其值为undefined而不是外部的全局变量的值；这种现象称之为暂时性死区；

    7：let声明变量时，不允许声明多个同名变量；否则将会报错；

    8：let在函数内部声明变量时，不允许声明和函数形参同名的变量；

    9：let在函数外部声明的变量不会被当做顶层对象window的属性；

    10：let声明变量的优势：缩小了变量的作用域范围，可以保证变量的安全性；特别需要注意的是：
        在for循环中，设置循环变量的代码块是循环体的父级作用域；
            1：如果在循环体中使用let声明变量，那么每循环一次，都将创建一次该变量；
            2：如果在设置循环变量的代码块中使用let声明变量，那么每一次循环，在循环体中该变量都将是一个新的变量，初始值为上一次循环的值；
 
const:
    ES6标准中又添加了一个关键字const，可以声明一个只读变量；
    const功能：声明一个只读变量；

    const使用：const n = "v";(const var_name = "value");

    const特征：
        1：const声明的变量是只读变量，所以在声明的同时就要为其赋值，且只能赋值一次；
        2：const声明的变量不存在变量提升现象；
        3：const在同一个块内不允许声明两个名称相同的只读变量；
        4：const不允许在函数内部声明和形参名称相同的只读变量；
        5：const也存在暂时性死区的现象；

    const本质：
        const本质上并不是保证变量的值不能被修改，而是变量指向的那个内存地址所保存的数据不能被改动；
        1：对于基本类型的数据(数字，字符串，布尔),由于值本身就保存在变量所指向的内存地址；因此也就可以认为该变量的值不能改变；
        2：对于复合数据类型(对象/数组)，由于复合数据类型的变量保存的是数据实际存放位置的地址，因此本质上是该变量所指向的地址不能改变，但是其指向的地址所指向的值本身是可以被修改的；因此如果const声明的变量指向的是符合类型的数据时，数据本身的值是可以改变的，但是不能改变该变量的指向；
        3：对于复合类型的数据，如果需要将数据本身冻结，则需要使用Object.freeze()方法；冻结之后复合数据本身不能再被修改；
            如const foo = Object.freeze({});此时如果foo.prop = 123;将会报错;

顶层对象：
    1：在浏览器窗口中js环境的顶层对象是指window对象，在nodejs中是指global对象；

    2：es5标准中，全局变量被认为是顶层对象的属性；

    3：全局变量作为顶层对象属性的缺陷：
        1：全局变量作为顶层对象的数据无法在编译期间就能够检测到变量未声明的错误，只有运行时才知道；
            (原因在于全局变量有可能是顶层对象的属性创建的，而属性的创建是动态的)

        2：全局变量容易被误创；

        3：全局变量的读写权限过大，全局内任意位置可读可写；不利于模块化编程；
        
    4：es6标准规定：
        1：为了向下兼容，var和function命令声明的全局变量依旧是顶层对象的属性；
        2：let、const、class声明的全局变量不属于顶层对象的属性；


