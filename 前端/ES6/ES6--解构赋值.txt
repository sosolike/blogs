解构赋值
    ES5标准中，变量的赋值只能通过 "=" 来进行；
    ES6标准中，允许按照一定的模式，从数组和对象中提取数据进行赋值；称为解构赋值；
数组结构赋值规则：
    1：数组结构赋值将会把左侧的数组元素按照顺序赋值给右侧的变量：
        如：
            let [a,b,c] = [1,2,3];                      //a=1,b=2,c=3
    
    2：数组解构赋值两边格式(数组元素个数、数组的嵌套顺序)必须保持一致；
        如：
            let [foo,bar,baz] = [1,2,3];                 //foo=1,bar=2,baz=3
            let [[foo],[bar],[baz]] = [[1],[2],[3]];     //foo=1,bar=2,baz=3
            let [a,,c] = [1,2,3];                        //a=1;c=3

    3：数组解构赋值支持批量赋值,右侧变量使用...var_name的形式，将会接收左侧多余的所有数组元素，...var_name必须放置在变量列表的最后面：
        如：
            let [a,...b] = [1,2,3,4];                    //a=1,b=[2,3,4]

    4：如果解构不成功，目标变量的值将为undefined，如果是通过...var_name接收参数不成功，将会是空数组:
        如：
            let [a,b,c] = [1];                           //a=1,b=undefined,c=undefined
            let [a,b,...c] = [1];                        //a=1,b=undefined,c=[]

    5：解构赋值允许指定默认值,并且通过严格模式的相等(===)判断来检测待赋值是否为undefined;只有待赋值为undefined才会使用默认值：
        如：
            let [foo = 1] = [];                          //foo=1;
            let [foo = 1] = [undefned];                  //foo=1;
            let [foo = 1] = [null];                      //foo=null;
    6：默认值可以是表达式，但是该表达式是惰性求值的，只有在用到的时候才会求值；
        如：
            function f() {
                console.log('aaa');
            }
            let [x = f()] = [1];
            由于惰性求值的特性，导致f()函数根本不会执行；因此x的值为1；
    7：默认值可以引用解构赋值的其他变量，但该变量必须在使用之前已经声明过的；
        如：
            let [x=1,y=x]                               //x=1,y=1
    
    8：只要具备Iterator接口，都可以采用数组形式的解构赋值；
        如：
            let [x,y,z] = new Set(['a','b','c']);

                               //x=1,y=1
对象的解构赋值：
    1：对象的解构赋值将会把左侧对象的属性和方法赋值给右侧同名的变量；
        如：let {foo,bar} = {foo:"foo_v",bar:"bar_v"};  //foo=foo_v,bar=bar_v;
           本质上为：
            let {foo:foo,bar:bar} = {foo:"foo_v",bar:"bar_v"};

    2：对象的解构赋值也支持默认值，但是只有左侧的同名属性或者同名方法为undefined时才会使用默认值；

    3：如果变量解构失败，则值为undefined;

    4：对象解构赋值可以互相嵌套，但是嵌套格式必须保持一致；

    5：如果将一个已经声明的变量用于结构赋值，要防止js引擎将左侧表达式理解为一个代码块，而导致语法错误；
        如：
            let x;
            {x} = {x: 1}; // SyntaxError: syntax error
            ({x} = {x: 1});//x=1

    6：对象的解构赋值可以将现有对象的方法赋值给同名变量；
        let {floor,ceil,random} = Math;

    7：数组本质上是特殊的对象；因此可以对数组进行对象属性的结构，此时数组的下标即为属性名；

字符串的解构赋值：
    1：字符串的解构赋值将会把字符串按照字符顺序赋值给右侧的变量；
        如：const [a,b,c,d] = "hello";      //a='h',b='e',c='l',d='l';
    2：字符串的解构赋值支持将字符串长度赋值给右侧变量；
        如：let {length:len} = "hello";     //len = 5;

数值以及布尔值的解构赋值：
    对于数值以及布尔值解构赋值时，会先将左侧的值转换为对象，然后赋值；
        let {toString:s} = 123;
        s === Number.prototype.toString;
    对于null以及undefined无法转换为对象，因此进行解构赋值时将会报错；

圆括号问题：
    在es6中，只有赋值语句的非模式部分才能使用圆括号，变量声明的部分不允许使用圆括号；

结构赋值的常见用法：
    1：变量的声明
    2：交换变量的值
    3：提取数组的数组元素
    4：提取json对象的值

        