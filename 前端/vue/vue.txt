vue.js：
    mvvm前端框架；
    m：      模型，数据修改与操作的逻辑部分；
    v:       视图，即html+css+js组成的前端组件
    vm:      view model ，是一个联通view和model的通道；

    mvvm架构特点：
        1：View只管显示数据以及捕获用户输入的数据；Model只管处理数据；ViewModel则是Model和View之间的双向数据通道，View和Model之间的数据是通过ViewModel进行互通的；
        2：ViewModel不仅仅是View和Model之间数据互通的一个通道，数据在View和Model之间是被双向绑定起来的，即View中数据的变化会立即同步到Model中，Model中数据的变化也会立即反应到View上；

            View:                                    Model:
                |--角色：数据显示中心                       |--角色：数据处理中心             
                |--组成：html+css+js；                     |--组成：处理数据的js代码         
                |--作用：显示数据/捕获用户数据               |--作用：请求数据/处理数据/发送数据


                                        Vue:
                                            |--角色：View和Model之间的连通者；
                                            |--功能：1：提供View和Model之间的数据通道；
                                                    2：根据数据名称绑定View和Model之间的数据；
                                                    3：处理View和Model之间传递的数据；
Vue.js基本
    1：Vue：ViewModel只是一个抽象的概念，一种实现View和Model绑定的方案；vue.js框架则是对于该mvvm中vm的实现；
    2：Vue实例就是一个vm,建立起了dom和数据之间的双向通道，并通过数据名称将dom中的数据和数据中心的数据进行双向绑定；
    3：Vue编程中，尽量避免手动操作dom。vue的思想中，数据才是操作dom的驱动力！
Vue实例的创建：
    1：Vue实例的创建：
        创建方式：    var app = new Vue({});
        参数：Vue实例的创建需要传入一个json对象；
    2: Vue实例对象中的json对象内容：
        var app = new Vue({

            el:"#dom_el",       
                #该vue实例绑定的dom元素域，一般通过#id值绑定，绑定完成后，该dom元素及子元素区域均属于该vue实例的作用域


            data:{
                message:"test_message",
                message2:"test_message2",
            },
                #data中声明一系列的属性，如果需要dom中的数据能够和vue实例中的数据双向互通，则需要通过data中的属性完成


            computed:{
                message3:function(){
                    return this.message;
                }
            },
                #computed中声明计算属性，计算属性本质上是和data中的属性性质相同，调用的时候像调用属性的方式调用即可；
                #getter:通过computed中的属性值需要提供一个方法得到，该方法默认是该属性的getter方法，获取该属性值的时候将会执行该getter方法；
                #setter:computed计算属性也可以添加一个setter方法，在为该属性赋值的时候将会执行该setter方法
                #创建方式： 
                    site: {
                                #以 app.site 获取数据的时候将会执行该方法
                                get: function () {
                                    return this.name + ' ' + this.url
                                },
                                #以 app.site = "value"的时候将会执行该方法
                                set: function (newValue) {
                                    this.name = newValue;
                                }
                          } 
                        

            methods:{  
                loadData:function(data){
                    return data;
                }
            },
                #一切在该vue实例中需要使用到的方法都可以在这里面定义；
                #vue实例的公共方法也可以在vue实例外部声明，然后可以在vue实例中调用；
                #注意，该属性名为methods，而不是method！
                #方法中获取vue实例相关的属性或者方法需要通过this.attr或者this.fun来调用；
            

            watch:{
                message:function(val){
                    alert("message值已经被改变");
                }
            },
                #监控属性，如果某个被监控的属性值发生变化，将会主动执行该方法；其中val是被改变之后的值！
                #也可以通过app.$watch("message",function(old,val){

                })来实现对某一个属性的监控
        })


Vue基本语法：
    1：模板语法：
        1：绑定文本：
            方法1：<div>{{ message }}</div>
            方法2：通过v-text="message"绑定内容，推荐使用v-text指令来绑定内容；

            a: 就是将vue中的属性的值根据名称插入到html元素中；

            b: 在html元素中使用{{ message }} 来占位，message将会和vue实例中的同名属性绑定；
               或者
               通过指令v-text="message"来声明该dom元素中的内容，message将会和vue实例中的message属性绑定

            c: 在vue实例中：
                var vm = new Vue({
                    el:'#el',
                    data:{
                        message:attr_value,
                    }
                })

            d: 一旦html元素中的内容发生变化，同时，vue实例中名为attr_name的值也将发生变化，反之亦然；
            e:dom元素中需要用到的属性必须先进行初始化！

            

        2：绑定HTML：
            绑定方法：<div v-html="html_content_name"></div>

            a: 就是将vue中html_content_name属性的值插入到html元素中；只不过插入的是html；

            b: 在需要被插入的html元素中使用<div v-html="html_content_name"></div> 来设置需要插入到div中的html内容，html_content_name将会和vue实例中的同名属性绑定；

            c: 在vue实例中：
                var vm = new Vue({
                    el:'#el',
                    data:{
                        html_content_name:"<h1>test</h1>",
                    }
                })
            d: 一旦html元素中的html内容发生变化，同时，vue实例中名为html_content_name的值也将发生变化，反之亦然；

            e: 如果使用{{ html_content_name }} 则会吧html元素当初普通的字符串插入其中，并不会解析html元素；

            f：html_content_name 属性必须先进行初始化；

        3：模板语法：
            Vue.js允许在{{}}以及指令结果" "中使用原生js表达式；
            如：
                <div id="app">
                    {{ a+b }}<br>
                    <div v-bind:class="'sclass_' + id"></div>
                </div>

    2: Vue.js中的条件与循环：
        1：条件指令：用于控制元素是否显示：
            条件: v-if="isSeen"
                  v-else-if="isSeen"
                  v-else

            显示指令：v-show="isShow"

            值：
                1：直接写死一个值：v-if=0/v-if=1 来控制是否显示元素；
                2：设置为vue的属性：v-if="attr" 如果attr为true则显示元素，否则隐藏元素；
                3：设置为计算属性：v-if="computed_attr" 如果计算属性返回true则显示元素，否则隐藏元素；
                4：通过原生js表达式判断：v-if="attr > 2" ；可以在""中使用js表达，最终结果为true则显示元素，否则将隐藏元素；

            备注：
                1：控制某个元素是否显示可以使用：
                    v-if='isSeen'
                    或者：
                    v-show="isSeen"

                2：对于复杂的逻辑判断可以使用v-if/v-else-if/v-else来实现；且必须保证指令集在同一个vue实例的作用域内

        2：循环指令：
            v-for指令：遍历指定的数据集和元素
                第一种遍历方式：
                语法：v-for="item in list"
                说明：list为需要被遍历的数据集；(数组或者js对象)
                      item为遍历出来的数据值；
                

                第二种遍历方式：获取键值和键名
                    语法：v-for="(value,key) in list"
                    说明：list为需要被遍历的数据集；(数组或者js对象)
                         value为遍历出来的数据值；key为遍历出来的键名

                第三种遍历方式：获取键值，键名，索引顺序
                    语法：v-for="(value,key,index) in list"
                    说明：list为需要被遍历的数据集；(数组或者js对象)
                         value为遍历出来的数据值；key为遍历出来的键名,index为遍历出来的索引顺序

                第四种遍历方式：迭代整数
                    语法：v-for="n in 10"
                    说明：10为需要被遍历的整数；
                         n为遍历出来的整数值；

                使用遍历出来的值：
                    1：直接通过插值使用：{{ item }}
                    2：设置某个元素的属性：v-bind:href="item"
                    3：和其他字符串拼接之后使用：v-bind:href="['http://example.com/' + item]"
                    4：作为函数的参数传入：@click="click_event(item)"
        3：v-bind:属性绑定指令
            v-bind指令一般用来绑定某个属性的值：

            对于clas属性：
                绑定方式1--将属性值绑定为一个vue属性：v-bind:class="vue_attr"
                        vue实例中的vue_attr会和该class属性双向绑定，

                绑定方式2--将属性值通过一个json对象绑定：v-bind:class="{a:is_a}"
                        此时如果is_a的值是true，将会把a赋值给class；
                        此时如果is_a的值是false,将不会把a赋值给class；
                
                绑定方式3--降属性绑定为一个json对象：v-bind:class="{a:is_a,b:is_b}"   
                        如果is_a的值为true,class的值就是a;
                        如果is_b的值为true,class的值就是b,
                        如果两个都是true,则属性值为最后一个；反之则谁都不是；
                绑定方式4--绑定为一个计算属性/方法：v-bind:class="computed_attr"
                        计算属性或者方法可以返回一个具体的值，或者返回一个json对象；

        对于style属性：
            可以使用v-bind指令将css样式属性绑定到style属性上；样式的属性值可以通过vue对象的属性动态改变；
            绑定方式1：直接赋值，只将样式属性值绑定到vue对象的属性；
                v-bind:style="{color:activeColor,fontSize:fontSize+'px'}"
                    此时style具备的样式属性直接在指令的值中声明了，样式属性的值则可以通过vue对象修改属性来动态改变；
            绑定方式2：
                v-bind:style="vue_attr":
                    此时将整个style的值都绑定在vue_attr中，vue_attr则通过json对象来设置css样式属性；
                    <div v-bind:style="styleObject">示例</div>
                    data: {
                        styleObject: {
                            color: 'green',
                            fontSize: '30px'
                        }
                    }
        对于其他自定义的属性，绑定方式和class属性绑定基本相同；

    4：事件监听：v-on
        作用：通过v-on来监听元素的某个事件；

        使用方式：v-on:eventName="eventDoer"; 
                如： v-on:click="eventDoer";eventDoer是该事件的处理器；
        
        事件处理器：
            1：通过methods中的函数处理
            2：通过computed计算属性处理
                区别在于：如果处理器定义在computed中，初始化的时候就会执行一次事件；定义在methods中则不会，只有触发时才会执行处理器；
            3：通过js表达式直接处理
        事件修饰符：        
            .stop          ：阻止事件冒泡
            .prevent       ：
            .capture
            .self          ：只当事件在元素本身而不是子元素触发时回调！
            .once          ：该事件只能执行一次；
        按键修饰符：监听按键：v-on:keyup:n 监听键盘码为n的的按键   
            .enter                监听：enter按键
            .tab                  监听：tab按键
            .delete               监听："删除" 和 "退格"
            .esc                  监听：esc按键
            .space                监听：space按键
            .up                   监听：up按键
            .down                 监听：down按键
            .left                 监听：left按键
            .right                监听：right 按键
            .ctrl                 监听：ctrl 按键
            .alt                  监听：alt 按键
            .shift                监听：shift 按键
            .meta                 监听：meta 按键
    7：表单元素：
        v-model指令：v-model指令用在表单元素中代表表单元素的value值；

        使用方式：v-model="value_name"   value_name代表该表单元素的value值；
        
        表单元素的value值一般通过v-model指令来创建双向绑定；

    8：组件
        所谓组件就是被封装起来的一段html代码，通过把html代码封装成组件来实现html代码块的重复利用；

        全局组件：将组件注册给Vue，则所有的vue实例锁绑定的dom块中都可以使用改组件！；
        局部组件：将组件注册给某个Vue实例对象，则该组件只能在该Vue实例所绑定的dom块中使用，不能在其他地方使用；

        组件的创建：
            创建全局组件：
                Vue.component('component_name', {
                    template: '<h1>自定义组件!</h1>'
                })
            创建局部组件：
                new Vue({
                    el:"",
                    components:{
                        components_name:{
                            template:"html"
                        }
                    }
                })
        父子组件：
            组件：就是包含了html,css,js的一段代码；

            父子组件：如果某个组件中包含了其他组件，其他组件就称为子组件，该组件就称为父组件；

            如：<div id="app" message="hellow">
                    <roub></roub>
                </div>
            此时<roub>被引用，roub就是子组件，对应的div就是父组件；

            组件是一个相对的概念

        父子组件之间的通信：
            父子组件之间通过props来通信：
            通信方式有两种：静态prop和动态prop
            静态通信：
                <body>
                    <div id="app" message="hellow">
                        <roub message="hello"></roub>
                    </div>
                    
                </body>
                <script type="text/javascript">
                    var vm = new Vue({
                        el:"#app",
                        components:{
                            'roub':
                            {
                                template: "<h2>{{ message }}局部组件</h2>",
                                props:["message"],
                            }
                        }
                    });

                roub就是一个子组件， hello就是传递给子组件roub的内容，内容的名称是message；roub中想要使用hello就必须在component中通过props显示声明需要接收的参数：props:["message"], 意思就是子组件roub要接收名为message的参数；接着，template中就可以使用message这个参数了
            动态通信：
                动态通信和静态通信一样，只不过传递到子组件中的值是动态可变的；
                如下例：传入子组件的参数名依然是message，依然需要在子组件中通过props声明出需要接收的参数名；
                        动态则体现在通过v-bind指令绑定了message的值，其值由Vue实例的parentMsg属性决定而已；v-model='parentMsg'只是为了获取input输入的值而已；
                    <div id="app">
                        <div>
                            <input v-model="parentMsg">
                            <br>
                            <child v-bind:message="parentMsg"></child>
                        </div>
                    </div>
                    
                    <script>
                        // 注册
                        Vue.component('child', {
                        // 声明 props
                        props: ['message'],
                        // 同样也可以在 vm 实例中像 "this.message" 这样使用
                        template: '<span>{{ message }}</span>'
                    })
            


            



        

        



        



            


    
